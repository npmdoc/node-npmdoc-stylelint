<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://stylelint.io">stylelint (v7.10.1)</a>
</h1>
<h4>A mighty, modern CSS linter.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint">module stylelint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.stylelint">
            function <span class="apidocSignatureSpan"></span>stylelint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.createLinter">
            function <span class="apidocSignatureSpan">stylelint.</span>createLinter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.createPlugin">
            function <span class="apidocSignatureSpan">stylelint.</span>createPlugin
            <span class="apidocSignatureSpan">(ruleName, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.createRuleTester">
            function <span class="apidocSignatureSpan">stylelint.</span>createRuleTester
            <span class="apidocSignatureSpan">(equalityCheck)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.lint">
            function <span class="apidocSignatureSpan">stylelint.</span>lint
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.postcssPlugin">
            function <span class="apidocSignatureSpan">stylelint.</span>postcssPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.process">
            function <span class="apidocSignatureSpan">stylelint.</span>process
            <span class="apidocSignatureSpan">(root, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.</span>augmentConfig</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.</span>formatters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.</span>rules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.augmentConfig">module stylelint.augmentConfig</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.augmentConfig.augmentConfigExtended">
            function <span class="apidocSignatureSpan">stylelint.augmentConfig.</span>augmentConfigExtended
            <span class="apidocSignatureSpan">( stylelint, cosmiconfigResultArg )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.augmentConfig.augmentConfigFull">
            function <span class="apidocSignatureSpan">stylelint.augmentConfig.</span>augmentConfigFull
            <span class="apidocSignatureSpan">( stylelint, cosmiconfigResultArg )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.formatters">module stylelint.formatters</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.formatters.json">
            function <span class="apidocSignatureSpan">stylelint.formatters.</span>json
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.formatters.string">
            function <span class="apidocSignatureSpan">stylelint.formatters.</span>string
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.formatters.verbose">
            function <span class="apidocSignatureSpan">stylelint.formatters.</span>verbose
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.postcssPlugin">module stylelint.postcssPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.postcssPlugin.postcssPlugin">
            function <span class="apidocSignatureSpan">stylelint.</span>postcssPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.postcssPlugin.createLinter">
            function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>createLinter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.postcssPlugin.createPlugin">
            function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>createPlugin
            <span class="apidocSignatureSpan">(ruleName, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.postcssPlugin.createRuleTester">
            function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>createRuleTester
            <span class="apidocSignatureSpan">(equalityCheck)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.postcssPlugin.lint">
            function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>lint
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.postcssPlugin.process">
            function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>process
            <span class="apidocSignatureSpan">(root, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>formatters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>rules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.rules">module stylelint.rules</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-blacklist
            <span class="apidocSignatureSpan">(blacklistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-name-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-name-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-name-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-semicolon-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-semicolon-newline-after
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-semicolon-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-semicolon-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-whitelist
            <span class="apidocSignatureSpan">(whitelistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-empty-line-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-newline-after
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-no-empty">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-no-empty
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-no-single-line">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-no-single-line
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-opening-brace-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-opening-brace-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-opening-brace-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-opening-brace-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-space-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-hex-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-hex-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-hex-length">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-hex-length
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-named">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-named
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-no-hex">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-no-hex
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-no-invalid-hex">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-no-invalid-hex
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.comment-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.comment-no-empty">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-no-empty
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.comment-whitespace-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-whitespace-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.comment-word-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-word-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.custom-media-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-media-pattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.custom-property-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.custom-property-no-outside-root">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-no-outside-root
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.custom-property-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-pattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-bang-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-bang-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-bang-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-bang-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-no-duplicate-properties">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-duplicate-properties
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-no-ignored-properties">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-ignored-properties
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-no-redundant-longhand-properties">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-redundant-longhand-properties
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-no-shorthand-property-overrides">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-shorthand-property-overrides
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-properties-order">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-properties-order
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-semicolon-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-semicolon-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-semicolon-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-semicolon-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-single-line-max-declarations">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-single-line-max-declarations
            <span class="apidocSignatureSpan">(quantity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-trailing-semicolon">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-trailing-semicolon
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-colon-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-colon-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-colon-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-no-important">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-no-important
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-property-unit-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-unit-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-property-unit-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-unit-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-property-value-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-value-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-property-value-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-value-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.font-family-name-quotes">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>font-family-name-quotes
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.font-family-no-duplicate-names">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>font-family-no-duplicate-names
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.font-weight-notation">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>font-weight-notation
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-calc-no-unspaced-operator">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-calc-no-unspaced-operator
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-comma-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-comma-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-comma-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-comma-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-linear-gradient-no-nonstandard-direction">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-linear-gradient-no-nonstandard-direction
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-max-empty-lines">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-max-empty-lines
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-name-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-name-case
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-parentheses-newline-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-parentheses-newline-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-parentheses-space-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-parentheses-space-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-url-data-uris">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-data-uris
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-url-no-scheme-relative">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-no-scheme-relative
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-url-quotes">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-quotes
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-url-scheme-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-scheme-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-whitelist
            <span class="apidocSignatureSpan">(whitelistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-whitespace-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-whitespace-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.indentation">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>indentation
            <span class="apidocSignatureSpan">(space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.keyframe-declaration-no-important">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>keyframe-declaration-no-important
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.length-zero-no-unit">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>length-zero-no-unit
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.max-empty-lines">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>max-empty-lines
            <span class="apidocSignatureSpan">(max, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.max-line-length">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>max-line-length
            <span class="apidocSignatureSpan">(maxLength, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.max-nesting-depth">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>max-nesting-depth
            <span class="apidocSignatureSpan">(max, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-colon-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-colon-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-colon-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-colon-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-no-missing-punctuation">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-no-missing-punctuation
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-parentheses-space-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-parentheses-space-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-range-operator-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-range-operator-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-range-operator-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-range-operator-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-query-list-comma-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-query-list-comma-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-query-list-comma-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-query-list-comma-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-browser-hacks">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-browser-hacks
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-descending-specificity">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-descending-specificity
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-duplicate-selectors">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-duplicate-selectors
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-empty-source">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-empty-source
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-eol-whitespace">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-eol-whitespace
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-extra-semicolons">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-extra-semicolons
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-indistinguishable-colors">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-indistinguishable-colors
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-invalid-double-slash-comments">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-invalid-double-slash-comments
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-missing-end-of-source-newline">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-missing-end-of-source-newline
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-unknown-animations">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-unknown-animations
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-unsupported-browser-features">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-unsupported-browser-features
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.number-leading-zero">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>number-leading-zero
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.number-max-precision">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>number-max-precision
            <span class="apidocSignatureSpan">(precision)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.number-no-trailing-zeros">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>number-no-trailing-zeros
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.root-no-standard-properties">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>root-no-standard-properties
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.rule-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.rule-nested-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-nested-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.rule-non-nested-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-non-nested-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-brackets-space-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-brackets-space-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-operator-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-blacklist
            <span class="apidocSignatureSpan">(blacklistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-operator-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-operator-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-operator-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-whitelist
            <span class="apidocSignatureSpan">(whitelistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-quotes">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-quotes
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-class-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-class-pattern
            <span class="apidocSignatureSpan">(pattern, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-combinator-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-combinator-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-combinator-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-combinator-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-descendant-combinator-no-non-space">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-descendant-combinator-no-non-space
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-id-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-id-pattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-list-comma-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-list-comma-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-list-comma-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-list-comma-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-max-compound-selectors">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-compound-selectors
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-max-empty-lines">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-empty-lines
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-max-specificity">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-specificity
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-nested-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-nested-pattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-attribute">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-attribute
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-combinator">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-combinator
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-empty">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-empty
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-id">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-id
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-qualifying-type">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-qualifying-type
            <span class="apidocSignatureSpan">(enabled, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-type">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-type
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-universal">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-universal
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-parentheses-space-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-parentheses-space-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-element-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-element-colon-notation">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-colon-notation
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-element-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-root-no-composition">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-root-no-composition
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-type-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-type-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-type-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-type-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.shorthand-property-no-redundant-values">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>shorthand-property-no-redundant-values
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.string-no-newline">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>string-no-newline
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.string-quotes">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>string-quotes
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.stylelint-disable-reason">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>stylelint-disable-reason
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.time-min-milliseconds">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>time-min-milliseconds
            <span class="apidocSignatureSpan">(minimum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.time-no-imperceptible">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>time-no-imperceptible
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.unit-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-blacklist
            <span class="apidocSignatureSpan">(blacklistInput, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.unit-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.unit-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.unit-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-whitelist
            <span class="apidocSignatureSpan">(whitelistInput, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-keyword-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-keyword-case
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-comma-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-comma-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-comma-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-comma-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-max-empty-lines">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-max-empty-lines
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.utils">module stylelint.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.utils.checkAgainstRule">
            function <span class="apidocSignatureSpan">stylelint.utils.</span>checkAgainstRule
            <span class="apidocSignatureSpan">( options, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.utils.report">
            function <span class="apidocSignatureSpan">stylelint.utils.</span>report
            <span class="apidocSignatureSpan">(violation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.utils.ruleMessages">
            function <span class="apidocSignatureSpan">stylelint.utils.</span>ruleMessages
            <span class="apidocSignatureSpan">( ruleName, messages )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.utils.validateOptions">
            function <span class="apidocSignatureSpan">stylelint.utils.</span>validateOptions
            <span class="apidocSignatureSpan">( result, ruleName )</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint" id="apidoc.module.stylelint">module stylelint</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.stylelint" id="apidoc.element.stylelint.stylelint">
        function <span class="apidocSignatureSpan"></span>stylelint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function creator() {
  var transformer = initializer.apply(undefined, arguments);
  transformer.postcssPlugin = name;
  transformer.postcssVersion = new _processor2.default().version;
  return transformer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.createLinter" id="apidoc.element.stylelint.createLinter">
        function <span class="apidocSignatureSpan">stylelint.</span>createLinter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createLinter = function (options)/*: stylelint$internalApi*/ {
  options = options || {}
  const stylelint/*: Object*/ = { _options: options }

  // Two separate explorers so they can each have their own transform
  // function whose results are cached by cosmiconfig
  stylelint._fullExplorer = cosmiconfig("stylelint", {
    argv: false,
    rcExtensions: true,
    transform: _.partial(augmentConfig.augmentConfigFull, stylelint),
  })
  stylelint._extendExplorer = cosmiconfig(null, {
    argv: false,
    transform: _.partial(augmentConfig.augmentConfigExtended, stylelint),
  })

  stylelint._specifiedConfigCache = new Map()
  stylelint._postcssResultCache = new Map()
  stylelint._createStylelintResult = _.partial(createStylelintResult, stylelint)
  stylelint._getPostcssResult = _.partial(getPostcssResult, stylelint)
  stylelint._lintSource = _.partial(lintSource, stylelint)

  stylelint.getConfigForFile = _.partial(getConfigForFile, stylelint)
  stylelint.isPathIgnored = _.partial(isPathIgnored, stylelint)

  return stylelint
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.createPlugin" id="apidoc.element.stylelint.createPlugin">
        function <span class="apidocSignatureSpan">stylelint.</span>createPlugin
        <span class="apidocSignatureSpan">(ruleName, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPlugin = function (ruleName, rule) {
  return {
    ruleName,
    rule,
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.createRuleTester" id="apidoc.element.stylelint.createRuleTester">
        function <span class="apidocSignatureSpan">stylelint.</span>createRuleTester
        <span class="apidocSignatureSpan">(equalityCheck)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createRuleTester = function (equalityCheck) {
  return function (rule, schema) {
    const alreadyHadOnlyTest = !!onlyTest
    if (schema.accept) {
      schema.accept.forEach(_.partial(checkCaseForOnly, "accept"))
    }

    if (schema.reject) {
      schema.reject.forEach(_.partial(checkCaseForOnly, "reject"))
    }

    if (onlyTest) {
      schema = _.assign(_.omit(schema, [ "accept", "reject" ]), {
        skipBasicChecks: true,
        [onlyTest.type]: [onlyTest.case],
      })
    }

    if (!alreadyHadOnlyTest) {
      process.nextTick(() =&gt; {
        processGroup(rule, schema, equalityCheck)
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.lint" id="apidoc.element.stylelint.lint">
        function <span class="apidocSignatureSpan">stylelint.</span>lint
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lint = function (options)/*: Promise&lt;stylelint$standaloneReturnValue&gt;*/ {
  const files = options.files
  const code = options.code
  const codeFilename = options.codeFilename
  const config = options.config
  const configFile = options.configFile
  const configBasedir = options.configBasedir
  const configOverrides = options.configOverrides
  const ignoreDisables = options.ignoreDisables
  const ignorePath = options.ignorePath
  const reportNeedlessDisables = options.reportNeedlessDisables
  const formatter = options.formatter
  const syntax = options.syntax
  const customSyntax = options.customSyntax
  const allowEmptyInput = options.allowEmptyInput
  const cacheLocation = options.cacheLocation
  const useCache = options.cache || false
  let fileCache

  const startTime = Date.now()

  const isValidCode = typeof code === "string"
  if (!files &amp;&amp; !isValidCode || files &amp;&amp; (code || isValidCode)) {
    throw new Error("You must pass stylelint a `files` glob or a `code` string, though not both")
  }

  let formatterFunction
  if (typeof formatter === "string") {
    formatterFunction = formatters[formatter]
    if (formatterFunction === undefined) {
      return Promise.reject(new Error("You must use a valid formatter option: 'json', 'string', 'verbose', or a function"))
    }
  } else if (typeof formatter === "function") {
    formatterFunction = formatter
  } else {
    formatterFunction = formatters.json
  }

  const stylelint = createStylelint({
    config,
    configFile,
    configBasedir,
    configOverrides,
    ignoreDisables,
    ignorePath,
    reportNeedlessDisables,
    syntax,
    customSyntax,
  })

  if (!files) {
    const absoluteCodeFilename = (codeFilename !== undefined &amp;&amp; !path.isAbsolute(codeFilename))
      ? path.join(process.cwd(), codeFilename)
      : codeFilename
    return stylelint._lintSource({
      code,
      codeFilename: absoluteCodeFilename,
    }).then(postcssResult =&gt; {
      return stylelint._createStylelintResult(postcssResult)
    }).catch(handleError).then(stylelintResult =&gt; {
      return prepareReturnValue([stylelintResult])
    })
  }

  let fileList = files
  if (typeof fileList === "string") {
    fileList = [fileList]
  }
  fileList = fileList.concat(
    alwaysIgnoredGlobs.map(file =&gt; "!" + file)
  )

  if (useCache) {
    const stylelintVersion = pkg.version
    const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config)}`)
    fileCache = new FileCache(cacheLocation, hashOfConfig)
  } else {
    // No need to calculate hash here, we just want to delete cache file.
    fileCache = new FileCache(cacheLocation)
    // Remove cache file if cache option is disabled
    fileCache.destroy()
  }

  return globby(fileList).then(filePaths =&gt; {
    if (!filePaths.length) {
      if (allowEmptyInput === undefined || !allowEmptyInput) {
        const message = (files =&gt; {
          if (typeof files === "string") {
            return `${files} does`
          }
          // seperate files into last (last file) and initial) all the others
          const initial = files.slice(0)
          const last = initial.pop()
          // join into a comma seperated string of file names
          const ending = (files.length &gt; 1 ? `and ${last} do` : `${last} does`)
          return `${initial.join(", ")} ${ending}`.trim()
        })(files) + " not match any files"

        const err/*: Object*/ = new Error(message)
        err.code = 80
        throw err
      } else {
        return Promise.all([])
      }
    }

    let absoluteFilePaths = filePaths.map(filePath =&gt; {
      const absoluteFilepath = (!path.isAbsolute(filePath))
        ? path.join(process.cwd(), filePath)
        : path.normalize(filePath)
      return absoluteFilepath
    })

    if (useCache) {
      absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache))
    }

    const getStylelintResults = absoluteFilePaths.map(absoluteFilepath =&gt; {
      debug(`Processing ${absoluteFilepath}`)
      return stylelint._lintSource({
        filePath: absoluteFilepath,
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.postcssPlugin" id="apidoc.element.stylelint.postcssPlugin">
        function <span class="apidocSignatureSpan">stylelint.</span>postcssPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function creator() {
  var transformer = initializer.apply(undefined, arguments);
  transformer.postcssPlugin = name;
  transformer.postcssVersion = new _processor2.default().version;
  return transformer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.process" id="apidoc.element.stylelint.process">
        function <span class="apidocSignatureSpan">stylelint.</span>process
        <span class="apidocSignatureSpan">(root, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (root, opts) {
  return postcss([creator(opts)]).process(root, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    let preProcessedCode = code
    if (options.codeProcessors) {
      options.codeProcessors.forEach(codeProcessor =&gt; {
        preProcessedCode = codeProcessor(preProcessedCode, source)
      })
    }

    return postcssProcessor.<span class="apidocCodeKeywordSpan">process</span>(preProcessedCode, postcssOptions)
  }).then(postcssResult =&gt; {
    stylelint._postcssResultCache.set(options.filePath, postcssResult)
    return postcssResult
  })
}

function readFile(filePath/*: string*/)/*: Promise&lt;string&gt;*/ {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.augmentConfig" id="apidoc.module.stylelint.augmentConfig">module stylelint.augmentConfig</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.augmentConfig.augmentConfigExtended" id="apidoc.element.stylelint.augmentConfig.augmentConfigExtended">
        function <span class="apidocSignatureSpan">stylelint.augmentConfig.</span>augmentConfigExtended
        <span class="apidocSignatureSpan">( stylelint, cosmiconfigResultArg )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function augmentConfigExtended( stylelint, cosmiconfigResultArg )/*: Promise&lt;?{ config: stylelint$config, filepath: string }&gt;*/ {
  const cosmiconfigResult = cosmiconfigResultArg // Lock in for Flow
  if (!cosmiconfigResult) return Promise.resolve(null)

  const configDir = path.dirname(cosmiconfigResult.filepath || "")
  const cleanedConfig = _.omit(cosmiconfigResult.config, "ignoreFiles")
  return augmentConfigBasic(stylelint, cleanedConfig, configDir).then(augmentedConfig =&gt; {
    return {
      config: augmentedConfig,
      filepath: cosmiconfigResult.filepath,
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.augmentConfig.augmentConfigFull" id="apidoc.element.stylelint.augmentConfig.augmentConfigFull">
        function <span class="apidocSignatureSpan">stylelint.augmentConfig.</span>augmentConfigFull
        <span class="apidocSignatureSpan">( stylelint, cosmiconfigResultArg )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function augmentConfigFull( stylelint, cosmiconfigResultArg )/*: Promise&lt;?{ config: stylelint$config, filepath: string }&gt;*/ {
  const cosmiconfigResult = cosmiconfigResultArg // Lock in for Flow
  if (!cosmiconfigResult) return Promise.resolve(null)

  const config = cosmiconfigResult.config,
    filepath = cosmiconfigResult.filepath

  const configDir = stylelint._options.configBasedir || path.dirname(filepath || "")

  return augmentConfigBasic(stylelint, config, configDir, true).then(augmentedConfig =&gt; {
    return addIgnorePatterns(stylelint, augmentedConfig)
  }).then(augmentedConfig =&gt; {
    return addPluginFunctions(augmentedConfig)
  }).then(augmentedConfig =&gt; {
    return addProcessorFunctions(augmentedConfig)
  }).then(augmentedConfig =&gt; {
    if (!augmentedConfig.rules) {
      throw configurationError("No rules found within configuration. Have you provided a \"rules\" property?")
    }

    return normalizeAllRuleSettings(augmentedConfig)
  }).then(augmentedConfig =&gt; {
    return {
      config: augmentedConfig,
      filepath: cosmiconfigResult.filepath,
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.formatters" id="apidoc.module.stylelint.formatters">module stylelint.formatters</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.formatters.json" id="apidoc.element.stylelint.formatters.json">
        function <span class="apidocSignatureSpan">stylelint.formatters.</span>json
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (results) {
  const cleanedResults = results.map(result =&gt; {
    return _.omitBy(result, (value, key) =&gt; key[0] === "_")
  })
  return JSON.stringify(cleanedResults)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.formatters.string" id="apidoc.element.stylelint.formatters.string">
        function <span class="apidocSignatureSpan">stylelint.formatters.</span>string
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function (results) {
  let output = invalidOptionsFormatter(results)
  output += deprecationsFormatter(results)

  output = results.reduce((output, result) =&gt; {
    output += formatter(result.warnings, result.source)
    return output
  }, output)

  // Ensure consistent padding
  output = output.trim()

  if (output !== "") {
    output = "\n" + output + "\n\n"
  }

  return output
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.formatters.verbose" id="apidoc.element.stylelint.formatters.verbose">
        function <span class="apidocSignatureSpan">stylelint.formatters.</span>verbose
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verbose = function (results) {
  let output = stringFormatter(results)

  if (output === "") {
    output = "\n"
  }

  const sourceWord = results.length &gt; 1 ? "sources" : "source"
  const ignoredCount = results.filter(result =&gt; result.ignored).length
  const checkedDisplay = ignoredCount ? `${results.length - ignoredCount} of ${results.length}` : results.length
  output += chalk.underline(`${checkedDisplay} ${sourceWord} checked\n`)
  results.forEach(result =&gt; {
    let formatting = "green"
    if (result.errored) {
      formatting = "red"
    } else if (result.warnings.length) {
      formatting = "yellow"
    } else if (result.ignored) {
      formatting = "dim"
    }
    let sourceText = `${result.source}`
    if (result.ignored) {
      sourceText += " (ignored)"
    }
    output += _.get(chalk, formatting)(` ${sourceText}\n`)
  })

  const warnings = _.flatten(results.map(r =&gt; r.warnings))
  const warningsBySeverity = _.groupBy(warnings, "severity")
  const problemWord = warnings.length === 1 ? "problem" : "problems"

  output += chalk.underline(`\n${warnings.length} ${problemWord} found\n`)

  _.forOwn(warningsBySeverity, (warningList, severityLevel) =&gt; {
    const warningsByRule = _.groupBy(warningList, "rule")
    output += ` severity level "${severityLevel}": ${warningList.length}\n`
    _.forOwn(warningsByRule, (list, rule) =&gt; {
      output += chalk.dim(`  ${rule}: ${list.length}\n`)
    })
  })

  return output + "\n"
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.postcssPlugin" id="apidoc.module.stylelint.postcssPlugin">module stylelint.postcssPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.postcssPlugin.postcssPlugin" id="apidoc.element.stylelint.postcssPlugin.postcssPlugin">
        function <span class="apidocSignatureSpan">stylelint.</span>postcssPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function creator() {
  var transformer = initializer.apply(undefined, arguments);
  transformer.postcssPlugin = name;
  transformer.postcssVersion = new _processor2.default().version;
  return transformer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.postcssPlugin.createLinter" id="apidoc.element.stylelint.postcssPlugin.createLinter">
        function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>createLinter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createLinter = function (options)/*: stylelint$internalApi*/ {
  options = options || {}
  const stylelint/*: Object*/ = { _options: options }

  // Two separate explorers so they can each have their own transform
  // function whose results are cached by cosmiconfig
  stylelint._fullExplorer = cosmiconfig("stylelint", {
    argv: false,
    rcExtensions: true,
    transform: _.partial(augmentConfig.augmentConfigFull, stylelint),
  })
  stylelint._extendExplorer = cosmiconfig(null, {
    argv: false,
    transform: _.partial(augmentConfig.augmentConfigExtended, stylelint),
  })

  stylelint._specifiedConfigCache = new Map()
  stylelint._postcssResultCache = new Map()
  stylelint._createStylelintResult = _.partial(createStylelintResult, stylelint)
  stylelint._getPostcssResult = _.partial(getPostcssResult, stylelint)
  stylelint._lintSource = _.partial(lintSource, stylelint)

  stylelint.getConfigForFile = _.partial(getConfigForFile, stylelint)
  stylelint.isPathIgnored = _.partial(isPathIgnored, stylelint)

  return stylelint
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.postcssPlugin.createPlugin" id="apidoc.element.stylelint.postcssPlugin.createPlugin">
        function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>createPlugin
        <span class="apidocSignatureSpan">(ruleName, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPlugin = function (ruleName, rule) {
  return {
    ruleName,
    rule,
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.postcssPlugin.createRuleTester" id="apidoc.element.stylelint.postcssPlugin.createRuleTester">
        function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>createRuleTester
        <span class="apidocSignatureSpan">(equalityCheck)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createRuleTester = function (equalityCheck) {
  return function (rule, schema) {
    const alreadyHadOnlyTest = !!onlyTest
    if (schema.accept) {
      schema.accept.forEach(_.partial(checkCaseForOnly, "accept"))
    }

    if (schema.reject) {
      schema.reject.forEach(_.partial(checkCaseForOnly, "reject"))
    }

    if (onlyTest) {
      schema = _.assign(_.omit(schema, [ "accept", "reject" ]), {
        skipBasicChecks: true,
        [onlyTest.type]: [onlyTest.case],
      })
    }

    if (!alreadyHadOnlyTest) {
      process.nextTick(() =&gt; {
        processGroup(rule, schema, equalityCheck)
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.postcssPlugin.lint" id="apidoc.element.stylelint.postcssPlugin.lint">
        function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>lint
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lint = function (options)/*: Promise&lt;stylelint$standaloneReturnValue&gt;*/ {
  const files = options.files
  const code = options.code
  const codeFilename = options.codeFilename
  const config = options.config
  const configFile = options.configFile
  const configBasedir = options.configBasedir
  const configOverrides = options.configOverrides
  const ignoreDisables = options.ignoreDisables
  const ignorePath = options.ignorePath
  const reportNeedlessDisables = options.reportNeedlessDisables
  const formatter = options.formatter
  const syntax = options.syntax
  const customSyntax = options.customSyntax
  const allowEmptyInput = options.allowEmptyInput
  const cacheLocation = options.cacheLocation
  const useCache = options.cache || false
  let fileCache

  const startTime = Date.now()

  const isValidCode = typeof code === "string"
  if (!files &amp;&amp; !isValidCode || files &amp;&amp; (code || isValidCode)) {
    throw new Error("You must pass stylelint a `files` glob or a `code` string, though not both")
  }

  let formatterFunction
  if (typeof formatter === "string") {
    formatterFunction = formatters[formatter]
    if (formatterFunction === undefined) {
      return Promise.reject(new Error("You must use a valid formatter option: 'json', 'string', 'verbose', or a function"))
    }
  } else if (typeof formatter === "function") {
    formatterFunction = formatter
  } else {
    formatterFunction = formatters.json
  }

  const stylelint = createStylelint({
    config,
    configFile,
    configBasedir,
    configOverrides,
    ignoreDisables,
    ignorePath,
    reportNeedlessDisables,
    syntax,
    customSyntax,
  })

  if (!files) {
    const absoluteCodeFilename = (codeFilename !== undefined &amp;&amp; !path.isAbsolute(codeFilename))
      ? path.join(process.cwd(), codeFilename)
      : codeFilename
    return stylelint._lintSource({
      code,
      codeFilename: absoluteCodeFilename,
    }).then(postcssResult =&gt; {
      return stylelint._createStylelintResult(postcssResult)
    }).catch(handleError).then(stylelintResult =&gt; {
      return prepareReturnValue([stylelintResult])
    })
  }

  let fileList = files
  if (typeof fileList === "string") {
    fileList = [fileList]
  }
  fileList = fileList.concat(
    alwaysIgnoredGlobs.map(file =&gt; "!" + file)
  )

  if (useCache) {
    const stylelintVersion = pkg.version
    const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config)}`)
    fileCache = new FileCache(cacheLocation, hashOfConfig)
  } else {
    // No need to calculate hash here, we just want to delete cache file.
    fileCache = new FileCache(cacheLocation)
    // Remove cache file if cache option is disabled
    fileCache.destroy()
  }

  return globby(fileList).then(filePaths =&gt; {
    if (!filePaths.length) {
      if (allowEmptyInput === undefined || !allowEmptyInput) {
        const message = (files =&gt; {
          if (typeof files === "string") {
            return `${files} does`
          }
          // seperate files into last (last file) and initial) all the others
          const initial = files.slice(0)
          const last = initial.pop()
          // join into a comma seperated string of file names
          const ending = (files.length &gt; 1 ? `and ${last} do` : `${last} does`)
          return `${initial.join(", ")} ${ending}`.trim()
        })(files) + " not match any files"

        const err/*: Object*/ = new Error(message)
        err.code = 80
        throw err
      } else {
        return Promise.all([])
      }
    }

    let absoluteFilePaths = filePaths.map(filePath =&gt; {
      const absoluteFilepath = (!path.isAbsolute(filePath))
        ? path.join(process.cwd(), filePath)
        : path.normalize(filePath)
      return absoluteFilepath
    })

    if (useCache) {
      absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache))
    }

    const getStylelintResults = absoluteFilePaths.map(absoluteFilepath =&gt; {
      debug(`Processing ${absoluteFilepath}`)
      return stylelint._lintSource({
        filePath: absoluteFilepath,
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.postcssPlugin.process" id="apidoc.element.stylelint.postcssPlugin.process">
        function <span class="apidocSignatureSpan">stylelint.postcssPlugin.</span>process
        <span class="apidocSignatureSpan">(root, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (root, opts) {
  return postcss([creator(opts)]).process(root, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    let preProcessedCode = code
    if (options.codeProcessors) {
      options.codeProcessors.forEach(codeProcessor =&gt; {
        preProcessedCode = codeProcessor(preProcessedCode, source)
      })
    }

    return postcssProcessor.<span class="apidocCodeKeywordSpan">process</span>(preProcessedCode, postcssOptions)
  }).then(postcssResult =&gt; {
    stylelint._postcssResultCache.set(options.filePath, postcssResult)
    return postcssResult
  })
}

function readFile(filePath/*: string*/)/*: Promise&lt;string&gt;*/ {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.rules" id="apidoc.module.stylelint.rules">module stylelint.rules</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-blacklist" id="apidoc.element.stylelint.rules.at-rule-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-blacklist
        <span class="apidocSignatureSpan">(blacklistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-blacklist = function (blacklistInput) {
  // To allow for just a string as a parameter (not only arrays of strings)
  const blacklist = [].concat(blacklistInput)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      const name = atRule.name

      if (blacklist.indexOf(postcss.vendor.unprefixed(name).toLowerCase()) === -1) {
        return
      }

      report({
        message: messages.rejected(name),
        node: atRule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-empty-line-before" id="apidoc.element.stylelint.rules.at-rule-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-empty-line-before = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    }, {
      actual: options,
      possible: {
        except: [
          "after-same-name",
          "all-nested",
          "inside-block",
          "blockless-after-same-name-blockless",
          "blockless-group",
          "blockless-after-blockless",
          "first-nested",
        ],
        ignore: [
          "after-comment",
          "all-nested",
          "inside-block",
          "blockless-after-same-name-blockless",
          "blockless-group",
          "blockless-after-blockless",
        ],
        ignoreAtRules: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    if (
      optionsMatches(options, "ignore", "all-nested")
      || optionsMatches(options, "except", "all-nested")
    ) {
      result.warn((
        "'at-rule-empty-line-before\'s' \"all-nested\" option has been deprecated and in 8.0 will be removed. " +
        "Instead use the \"inside-block\" option."
      ), {
        stylelintType: "deprecation",
        stylelintReference: "https://stylelint.io/user-guide/rules/at-rule-empty-line-before/",
      })
    }

    if (
      optionsMatches(options, "ignore", "blockless-group")
      || optionsMatches(options, "except", "blockless-group")
    ) {
      result.warn((
        "'at-rule-empty-line-before\'s' \"blockless-group\" option has been deprecated and in 8.0 will be removed. " +
        "Instead use the \"blockless-after-blockless\" option."
      ), {
        stylelintType: "deprecation",
        stylelintReference: "https://stylelint.io/user-guide/rules/at-rule-empty-line-before/",
      })
    }

    root.walkAtRules(atRule =&gt; {
      // Ignore the first node
      if (atRule === root.first) {
        return
      }

      // Return early if at-rule is to be ignored
      if (optionsMatches(options, "ignoreAtRules", atRule.name)) {
        return
      }

      // Optionally ignore the expectation if the node is blockless
      if (
        optionsMatches(options, "ignore", "blockless-group")
        &amp;&amp; !hasBlock(atRule)
        || optionsMatches(options, "ignore", "blockless-after-blockless")
        &amp;&amp; !hasBlock(atRule)
      ) {
        return
      }

      const isNested = atRule.parent !== root
      const previousNode = atRule.prev()

      // Optionally ignore the expection if the node is blockless
      // and following another blockless at-rule with the same name
      if (
        optionsMatches(options, "ignore", "blockless-after-same-name-blockless")
        &amp;&amp; isBlocklessAfterSameNameBlockless()
      ) {
        return
      }

      // Optionally ignore the expectation if the node is inside a block
      if (
        optionsMatches(options, "ignore", "all-nested")
        &amp;&amp; isNested
        || optionsMatches(options, "ignore", "inside-block")
        &amp;&amp; isNested
      ) {
        return
      }

      // Optionally ignore the expectation if a comment precedes this node
      if (
        optionsMatches(options, "ignore", "after-comment")
        &amp;&amp; isAfterComment()
      ) {
        return
      }

      const hasEmptyLineBefore = hasEmptyLine(atRule.raws.before)
      let expectEmptyLineBefore = expectation === "always"
        ? true
        : false

      // Optionally reverse the expectation if any exceptions apply
      if (
        optionsMatches(options, "except", "after-same-name")
        &amp;&amp; isAfterSameName()
        || optionsMatches(options, "except", "all-nested")
        &amp;&amp; isNested
        || optionsMatches(options, "except", "inside-block")
        &amp;&amp; isNested
        || optionsMatches(options, "except", "first-nested")
        &amp;&amp; isFirstNested()
        || optionsMatches(options, "except", "blockless-group")
        &amp;&amp; isBlocklessAfterBlockless()
        || optionsMatches(options, "except", "blockless-after-blockless")
        &amp;&amp; isBlocklessAfterBlockless()
        || optionsMatches( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-name-case" id="apidoc.element.stylelint.rules.at-rule-name-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-name-case = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      const name = atRule.name

      const expectedName = expectation === "lower"
        ? name.toLowerCase()
        : name.toUpperCase()

      if (name === expectedName) {
        return
      }

      report({
        message: messages.expected(name, expectedName),
        node: atRule,
        ruleName,
        result,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-name-newline-after" id="apidoc.element.stylelint.rules.at-rule-name-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-name-newline-after = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    atRuleNameSpaceChecker({
      root,
      result,
      locationChecker: checker.afterOneOnly,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-name-space-after" id="apidoc.element.stylelint.rules.at-rule-name-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-name-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    atRuleNameSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-no-unknown" id="apidoc.element.stylelint.rules.at-rule-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-no-unknown = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreAtRules: [_.isString],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      const name = atRule.name

      // Return early if at-rule is to be ignored
      if (optionsMatches(options, "ignoreAtRules", atRule.name)) {
        return
      }

      if (
        postcss.vendor.prefix(name)
        || keywordSets.atRules.has(name.toLowerCase())
      ) {
        return
      }

      report({
        message: messages.rejected(`@${name}`),
        node: atRule,
        ruleName,
        result,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-no-vendor-prefix" id="apidoc.element.stylelint.rules.at-rule-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-no-vendor-prefix = function (actual) {
  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      if (!isStandardSyntaxAtRule(atRule)) {
        return
      }

      const name = atRule.name

      if (name[0] !== "-") {
        return
      }

      if (!isAutoprefixable.atRuleName(name)) {
        return
      }

      report({
        message: messages.rejected(name),
        node: atRule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-semicolon-newline-after" id="apidoc.element.stylelint.rules.at-rule-semicolon-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-semicolon-newline-after
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-semicolon-newline-after = function (actual) {
  const checker = whitespaceChecker("newline", actual, messages)

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual,
      possible: ["always"],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      const nextNode = atRule.next()
      if (!nextNode) {
        return
      }
      if (hasBlock(atRule)) {
        return
      }

      // Allow an end-of-line comment
      const nodeToCheck = nextNonCommentNode(nextNode)
      if (!nodeToCheck) {
        return
      }

      checker.afterOneOnly({
        source: rawNodeString(nodeToCheck),
        index: -1,
        err: msg =&gt; {
          report({
            message: msg,
            node: atRule,
            index: atRule.toString().length + 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-semicolon-space-before" id="apidoc.element.stylelint.rules.at-rule-semicolon-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-semicolon-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-semicolon-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      if (hasBlock(atRule)) {
        return
      }
      const nodeString = rawNodeString(atRule)

      checker.before({
        source: nodeString,
        index: nodeString.length,
        err: m =&gt; {
          report({
            message: m,
            node: atRule,
            index: nodeString.length - 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-whitelist" id="apidoc.element.stylelint.rules.at-rule-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-whitelist
        <span class="apidocSignatureSpan">(whitelistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-whitelist = function (whitelistInput) {
  // To allow for just a string as a parameter (not only arrays of strings)
  const whitelist = [].concat(whitelistInput)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      const name = atRule.name

      if (whitelist.indexOf(postcss.vendor.unprefixed(name).toLowerCase()) !== -1) {
        return
      }

      report({
        message: messages.rejected(name),
        node: atRule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-empty-line-before" id="apidoc.element.stylelint.rules.block-closing-brace-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-empty-line-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-empty-line-before = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always-multi-line",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      // Get whitespace after ""}", ignoring extra semicolon
      const before = (statement.raws.after || "").replace(/;+/, "")
      if (before === undefined) {
        return
      }

      // Calculate index
      const statementString = statement.toString()
      let index = statementString.length - 1
      if (statementString[index - 1] === "\r") {
        index -= 1
      }

      // Set expectation
      const expectEmptyLineBefore = expectation === "always-multi-line"
        &amp;&amp; !isSingleLineString(blockString(statement))
          ? true
          : false

      // Check for at least one empty line
      const hasEmptyLineBefore = hasEmptyLine(before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore
        ? messages.expected
        : messages.rejected

      report({
        message,
        result,
        ruleName,
        node: statement,
        index,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-newline-after" id="apidoc.element.stylelint.rules.block-closing-brace-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-newline-after
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-newline-after = function (expectation, options) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-single-line",
        "never-single-line",
        "always-multi-line",
        "never-multi-line",
      ],
    }, {
      actual: options,
      possible: {
        ignoreAtRules: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      if (!hasBlock(statement)) {
        return
      }
      if (optionsMatches(options, "ignoreAtRules", statement.name)) {
        return
      }

      const nextNode = statement.next()
      if (!nextNode) {
        return
      }

      // Allow an end-of-line comment x spaces after the brace
      const nextNodeIsSingleLineComment = nextNode.type === "comment"
        &amp;&amp; !/[^ ]/.test((nextNode.raws.before || ""))
        &amp;&amp; nextNode.toString().indexOf("\n") === -1

      const nodeToCheck = nextNodeIsSingleLineComment
        ? nextNode.next()
        : nextNode

      if (!nodeToCheck) {
        return
      }

      let reportIndex = statement.toString().length
      let source = rawNodeString(nodeToCheck)

      // Skip a semicolon at the beginning, if any
      if (
        source
        &amp;&amp; source[0] === ";"
      ) {
        source = source.slice(1)
        reportIndex++
      }

      // Only check one after, because there might be other
      // spaces handled by the indentation rule
      checker.afterOneOnly({
        source,
        index: -1,
        lineCheckStr: blockString(statement),
        err: msg =&gt; {
          report({
            message: msg,
            node: statement,
            index: reportIndex,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-newline-before" id="apidoc.element.stylelint.rules.block-closing-brace-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-newline-before = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      // Ignore extra semicolon
      const after = (statement.raws.after || "").replace(/;+/, "")
      if (after === undefined) {
        return
      }

      const blockIsMultiLine = !isSingleLineString(blockString(statement))
      const statementString = statement.toString()

      let index = statementString.length - 2
      if (statementString[index - 1] === "\r") {
        index -= 1
      }

      // We're really just checking whether a
      // newline *starts* the block's final space -- between
      // the last declaration and the closing brace. We can
      // ignore any other whitespace between them, because that
      // will be checked by the indentation rule.
      if (
        !_.startsWith(after, "\n")
        &amp;&amp; !_.startsWith(after, "\r\n")
      ) {
        if (expectation === "always") {
          complain(messages.expectedBefore)
        } else if (
          blockIsMultiLine
          &amp;&amp; expectation === "always-multi-line"
        ) {
          complain(messages.expectedBeforeMultiLine)
        }
      }

      if (
        after !== ""
        &amp;&amp; blockIsMultiLine
        &amp;&amp; expectation === "never-multi-line"
      ) {
        complain(messages.rejectedBeforeMultiLine)
      }

      function complain(message) {
        report({
          message,
          result,
          ruleName,
          node: statement,
          index,
        })
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-space-after" id="apidoc.element.stylelint.rules.block-closing-brace-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)

  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      const nextNode = statement.next()
      if (!nextNode) {
        return
      }
      if (!hasBlock(statement)) {
        return
      }

      let reportIndex = statement.toString().length
      let source = rawNodeString(nextNode)

      // Skip a semicolon at the beginning, if any
      if (
        source
        &amp;&amp; source[0] === ";"
      ) {
        source = source.slice(1)
        reportIndex++
      }

      checker.after({
        source,
        index: -1,
        lineCheckStr: blockString(statement),
        err: msg =&gt; {
          report({
            message: msg,
            node: statement,
            index: reportIndex,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-space-before" id="apidoc.element.stylelint.rules.block-closing-brace-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual : expectation,
      possible : [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statement: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      const source = blockString(statement)
      const statementString = statement.toString()

      let index = statementString.length - 2
      if (statementString[index - 1] === "\r") {
        index -= 1
      }

      checker.before({
        source,
        index: source.length - 1,
        err: msg =&gt; {
          report({
            message: msg,
            node: statement,
            index,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-no-empty" id="apidoc.element.stylelint.rules.block-no-empty">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-no-empty
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-no-empty = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      if (!hasEmptyBlock(statement)) {
        return
      }

      let index = beforeBlockString(statement, { noRawBefore: true }).length

      // For empty blocks when using SugarSS parser
      if (statement.raws.between === undefined) {
        index--
      }

      report({
        message: messages.rejected,
        node: statement,
        index,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-no-single-line" id="apidoc.element.stylelint.rules.block-no-single-line">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-no-single-line
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-no-single-line = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      "'block-no-single-line' has been deprecated and in 8.0 will be removed. " +
      "Instead use 'block-opening-brace-newline-after' and 'block-closing-brace-newline-before' with the \"always\" option."
    ), {
      stylelintType: "deprecation",
      stylelintReference: "https://stylelint.io/user-guide/rules/block-no-single-line/",
    })

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }
      if (!isSingleLineString(blockString(statement))) {
        return
      }

      report({
        message: messages.rejected,
        node: statement,
        index: beforeBlockString(statement, { noRawBefore: true }).length,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-opening-brace-newline-after" id="apidoc.element.stylelint.rules.block-opening-brace-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-opening-brace-newline-after = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statement: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has an empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      // Allow an end-of-line comment
      const nodeToCheck = nextNonCommentNode(statement.first)
      if (!nodeToCheck) {
        return
      }

      checker.afterOneOnly({
        source: rawNodeString(nodeToCheck),
        index: -1,
        lineCheckStr: blockString(statement),
        err: m =&gt; {
          report({
            message: m,
            node: statement,
            index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-opening-brace-newline-before" id="apidoc.element.stylelint.rules.block-opening-brace-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-opening-brace-newline-before = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual : expectation,
      possible : [
        "always",
        "always-single-line",
        "never-single-line",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statement: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has an empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      const source = beforeBlockString(statement)
      const beforeBraceNoRaw = beforeBlockString(statement, { noRawBefore: true })

      let index = beforeBraceNoRaw.length - 1
      if (beforeBraceNoRaw[index - 1] === "\r") {
        index -= 1
      }

      checker.beforeAllowingIndentation({
        lineCheckStr: blockString(statement),
        source,
        index: source.length,
        err: m =&gt; {
          report({
            message: m,
            node: statement,
            index,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-opening-brace-space-after" id="apidoc.element.stylelint.rules.block-opening-brace-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-opening-brace-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has an empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      checker.after({
        source: blockString(statement),
        index: 0,
        err: m =&gt; {
          report({
            message: m,
            node: statement,
            index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-opening-brace-space-before" id="apidoc.element.stylelint.rules.block-opening-brace-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-space-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-opening-brace-space-before = function (expectation, options) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
        "always-multi-line",
        "never-multi-line",
      ],
    }, {
      actual: options,
      possible: {
        ignoreAtRules: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has an empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      // Return early if at-rule is to be ignored
      if (optionsMatches(options, "ignoreAtRules", statement.name)) {
        return
      }

      const source = beforeBlockString(statement)
      const beforeBraceNoRaw = beforeBlockString(statement, { noRawBefore: true })

      let index = beforeBraceNoRaw.length - 1
      if (beforeBraceNoRaw[index - 1] === "\r") {
        index -= 1
      }

      checker.before({
        source,
        index: source.length,
        lineCheckStr: blockString(statement),
        err: m =&gt; {
          report({
            message: m,
            node: statement,
            index,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-hex-case" id="apidoc.element.stylelint.rules.color-hex-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-hex-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-hex-case = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const declString = blurFunctionArguments(decl.toString(), "url")
      styleSearch({ source: declString, target: "#" }, match =&gt; {
        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))
        if (!hexMatch) {
          return
        }

        const hexValue = hexMatch[0]
        const hexValueLower = hexValue.toLowerCase()
        const hexValueUpper = hexValue.toUpperCase()
        const expectedHex = expectation === "lower"
          ? hexValueLower
          : hexValueUpper

        if (hexValue === expectedHex) {
          return
        }

        report({
          message: messages.expected(hexValue, expectedHex),
          node: decl,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-hex-length" id="apidoc.element.stylelint.rules.color-hex-length">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-hex-length
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-hex-length = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "short",
        "long",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const declString = decl.toString()

      styleSearch({ source: declString, target: "#" }, match =&gt; {
        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))
        if (!hexMatch) {
          return
        }

        const hexValue = hexMatch[0]

        if (
          expectation === "long"
          &amp;&amp; hexValue.length !== 4
          &amp;&amp; hexValue.length !== 5
        ) {
          return
        }

        if (
          expectation === "short"
          &amp;&amp; (
            hexValue.length &lt; 6
            || !canShrink(hexValue)
          )
        ) {
          return
        }

        const variant = expectation === "long"
          ? longer
          : shorter

        report({
          message: messages.expected(hexValue, variant(hexValue)),
          node: decl,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-named" id="apidoc.element.stylelint.rules.color-named">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-named
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-named = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "never",
        "always-where-possible",
      ],
    }, {
      actual: options,
      possible: {
        ignoreProperties: [_.isString],
        ignore: ["inside-function"],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    const namedColors = Object.keys(namedColorData)

    root.walkDecls(decl =&gt; {
      if (propertySets.acceptCustomIdents.has(decl.prop)) {
        return
      }

      // Return early if the property is to be ignored
      if (optionsMatches(options, "ignoreProperties", decl.prop)) {
        return
      }

      valueParser(decl.value).walk(node =&gt; {
        const value = node.value,
          type = node.type,
          sourceIndex = node.sourceIndex

        if (
          optionsMatches(options, "ignore", "inside-function")
          &amp;&amp; type === "function"
        ) {
          return false
        }

        if (!isStandardSyntaxFunction(node)) {
          return false
        }

        if (!isStandardSyntaxValue(value)) {
          return
        }
        // Return early if neither a word nor a function
        if (NODE_TYPES.indexOf(type) === -1) {
          return
        }

        // Check for named colors for "never" option
        if (
          expectation === "never"
          &amp;&amp; type === "word"
          &amp;&amp; namedColors.indexOf(value.toLowerCase()) !== -1
        ) {
          complain(messages.rejected(value), decl, declarationValueIndex(decl) + sourceIndex)
          return
        }

        // Check "always-where-possible" option ...
        if (expectation !== "always-where-possible") {
          return
        }

        // First by checking for alternative color function representations ...
        if (
          type === "function"
          &amp;&amp; keywordSets.colorFunctionNames.has(value.toLowerCase())
        ) {
          // Remove all spaces to match what's in `representations`
          const normalizedFunctionString = valueParser.stringify(node).replace(/\s+/g, "")
          let namedColor
          for (let i = 0, l = namedColors.length; i &lt; l; i++) {
            namedColor = namedColors[i]
            if (namedColorData[namedColor].func.indexOf(normalizedFunctionString.toLowerCase()) !== -1) {
              complain(messages.expected(namedColor, normalizedFunctionString), decl, declarationValueIndex(decl) + sourceIndex)
              return // Exit as soon as a problem is found
            }
          }
          return
        }

        // Then by checking for alternative hex representations
        let namedColor
        for (let i = 0, l = namedColors.length; i &lt; l; i++) {
          namedColor = namedColors[i]
          if (namedColorData[namedColor].hex.indexOf(value.toLowerCase()) !== -1) {
            complain(messages.expected(namedColor, value), decl, declarationValueIndex(decl) + sourceIndex)
            return // Exit as soon as a problem is found
          }
        }
      })
    })

    function complain(message, node, index) {
      report({
        result,
        ruleName,
        message,
        node,
        index,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-no-hex" id="apidoc.element.stylelint.rules.color-no-hex">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-no-hex
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-no-hex = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const declString = decl.toString()

      styleSearch({ source: declString, target: "#" }, match =&gt; {
        // If there's not a colon, comma, or whitespace character before, we'll assume this is
        // not intended to be a hex color, but is instead something like the
        // hash in a url() argument
        if (!/[:,\s]/.test(declString[match.startIndex - 1])) {
          return
        }

        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))
        if (!hexMatch) {
          return
        }
        const hexValue = hexMatch[0]

        report({
          message: messages.rejected(hexValue),
          node: decl,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-no-invalid-hex" id="apidoc.element.stylelint.rules.color-no-invalid-hex">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-no-invalid-hex
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-no-invalid-hex = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const declString = decl.toString()

      styleSearch({ source: declString, target: "#" }, match =&gt; {
        // If there's not a colon, comma, or whitespace character before, we'll assume this is
        // not intended to be a hex color, but is instead something like the
        // hash in a url() argument
        if (!/[:,\s]/.test(declString[match.startIndex - 1])) {
          return
        }

        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))
        if (!hexMatch) {
          return
        }

        const hexValue = hexMatch[0]
        if (isValidHex(hexValue)) {
          return
        }

        report({
          message: messages.rejected(hexValue),
          node: decl,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.comment-empty-line-before" id="apidoc.element.stylelint.rules.comment-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment-empty-line-before = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    }, {
      actual: options,
      possible: {
        except: ["first-nested"],
        ignore: [
          "stylelint-commands",
          "stylelint-command",
          "between-comments",
          "after-comment",
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    if (
      optionsMatches(options, "ignore", "between-comments")
    ) {
      result.warn((
        "'comment-empty-line-before\'s' \"between-comments\" option has been deprecated and in 8.0 will be removed. " +
        "Instead use the \"after-comment\" option."
      ), {
        stylelintType: "deprecation",
        stylelintReference: "https://stylelint.io/user-guide/rules/comment-empty-line-before/",
      })
    }

    root.walkComments(comment =&gt; {
      // Ignore the first node
      if (comment === root.first) {
        return
      }

      // Optionally ignore stylelint commands
      if (
        comment.text.indexOf(stylelintCommandPrefix) === 0
        &amp;&amp; optionsMatches(options, "ignore", "stylelint-commands")
      ) {
        return
      }

      // Optionally ignore newlines between comments
      const prev = comment.prev()
      if (
        prev
        &amp;&amp; prev.type === "comment"
        &amp;&amp; optionsMatches(options, "ignore", "between-comments")
      ) {
        return
      }

      if (
        prev
        &amp;&amp; prev.type === "comment"
        &amp;&amp; optionsMatches(options, "ignore", "after-comment")
      ) {
        return
      }

      if (
        comment.raws.inline
        || comment.inline
      ) {
        return
      }

      const before = (comment.raws.before || "")

      // Ignore shared-line comments
      if (before.indexOf("\n") === -1) {
        return
      }

      const expectEmptyLineBefore = (() =&gt; {
        if (
          optionsMatches(options, "except", "first-nested")
          &amp;&amp; comment.parent !== root
          &amp;&amp; comment === comment.parent.first
        ) {
          return false
        }
        return expectation === "always"
      })()

      const hasEmptyLineBefore = hasEmptyLine(before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore
        ? messages.expected
        : messages.rejected

      report({
        message,
        node: comment,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.comment-no-empty" id="apidoc.element.stylelint.rules.comment-no-empty">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-no-empty
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment-no-empty = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkComments(comment =&gt; {
      // To ignore inline SCSS comments
      if (
        comment.raws.inline
        || comment.inline
      ) {
        return
      }

      // To ignore comments that are not empty
      if (
        comment.text
        &amp;&amp; comment.text.length !== 0
      ) {
        return
      }

      report({
        message: messages.rejected,
        node: comment,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.comment-whitespace-inside" id="apidoc.element.stylelint.rules.comment-whitespace-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-whitespace-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment-whitespace-inside = function (expectation) {
  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkComments(function (comment) {
      if (
        comment.raws.inline
        || comment.inline
      ) {
        return
      }

      const rawComment = comment.toString()
      const firstFourChars = rawComment.substr(0, 4)

      // Return early if sourcemap or copyright comment
      if (/^\/\*[#!]\s/.test(firstFourChars)) {
        return
      }

      const leftMatches = rawComment.match(/(^\/\*+)(\s)?/)
      const rightMatches = rawComment.match(/(\s)?(\*+\/)$/)
      const opener = leftMatches[1]
      const leftSpace = leftMatches[2] || ""
      const rightSpace = rightMatches[1] || ""
      const closer = rightMatches[2]

      if (
        expectation === "never"
        &amp;&amp; leftSpace !== ""
      ) {
        complain(messages.rejectedOpening, opener.length)
      }

      if (
        expectation === "always"
        &amp;&amp; !isWhitespace(leftSpace)
      ) {
        complain(messages.expectedOpening, opener.length)
      }

      if (
        expectation === "never"
        &amp;&amp; rightSpace !== ""
      ) {
        complain(messages.rejectedClosing, comment.toString().length - closer.length - 1)
      }

      if (
        expectation === "always"
        &amp;&amp; !isWhitespace(rightSpace)
      ) {
        complain(messages.expectedClosing, comment.toString().length - closer.length - 1)
      }

      function complain(message, index) {
        report({
          message,
          index,
          result,
          ruleName,
          node: comment,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.comment-word-blacklist" id="apidoc.element.stylelint.rules.comment-word-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-word-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment-word-blacklist = function (blacklist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkComments(comment =&gt; {
      const text = comment.text
      const rawComment = comment.toString()
      const firstFourChars = rawComment.substr(0, 4)

      // Return early if sourcemap
      if (firstFourChars === "/*# ") {
        return
      }

      const matchesWord = matchesStringOrRegExp(text, blacklist) || containsString(text, blacklist)

      if (!matchesWord) {
        return
      }

      report({
        message: messages.rejected(matchesWord.pattern),
        node: comment,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.custom-media-pattern" id="apidoc.element.stylelint.rules.custom-media-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-media-pattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom-media-pattern = function (pattern) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    })
    if (!validOptions) {
      return
    }

    const regexpPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkAtRules(atRule =&gt; {
      if (atRule.name.toLowerCase() !== "custom-media") {
        return
      }

      const customMediaName = atRule.params.match(/^--(\S+)\b/)[1]

      if (regexpPattern.test(customMediaName)) {
        return
      }

      report({
        message: messages.expected,
        node: atRule,
        index: atRuleParamIndex(atRule),
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.custom-property-empty-line-before" id="apidoc.element.stylelint.rules.custom-property-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom-property-empty-line-before = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    }, {
      actual: options,
      possible: {
        except: [
          "first-nested",
          "after-comment",
          "after-custom-property",
        ],
        ignore: [
          "after-comment",
          "inside-single-line-block",
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop,
        parent = decl.parent

      if (!isStandardSyntaxDeclaration(decl)) {
        return
      }
      if (!isCustomProperty(prop)) {
        return
      }

      // Optionally ignore the node if a comment precedes it
      if (
        optionsMatches(options, "ignore", "after-comment")
        &amp;&amp; decl.prev()
        &amp;&amp; decl.prev().type === "comment"
      ) {
        return
      }

      // Optionally ignore nodes inside single-line blocks
      if (
        optionsMatches(options, "ignore", "inside-single-line-block")
        &amp;&amp; isSingleLineString(blockString(parent))
      ) {
        return
      }

      let expectEmptyLineBefore = expectation === "always" ? true : false

      // Optionally reverse the expectation for the first nested node
      if (
        optionsMatches(options, "except", "first-nested")
        &amp;&amp; decl === parent.first
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a comment precedes this node
      if (
        optionsMatches(options, "except", "after-comment")
        &amp;&amp; decl.prev()
        &amp;&amp; decl.prev().type === "comment"
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a custom property precedes this node
      if (
        optionsMatches(options, "except", "after-custom-property")
        &amp;&amp; decl.prev()
        &amp;&amp; decl.prev().prop
        &amp;&amp; isCustomProperty(decl.prev().prop)
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      const hasEmptyLineBefore = hasEmptyLine(decl.raws.before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore ? messages.expected : messages.rejected
      report({
        message,
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.custom-property-no-outside-root" id="apidoc.element.stylelint.rules.custom-property-no-outside-root">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-no-outside-root
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom-property-no-outside-root = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use the community 'stylelint-suitcss' plugin pack.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&gt; {
      // Ignore rules whose selector is just `:root`
      if (rule.selector.toLowerCase().trim() === ":root") {
        return
      }

      rule.walkDecls(decl =&gt; {
        if (!isCustomProperty(decl.prop)) {
          return
        }
        report({
          message: messages.rejected,
          node: decl,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.custom-property-pattern" id="apidoc.element.stylelint.rules.custom-property-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-pattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom-property-pattern = function (pattern) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    })
    if (!validOptions) {
      return
    }

    const regexpPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkDecls(decl =&gt; {
      const prop = decl.prop

      if (!isCustomProperty(prop)) {
        return
      }
      if (regexpPattern.test(prop.slice(2))) {
        return
      }

      report({
        message: messages.expected,
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-bang-space-after" id="apidoc.element.stylelint.rules.declaration-bang-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-bang-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-bang-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    declarationBangSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-bang-space-before" id="apidoc.element.stylelint.rules.declaration-bang-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-bang-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-bang-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    declarationBangSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-no-duplicate-properties" id="apidoc.element.stylelint.rules.declaration-block-no-duplicate-properties">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-duplicate-properties
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-no-duplicate-properties = function (on, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      actual: options,
      possible: {
        ignore: [
          "consecutive-duplicates",
          "consecutive-duplicates-with-different-values",
        ],
        ignoreProperties: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    // In order to accommodate nested blocks (postcss-nested),
    // we need to run a shallow loop (instead of eachDecl() or eachRule(),
    // which loop recursively) and allow each nested block to accumulate
    // its own list of properties -- so that a property in a nested rule
    // does not conflict with the same property in the parent rule
    root.each(node =&gt; {
      if (
        node.type === "rule"
        || node.type === "atrule"
      ) {
        checkRulesInNode(node)
      }
    })

    function checkRulesInNode(node) {
      const decls = []
      const values = []

      node.each(child =&gt; {
        if (
          child.nodes
          &amp;&amp; child.nodes.length
        ) {
          checkRulesInNode(child)
        }

        if (child.type !== "decl") {
          return
        }

        const prop = child.prop
        const value = child.value

        if (!isStandardSyntaxProperty(prop)) {
          return
        }
        if (isCustomProperty(prop)) {
          return
        }

        // Return early if the property is to be ignored
        if (optionsMatches(options, "ignoreProperties", prop)) {
          return
        }

        // Ignore the src property as commonly duplicated in at-fontface
        if (prop.toLowerCase() === "src") {
          return
        }

        const indexDuplicate = decls.indexOf(prop.toLowerCase())

        if (indexDuplicate !== -1) {
          if (optionsMatches(options, "ignore", "consecutive-duplicates-with-different-values")) {
            // if duplicates are not consecutive
            if (indexDuplicate !== decls.length - 1) {
              report({
                message: messages.rejected(prop),
                node: child,
                result,
                ruleName,
              })
              return
            }
            // if values of consecutive duplicates are equal
            if (value === values[indexDuplicate]) {
              report({
                message: messages.rejected(value),
                node: child,
                result,
                ruleName,
              })
              return
            }
            return
          }

          if (
            optionsMatches(options, "ignore", "consecutive-duplicates")
            &amp;&amp; indexDuplicate === decls.length - 1
          ) {
            return
          }

          report({
            message: messages.rejected(prop),
            node: child,
            result,
            ruleName,
          })
        }

        decls.push(prop.toLowerCase())
        values.push(value.toLowerCase())
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-no-ignored-properties" id="apidoc.element.stylelint.rules.declaration-block-no-ignored-properties">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-ignored-properties
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-no-ignored-properties = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })

    if (!validOptions) {
      return
    }

    result.warn((
      "'declaration-block-no-ignored-properties' has been deprecated and in 8.0 will be removed."
    ), {
      stylelintType: "deprecation",
      stylelintReference: "https://stylelint.io/user-guide/rules/declaration-block-no-ignored-properties/",
    })

    const uniqueDecls = {}
    root.walkDecls(decl =&gt; {
      uniqueDecls[decl.prop] = decl
    })

    Object.keys(uniqueDecls).forEach((prop, index) =&gt; {
      const decl = uniqueDecls[prop]
      const unprefixedProp = postcss.vendor.unprefixed(prop)
      const unprefixedValue = postcss.vendor.unprefixed(decl.value)

      ignored.forEach(ignore =&gt; {
        const matchProperty = matchesStringOrRegExp(unprefixedProp.toLowerCase(), ignore.property)
        const matchValue = matchesStringOrRegExp(unprefixedValue.toLowerCase(), ignore.value)

        if (!matchProperty || !matchValue) {
          return
        }

        const ignoredProperties = ignore.ignoredProperties

        decl.parent.nodes.forEach((node, nodeIndex) =&gt; {
          if (!node.prop || ignoredProperties.indexOf(node.prop.toLowerCase()) === -1 || index === nodeIndex) {
            return
          }

          report({
            message: messages.rejected(node.prop, decl.toString()),
            node,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-no-redundant-longhand-properties" id="apidoc.element.stylelint.rules.declaration-block-no-redundant-longhand-properties">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-redundant-longhand-properties
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-no-redundant-longhand-properties = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreShorthands: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const longhandProperties = _.transform(shorthandData, (result, values, key) =&gt; {
      if (optionsMatches(options, "ignoreShorthands", key)) {
        return
      }

      values.forEach(value =&gt; {
        (result[value] || (result[value] = [])).push(key)
      })
    })

    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      const longhandDeclarations = {}
      // Shallow iteration so nesting doesn't produce
      // false positives
      statement.each(node =&gt; {
        if (node.type !== "decl") {
          return
        }

        const prop = node.prop.toLowerCase()

        const shorthandProperties = longhandProperties[prop]

        if (!shorthandProperties) {
          return
        }

        shorthandProperties.forEach(shorthandProperty =&gt; {
          (longhandDeclarations[shorthandProperty] || (longhandDeclarations[shorthandProperty] = [])).push(prop)

          if (!_.isEqual(shorthandData[shorthandProperty].sort(), longhandDeclarations[shorthandProperty].sort())) {
            return
          }

          report({
            ruleName,
            result,
            node,
            message: messages.expected(shorthandProperty),
          })
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-no-shorthand-property-overrides" id="apidoc.element.stylelint.rules.declaration-block-no-shorthand-property-overrides">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-shorthand-property-overrides
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-no-shorthand-property-overrides = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      const declarations = {}
      // Shallow iteration so nesting doesn't produce
      // false positives
      statement.each(node =&gt; {
        if (node.type !== "decl") {
          return
        }
        const prop = node.prop

        const overrideables = shorthandData[prop.toLowerCase()]
        if (!overrideables) {
          declarations[prop.toLowerCase()] = prop
          return
        }
        overrideables.forEach(longhandProp =&gt; {
          if (!declarations.hasOwnProperty(longhandProp)) {
            return
          }
          report({
            ruleName,
            result,
            node,
            message: messages.rejected(prop, declarations[longhandProp]),
          })
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-properties-order" id="apidoc.element.stylelint.rules.declaration-block-properties-order">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-properties-order
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-properties-order = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: validatePrimaryOption,
    }, {
      actual: options,
      possible: {
        unspecified: [
          "top",
          "bottom",
          "ignore",
          "bottomAlphabetical",
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    result.warn((
      "'declaration-block-properties-order'has been deprecated and in 8.0 will be removed. " +
      "Instead use the community 'stylelint-order' plugin pack."
    ), {
      stylelintType: "deprecation",
      stylelintReference: "https://stylelint.io/user-guide/rules/declaration-block-properties-order/",
    })

    const alphabetical = expectation === "alphabetical"
    const expectedOrder = alphabetical ? null : createExpectedOrder(expectation)
    // By default, ignore unspecified properties
    const unspecified = _.get(options, ["unspecified"], "ignore")

    // Shallow loop
    root.each(node =&gt; {
      if (node.type === "rule" || node.type === "atrule") {
        checkNode(node)
      }
    })

    function checkNode(node) {
      const allPropData = []

      node.each(child =&gt; {
        // If the child has nested nodes with child
        // (e.g. a rule nested within a rule), make
        // sure to check the children
        if (child.nodes &amp;&amp; child.nodes.length) {
          checkNode(child)
        }

        if (child.type !== "decl") {
          return
        }

        const prop = child.prop

        if (!isStandardSyntaxProperty(prop)) {
          return
        }
        if (isCustomProperty(prop)) {
          return
        }

        let unprefixedPropName = postcss.vendor.unprefixed(prop)

        // Hack to allow -moz-osx-font-smoothing to be understood
        // just like -webkit-font-smoothing
        if (unprefixedPropName.indexOf("osx-") === 0) {
          unprefixedPropName = unprefixedPropName.slice(4)
        }

        const propData = {
          name: prop,
          unprefixedName: unprefixedPropName,
          orderData: alphabetical ? null : getOrderData(expectedOrder, unprefixedPropName),
          before: child.raws.before,
          index: allPropData.length,
          node: child,
        }

        const previousPropData = _.last(allPropData)
        allPropData.push(propData)

        // Skip first decl
        if (!previousPropData) {
          return
        }

        const isCorrectOrder = alphabetical ? checkAlpabeticalOrder(previousPropData, propData) : checkOrder(previousPropData, propData
)

        if (isCorrectOrder) {
          return
        }

        complain({
          message: messages.expected(propData.name, previousPropData.name),
          node: child,
        })
      })

      function checkOrder(firstPropData, secondPropData) {
        // If the unprefixed property names are the same, resort to alphabetical ordering
        if (firstPropData.unprefixedName === secondPropData.unprefixedName) {
          return firstPropData.name &lt;= secondPropData.name
        }

        const firstPropIsUnspecified = !firstPropData.orderData
        const secondPropIsUnspecified = !secondPropData.orderData

        // Now check actual known properties ...
        if (!firstPropIsUnspecified &amp;&amp; !secondPropIsUnspecified) {
          return firstPropData.orderData.expectedPosition &lt;= secondPropData.orderData.expectedPosition
        }

        if (firstPropIsUnspecified &amp;&amp; !secondPropIsUnspecified) {
          // If first prop is unspecified, look for a specified prop before it to
          // compare to the current prop
          const priorSpecifiedPropData = _.findLast(allPropData.slice(0, -1), d =&gt; !!d.orderData)
          if (priorSpecifiedPropData &amp;&amp; priorSpecifiedPropData.orderData &amp;&amp; priorSpecifiedPropData.orderData.expectedPosition &gt;
secondPropData.orderData.expectedPosition) {
            complain({
              message: messages.expected(secondPropData.name, priorSpecifiedPropData.name),
              node: ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-semicolon-newline-after" id="apidoc.element.stylelint.rules.declaration-block-semicolon-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-semicolon-newline-after = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      // Ignore last declaration if there's no trailing semicolon
      const parentRule = decl.parent
      if (
        !parentRule.raws.semicolon
        &amp;&amp; parentRule.last === decl
      ) {
        return
      }

      const nextNode = decl.next()
      if (!nextNode) {
        return
      }

      // Allow end-of-line comment
      const nodeToCheck = nextNonCommentNode(nextNode)
      if (!nodeToCheck) {
        return
      }

      checker.afterOneOnly({
        source: rawNodeString(nodeToCheck),
        index: -1,
        lineCheckStr: blockString(parentRule),
        err: m =&gt; {
          report({
            message: m,
            node: decl,
            index: decl.toString().length + 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-semicolon-newline-before" id="apidoc.element.stylelint.rules.declaration-block-semicolon-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-semicolon-newline-before = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)

  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      const parentRule = decl.parent
      if (
        !parentRule.raws.semicolon
        &amp;&amp; parentRule.last === decl
      ) {
        return
      }

      const declString = decl.toString()

      checker.beforeAllowingIndentation({
        source: declString,
        index: declString.length,
        lineCheckStr: blockString(parentRule),
        err: m =&gt; {
          report({
            message: m,
            node: decl,
            index: decl.toString().length - 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-semicolon-space-after" id="apidoc.element.stylelint.rules.declaration-block-semicolon-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-semicolon-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)

  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      // Ignore last declaration if there's no trailing semicolon
      const parentRule = decl.parent
      if (!parentRule.raws.semicolon &amp;&amp; parentRule.last === decl) {
        return
      }

      const nextDecl = decl.next()
      if (!nextDecl) {
        return
      }

      checker.after({
        source: rawNodeString(nextDecl),
        index: -1,
        lineCheckStr: blockString(parentRule),
        err: m =&gt; {
          report({
            message: m,
            node: decl,
            index: decl.toString().length + 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-semicolon-space-before" id="apidoc.element.stylelint.rules.declaration-block-semicolon-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-semicolon-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      // Ignore last declaration if there's no trailing semicolon
      const parentRule = decl.parent
      if (!parentRule.raws.semicolon &amp;&amp; parentRule.last === decl) {
        return
      }

      const declString = decl.toString()

      checker.before({
        source: declString,
        index: declString.length,
        lineCheckStr: blockString(parentRule),
        err: m =&gt; {
          report({
            message: m,
            node: decl,
            index: decl.toString().length - 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-single-line-max-declarations" id="apidoc.element.stylelint.rules.declaration-block-single-line-max-declarations">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-single-line-max-declarations
        <span class="apidocSignatureSpan">(quantity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-single-line-max-declarations = function (quantity) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: quantity,
      possible: [_.isNumber],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isSingleLineString(blockString(rule))) {
        return
      }
      if (!rule.nodes) {
        return
      }

      const decls = rule.nodes.filter(node =&gt; node.type === "decl")

      if (decls.length &lt;= quantity) {
        return
      }

      report({
        message: messages.expected(quantity),
        node: rule,
        index: beforeBlockString(rule, { noRawBefore: true }).length,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-trailing-semicolon" id="apidoc.element.stylelint.rules.declaration-block-trailing-semicolon">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-trailing-semicolon
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-trailing-semicolon = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      if (atRule.parent === root) {
        return
      }
      if (atRule !== atRule.parent.last) {
        return
      }
      if (hasBlock(atRule)) {
        return
      }
      checkLastNode(atRule)
    })

    root.walkDecls(decl =&gt; {
      if (decl !== decl.parent.last) {
        return
      }
      checkLastNode(decl)
    })

    function checkLastNode(node) {
      let message

      if (expectation === "always") {
        if (node.parent.raws.semicolon) {
          return
        }
        message = messages.expected
      }
      if (expectation === "never") {
        if (!node.parent.raws.semicolon) {
          return
        }
        message = messages.rejected
      }

      report({
        message,
        node,
        index: node.toString().trim().length - 1,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-colon-newline-after" id="apidoc.element.stylelint.rules.declaration-colon-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-colon-newline-after = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (!isStandardSyntaxDeclaration(decl)) {
        return
      }

      // Get the raw prop, and only the prop
      const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || "").length - 1

      // The extra characters tacked onto the end ensure that there is a character to check
      // after the colon. Otherwise, with `background:pink` the character after the
      const propPlusColon = decl.toString().slice(0, endOfPropIndex) + "xxx"

      for (let i = 0, l = propPlusColon.length; i &lt; l; i++) {
        if (propPlusColon[i] !== ":") {
          continue
        }
        const indexToCheck = propPlusColon.substr(propPlusColon[i], 3) === "/*" ? propPlusColon.indexOf("*/", i) + 1 : i

        checker.afterOneOnly({
          source: propPlusColon,
          index: indexToCheck,
          lineCheckStr: decl.value,
          err: m =&gt; {
            report({
              message: m,
              node: decl,
              index: indexToCheck,
              result,
              ruleName,
            })
          },
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-colon-space-after" id="apidoc.element.stylelint.rules.declaration-colon-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-colon-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    declarationColonSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-colon-space-before" id="apidoc.element.stylelint.rules.declaration-colon-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-colon-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    declarationColonSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-empty-line-before" id="apidoc.element.stylelint.rules.declaration-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-empty-line-before = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    }, {
      actual: options,
      possible: {
        except: [
          "first-nested",
          "after-comment",
          "after-declaration",
        ],
        ignore: [
          "after-comment",
          "after-declaration",
          "inside-single-line-block",
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop,
        parent = decl.parent

      if (!isStandardSyntaxDeclaration(decl)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }

      // Optionally ignore the node if a comment precedes it
      if (
        optionsMatches(options, "ignore", "after-comment")
        &amp;&amp; decl.prev()
        &amp;&amp; decl.prev().type === "comment"
      ) {
        return
      }

      // Optionally ignore the node if a declaration precedes it
      if (
        optionsMatches(options, "ignore", "after-declaration")
        &amp;&amp; decl.prev()
        &amp;&amp; decl.prev().type === "decl"
      ) {
        return
      }

      // Optionally ignore nodes inside single-line blocks
      if (
        optionsMatches(options, "ignore", "inside-single-line-block")
        &amp;&amp; isSingleLineString(blockString(parent))
      ) {
        return
      }

      let expectEmptyLineBefore = expectation === "always"
        ? true
        : false

      // Optionally reverse the expectation for the first nested node
      if (
        optionsMatches(options, "except", "first-nested")
        &amp;&amp; decl === parent.first
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a comment precedes this node
      if (
        optionsMatches(options, "except", "after-comment")
        &amp;&amp; decl.prev()
        &amp;&amp; decl.prev().type === "comment"
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a declaration precedes this node
      if (
        optionsMatches(options, "except", "after-declaration")
        &amp;&amp; decl.prev()
        &amp;&amp; decl.prev().prop
        &amp;&amp; isStandardSyntaxDeclaration(decl.prev())
        &amp;&amp; !isCustomProperty(decl.prev().prop)
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Check for at least one empty line
      const hasEmptyLineBefore = hasEmptyLine(decl.raws.before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore
        ? messages.expected
        : messages.rejected
      report({ message, node: decl, result, ruleName })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-no-important" id="apidoc.element.stylelint.rules.declaration-no-important">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-no-important
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-no-important = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (!decl.important) {
        return
      }

      report({
        message: messages.rejected,
        node: decl,
        word: "important",
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-property-unit-blacklist" id="apidoc.element.stylelint.rules.declaration-property-unit-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-unit-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-property-unit-blacklist = function (blacklist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isObject],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop,
        value = decl.value

      const unprefixedProp = postcss.vendor.unprefixed(prop)

      const propBlacklist = _.find(blacklist, (list, propIdentifier) =&gt; matchesStringOrRegExp(unprefixedProp, propIdentifier))

      if (!propBlacklist) {
        return
      }

      valueParser(value).walk(function (node) {
        // Ignore wrong units within `url` function
        if (
          node.type === "function"
          &amp;&amp; node.value.toLowerCase() === "url"
        ) {
          return false
        }
        if (node.type === "string") {
          return
        }

        const unit = getUnitFromValueNode(node)

        if (
          !unit
          || unit
          &amp;&amp; propBlacklist.indexOf(unit.toLowerCase()) === -1
        ) {
          return
        }

        report({
          message: messages.rejected(prop, unit),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-property-unit-whitelist" id="apidoc.element.stylelint.rules.declaration-property-unit-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-unit-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-property-unit-whitelist = function (whitelist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isObject],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop,
        value = decl.value

      const unprefixedProp = postcss.vendor.unprefixed(prop)

      const propWhitelist = _.find(whitelist, (list, propIdentifier) =&gt; matchesStringOrRegExp(unprefixedProp, propIdentifier))

      if (!propWhitelist) {
        return
      }

      valueParser(value).walk(function (node) {
        // Ignore wrong units within `url` function
        if (node.type === "function" &amp;&amp; node.value.toLowerCase() === "url") {
          return false
        }
        if (node.type === "string") {
          return
        }

        const unit = getUnitFromValueNode(node)

        if (!unit || (unit &amp;&amp; propWhitelist.indexOf(unit.toLowerCase())) !== -1) {
          return
        }

        report({
          message: messages.rejected(prop, unit),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-property-value-blacklist" id="apidoc.element.stylelint.rules.declaration-property-value-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-value-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-property-value-blacklist = function (blacklist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isObject],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop,
        value = decl.value

      const unprefixedProp = postcss.vendor.unprefixed(prop)
      const propBlacklist = _.find(blacklist, (list, propIdentifier) =&gt; matchesStringOrRegExp(unprefixedProp, propIdentifier))

      if (_.isEmpty(propBlacklist)) {
        return
      }

      if (!matchesStringOrRegExp(value, propBlacklist)) {
        return
      }

      report({
        message: messages.rejected(prop, value),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-property-value-whitelist" id="apidoc.element.stylelint.rules.declaration-property-value-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-value-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-property-value-whitelist = function (whitelist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isObject],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop,
        value = decl.value

      const unprefixedProp = postcss.vendor.unprefixed(prop)
      const propWhitelist = _.find(whitelist, (list, propIdentifier) =&gt; matchesStringOrRegExp(unprefixedProp, propIdentifier))

      if (_.isEmpty(propWhitelist)) {
        return
      }

      if (matchesStringOrRegExp(value, propWhitelist)) {
        return
      }

      report({
        message: messages.rejected(prop, value),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.font-family-name-quotes" id="apidoc.element.stylelint.rules.font-family-name-quotes">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>font-family-name-quotes
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">font-family-name-quotes = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always-where-required",
        "always-where-recommended",
        "always-unless-keyword",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(/^font(-family)?$/i, decl =&gt; {
      const fontFamilies = findFontFamily(decl.value)

      if (fontFamilies.length === 0) {
        return
      }

      fontFamilies.forEach(fontFamilyNode =&gt; {
        let rawFamily = fontFamilyNode.value

        if (fontFamilyNode.quote) {
          rawFamily = fontFamilyNode.quote + rawFamily + fontFamilyNode.quote
        }

        checkFamilyName(rawFamily, decl)
      })
    })

    function checkFamilyName(rawFamily, decl) {
      if (!isStandardSyntaxValue(rawFamily)) {
        return
      }
      if (isVariable(rawFamily)) {
        return
      }

      const hasQuotes = rawFamily[0] === "'" || rawFamily[0] === "\""

      // Clean the family of its quotes
      const family = rawFamily.replace(/^['"]|['"]$/g, "")

      // Disallow quotes around (case-insensitive) keywords
      // and system font keywords in all cases
      if (keywordSets.fontFamilyKeywords.has(family.toLowerCase()) || isSystemFontKeyword(family)) {
        if (hasQuotes) {
          return complain(messages.rejected(family), family, decl)
        }
        return
      }

      const required = quotesRequired(family)
      const recommended = quotesRecommended(family)

      switch (expectation) {
        case "always-unless-keyword":
          if (!hasQuotes) {
            return complain(messages.expected(family), family, decl)
          }
          return

        case "always-where-recommended":
          if (!recommended &amp;&amp; hasQuotes) {
            return complain(messages.rejected(family), family, decl)
          }
          if (recommended &amp;&amp; !hasQuotes) {
            return complain(messages.expected(family), family, decl)
          }
          return

        case "always-where-required":
          if (!required &amp;&amp; hasQuotes) {
            return complain(messages.rejected(family), family, decl)
          }
          if (required &amp;&amp; !hasQuotes) {
            return complain(messages.expected(family), family, decl)
          }
          return
      }
    }

    function complain(message, family, decl) {
      report({
        result,
        ruleName,
        message,
        node: decl,
        word: family,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.font-family-no-duplicate-names" id="apidoc.element.stylelint.rules.font-family-no-duplicate-names">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>font-family-no-duplicate-names
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">font-family-no-duplicate-names = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreFontFamilyNames: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(/^font(-family)?$/i, decl =&gt; {
      const keywords = new Set()
      const familyNames = new Set()

      const fontFamilies = findFontFamily(decl.value)

      if (fontFamilies.length === 0) {
        return
      }

      fontFamilies.forEach(fontFamilyNode =&gt; {
        const family = fontFamilyNode.value.trim()

        if (optionsMatches(options, "ignoreFontFamilyNames", fontFamilyNode.value.trim())) {
          return
        }

        if (isFamilyNameKeyword(fontFamilyNode)) {
          if (keywords.has(family.toLowerCase())) {
            complain(messages.rejected(family), declarationValueIndex(decl) + fontFamilyNode.sourceIndex, decl)
            return
          }

          keywords.add(family)
          return
        }

        if (familyNames.has(family)) {
          complain(messages.rejected(family), declarationValueIndex(decl) + fontFamilyNode.sourceIndex, decl)
          return
        }

        familyNames.add(family)
      })
    })

    function complain(message, index, decl) {
      report({
        result,
        ruleName,
        message,
        node: decl,
        index,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.font-weight-notation" id="apidoc.element.stylelint.rules.font-weight-notation">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>font-weight-notation
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">font-weight-notation = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "numeric",
        "named-where-possible",
      ],
    }, {
      actual: options,
      possible: {
        ignore: ["relative"],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (decl.prop.toLowerCase() === "font-weight") {
        checkWeight(decl.value, decl)
      }

      if (decl.prop.toLowerCase() === "font") {
        checkFont(decl)
      }
    })

    function checkFont(decl) {
      const valueList = postcss.list.space(decl.value)
      // We do not need to more carefully distinguish font-weight
      // numbers from unitless line-heights because line-heights in
      // `font` values need to be part of a font-size/line-height pair
      const hasNumericFontWeight = valueList.some(isNumbery)

      for (const value of postcss.list.space(decl.value)) {
        if (value.toLowerCase() === NORMAL_KEYWORD &amp;&amp; !hasNumericFontWeight || isNumbery(value) || value.toLowerCase() !== NORMAL_KEYWORD
 &amp;&amp; keywordSets.fontWeightKeywords.has(value.toLowerCase())) {
          checkWeight(value, decl)
          return
        }
      }
    }

    function checkWeight(weightValue, decl) {
      if (!isStandardSyntaxValue(weightValue)) {
        return
      }
      if (isVariable(weightValue)) {
        return
      }
      if (weightValue.toLowerCase() === INHERIT_KEYWORD || weightValue.toLowerCase() === INITIAL_KEYWORD) {
        return
      }

      if (optionsMatches(options, "ignore", "relative") &amp;&amp; keywordSets.fontWeightRelativeKeywords.has(weightValue.toLowerCase())) {
        return
      }

      const weightValueOffset = decl.value.indexOf(weightValue)

      if (expectation === "numeric") {
        if (!isNumbery(weightValue)) {
          return complain(messages.expected("numeric"))
        }
      }

      if (expectation === "named-where-possible") {
        if (isNumbery(weightValue)) {
          if (_.includes(WEIGHTS_WITH_KEYWORD_EQUIVALENTS, weightValue)) {
            complain(messages.expected("named"))
          }
          return
        }
        if (!keywordSets.fontWeightKeywords.has(weightValue.toLowerCase()) &amp;&amp; weightValue.toLowerCase() !== NORMAL_KEYWORD) {
          return complain(messages.invalidNamed(weightValue))
        }
        return
      }

      function complain(message) {
        report({
          ruleName,
          result,
          message,
          node: decl,
          index: declarationValueIndex(decl) + weightValueOffset,
        })
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-blacklist" id="apidoc.element.stylelint.rules.function-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-blacklist = function (blacklist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }
    root.walkDecls(decl =&gt; {
      const value = decl.value

      valueParser(value).walk(function (node) {
        if (node.type !== "function") {
          return
        }
        if (!isStandardSyntaxFunction(node)) {
          return
        }
        if (!matchesStringOrRegExp(postcss.vendor.unprefixed(node.value).toLowerCase(), blacklist)) {
          return
        }

        report({
          message: messages.rejected(node.value),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-calc-no-unspaced-operator" id="apidoc.element.stylelint.rules.function-calc-no-unspaced-operator">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-calc-no-unspaced-operator
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-calc-no-unspaced-operator = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    function complain(message, node, index) {
      report({ message, node, index, result, ruleName })
    }

    root.walkDecls(decl =&gt; {
      valueParser(decl.value).walk(node =&gt; {
        if (node.type !== "function" || node.value.toLowerCase() !== "calc") {
          return
        }

        const parensMatch = balancedMatch("(", ")", valueParser.stringify(node))
        const rawExpression = parensMatch.body
        const expressionIndex = decl.source.start.column + decl.prop.length + (decl.raws.between || "").length + node.sourceIndex
        const expression = blurVariables(rawExpression)

        checkSymbol("+")
        checkSymbol("-")
        checkSymbol("*")
        checkSymbol("/")

        function checkSymbol(symbol) {
          const styleSearchOptions = {
            source: expression,
            target: symbol,
            functionArguments: "skip",
          }

          styleSearch(styleSearchOptions, match =&gt; {
            const index = match.startIndex

            // Deal with signs.
            // (@ and $ are considered "digits" here to allow for variable syntaxes
            // that permit signs in front of variables, e.g. `-$number`)
            // As is "." to deal with fractional numbers without a leading zero
            if ((symbol === "+" || symbol === "-") &amp;&amp; /[\d@\$.]/.test(expression[index + 1])) {
              const expressionBeforeSign = expression.substr(0, index)

              // Ignore signs that directly follow a opening bracket
              if (expressionBeforeSign[expressionBeforeSign.length - 1] === "(") {
                return
              }

              // Ignore signs at the beginning of the expression
              if (/^\s*$/.test(expressionBeforeSign)) {
                return
              }

              // Otherwise, ensure that there is a real operator preceeding them
              if (/[\*/+-]\s*$/.test(expressionBeforeSign)) {
                return
              }

              // And if not, complain
              complain(messages.expectedOperatorBeforeSign(symbol), decl, expressionIndex + index)
              return
            }

            const beforeOk = expression[index - 1] === " " &amp;&amp; !isWhitespace(expression[index - 2]) || newlineBefore(expression,
index - 1)
            if (!beforeOk) {
              complain(messages.expectedBefore(symbol), decl, expressionIndex + index)
            }

            const afterOk = expression[index + 1] === " " &amp;&amp; !isWhitespace(expression[index + 2]) || expression[index + 1] === "\n" || expression.substr(index + 1, 2) === "\r\n"

            if (!afterOk) {
              complain(messages.expectedAfter(symbol), decl, expressionIndex + index)
            }
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-comma-newline-after" id="apidoc.element.stylelint.rules.function-comma-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-comma-newline-after = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    functionCommaSpaceChecker({
      root,
      result,
      locationChecker: checker.afterOneOnly,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-comma-newline-before" id="apidoc.element.stylelint.rules.function-comma-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-comma-newline-before = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    functionCommaSpaceChecker({
      root,
      result,
      locationChecker: checker.beforeAllowingIndentation,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-comma-space-after" id="apidoc.element.stylelint.rules.function-comma-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-comma-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    functionCommaSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-comma-space-before" id="apidoc.element.stylelint.rules.function-comma-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-comma-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    functionCommaSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-linear-gradient-no-nonstandard-direction" id="apidoc.element.stylelint.rules.function-linear-gradient-no-nonstandard-direction">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-linear-gradient-no-nonstandard-direction
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-linear-gradient-no-nonstandard-direction = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      functionArgumentsSearch(decl.toString().toLowerCase(), "linear-gradient", (expression, expressionIndex) =&gt; {
        const firstArg = expression.split(",")[0].trim()

        // If the first character is a number, we can assume the user intends an angle
        if (/[\d\.]/.test(firstArg[0])) {
          if (/^[\d\.]+(?:deg|grad|rad|turn)$/.test(firstArg)) {
            return
          }
          complain()
          return
        }

        // The first argument may not be a direction: it may be an angle,
        // or a color stop (in which case user gets default direction, "to bottom")
        // cf. https://drafts.csswg.org/css-images-3/#linear-gradient-syntax
        if (!/left|right|top|bottom/.test(firstArg)) {
          return
        }

        const withToPrefix = !postcss.vendor.prefix(decl.value)
        if (!isStandardDirection(firstArg, withToPrefix)) {
          complain()
          return
        }

        function complain() {
          report({
            message: messages.rejected,
            node: decl,
            index: expressionIndex,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-max-empty-lines" id="apidoc.element.stylelint.rules.function-max-empty-lines">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-max-empty-lines
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-max-empty-lines = function (max) {
  const maxAdjacentNewlines = max + 1

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: _.isNumber,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (decl.value.indexOf("(") === -1) {
        return
      }

      const declString = decl.toString()
      const repeatLFNewLines = _.repeat("\n", maxAdjacentNewlines)
      const repeatCRLFNewLines = _.repeat("\r\n", maxAdjacentNewlines)

      styleSearch({
        source: declString,
        target: "\n",
        functionArguments: "only",
      }, match =&gt; {
        if (declString.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || declString.substr(match.startIndex
 + 1, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {
          // Put index at `\r` if it's CRLF, otherwise leave it at `\n`
          let index = match.startIndex
          if (declString[index - 1] === "\r") {
            index -= 1
          }

          report({
            message: messages.expected(max),
            node: decl,
            index,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-name-case" id="apidoc.element.stylelint.rules.function-name-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-name-case
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-name-case = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    }, {
      actual: options,
      possible: {
        ignoreFunctions: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const value = decl.value

      valueParser(value).walk(function (node) {
        if (node.type !== "function" || !isStandardSyntaxFunction(node)) {
          return
        }

        const functionName = node.value
        const functionNameLowerCase = functionName.toLowerCase()

        const ignoreFunctions = options &amp;&amp; options.ignoreFunctions || []

        if (ignoreFunctions.length &gt; 0 &amp;&amp; matchesStringOrRegExp(functionName, ignoreFunctions)) {
          return
        }

        let expectedFunctionName = null

        if (expectation === "lower" &amp;&amp; mapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase)) {
          expectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase)
        } else if (expectation === "lower") {
          expectedFunctionName = functionNameLowerCase
        } else {
          expectedFunctionName = functionName.toUpperCase()
        }

        if (functionName === expectedFunctionName) {
          return
        }

        report({
          message: messages.expected(functionName, expectedFunctionName),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-parentheses-newline-inside" id="apidoc.element.stylelint.rules.function-parentheses-newline-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-parentheses-newline-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-parentheses-newline-inside = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (decl.value.indexOf("(") === -1) {
        return
      }

      valueParser(decl.value).walk(valueNode =&gt; {
        if (valueNode.type !== "function") {
          return
        }

        if (!isStandardSyntaxFunction(valueNode)) {
          return
        }

        const functionString = valueParser.stringify(valueNode)
        const isMultiLine = !isSingleLineString(functionString)
        function containsNewline(str) {
          return str.indexOf("\n") !== -1
        }

        // Check opening ...

        const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1

        if (expectation === "always" &amp;&amp; !containsNewline(valueNode.before)) {
          complain(messages.expectedOpening, openingIndex)
        }

        if (isMultiLine &amp;&amp; expectation === "always-multi-line" &amp;&amp; !containsNewline(valueNode.before)) {
          complain(messages.expectedOpeningMultiLine, openingIndex)
        }

        if (isMultiLine &amp;&amp; expectation === "never-multi-line" &amp;&amp; valueNode.before !== "") {
          complain(messages.rejectedOpeningMultiLine, openingIndex)
        }

        // Check closing ...

        const closingIndex = valueNode.sourceIndex + functionString.length - 2

        if (expectation === "always" &amp;&amp; !containsNewline(valueNode.after)) {
          complain(messages.expectedClosing, closingIndex)
        }

        if (isMultiLine &amp;&amp; expectation === "always-multi-line" &amp;&amp; !containsNewline(valueNode.after)) {
          complain(messages.expectedClosingMultiLine, closingIndex)
        }

        if (isMultiLine &amp;&amp; expectation === "never-multi-line" &amp;&amp; valueNode.after !== "") {
          complain(messages.rejectedClosingMultiLine, closingIndex)
        }
      })

      function complain(message, offset) {
        report({
          ruleName,
          result,
          message,
          node: decl,
          index: declarationValueIndex(decl) + offset,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-parentheses-space-inside" id="apidoc.element.stylelint.rules.function-parentheses-space-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-parentheses-space-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-parentheses-space-inside = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (decl.value.indexOf("(") === -1) {
        return
      }

      valueParser(decl.value).walk(valueNode =&gt; {
        if (valueNode.type !== "function") {
          return
        }

        if (!isStandardSyntaxFunction(valueNode)) {
          return
        }

        const functionString = valueParser.stringify(valueNode)
        const isSingleLine = isSingleLineString(functionString)

        // Check opening ...

        const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1

        if (expectation === "always" &amp;&amp; valueNode.before !== " ") {
          complain(messages.expectedOpening, openingIndex)
        }

        if (expectation === "never" &amp;&amp; valueNode.before !== "") {
          complain(messages.rejectedOpening, openingIndex)
        }

        if (isSingleLine &amp;&amp; expectation === "always-single-line" &amp;&amp; valueNode.before !== " ") {
          complain(messages.expectedOpeningSingleLine, openingIndex)
        }

        if (isSingleLine &amp;&amp; expectation === "never-single-line" &amp;&amp; valueNode.before !== "") {
          complain(messages.rejectedOpeningSingleLine, openingIndex)
        }

        // Check closing ...

        const closingIndex = valueNode.sourceIndex + functionString.length - 2

        if (expectation === "always" &amp;&amp; valueNode.after !== " ") {
          complain(messages.expectedClosing, closingIndex)
        }

        if (expectation === "never" &amp;&amp; valueNode.after !== "") {
          complain(messages.rejectedClosing, closingIndex)
        }

        if (isSingleLine &amp;&amp; expectation === "always-single-line" &amp;&amp; valueNode.after !== " ") {
          complain(messages.expectedClosingSingleLine, closingIndex)
        }

        if (isSingleLine &amp;&amp; expectation === "never-single-line" &amp;&amp; valueNode.after !== "") {
          complain(messages.rejectedClosingSingleLine, closingIndex)
        }
      })

      function complain(message, offset) {
        report({
          ruleName,
          result,
          message,
          node: decl,
          index: declarationValueIndex(decl) + offset,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-url-data-uris" id="apidoc.element.stylelint.rules.function-url-data-uris">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-data-uris
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-url-data-uris = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      valueParser(decl.value).walk(valueNode =&gt; {
        if (valueNode.type !== "function" || valueNode.value.toLowerCase() !== "url" || !valueNode.nodes.length &gt; 0) {
          return
        }

        const urlValueNode = valueNode.nodes[0]

        if (!urlValueNode.value || !isStandardSyntaxValue(urlValueNode.value) || isVariable(urlValueNode.value)) {
          return
        }

        const valueContainDataUris = urlValueNode.value.toLowerCase().indexOf("data:") === 0
        const needUrlDataUris = expectation === "always"

        if (valueContainDataUris &amp;&amp; needUrlDataUris || !valueContainDataUris &amp;&amp; !needUrlDataUris) {
          return
        }

        const message = needUrlDataUris ? messages.expected : messages.rejected

        report({
          message,
          node: decl,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-url-no-scheme-relative" id="apidoc.element.stylelint.rules.function-url-no-scheme-relative">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-no-scheme-relative
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-url-no-scheme-relative = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      functionArgumentsSearch(decl.toString().toLowerCase(), "url", (args, index) =&gt; {
        const url = _.trim(args, " '\"")

        if (!isStandardSyntaxUrl(url) || url.indexOf("//") !== 0) {
          return
        }

        report({
          message: messages.rejected,
          node: decl,
          index,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-url-quotes" id="apidoc.element.stylelint.rules.function-url-quotes">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-quotes
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-url-quotes = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    }, {
      actual: options,
      possible: {
        except: ["empty"],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(checkStatement)
    root.walkRules(checkStatement)

    function checkStatement(statement) {
      if (statement.type === "atrule") {
        checkAtRuleParams(statement)
      }

      statement.walkDecls(function (decl) {
        functionArgumentsSearch(decl.toString().toLowerCase(), "url", (args, index) =&gt; {
          checkArgs(args, decl, index, "url")
        })
      })
    }

    function checkAtRuleParams(atRule) {
      const atRuleParamsLowerCase = atRule.params.toLowerCase()
      functionArgumentsSearch(atRuleParamsLowerCase, "url", (args, index) =&gt; {
        checkArgs(args, atRule, index + atRuleParamIndex(atRule), "url")
      })
      functionArgumentsSearch(atRuleParamsLowerCase, "url-prefix", (args, index) =&gt; {
        checkArgs(args, atRule, index + atRuleParamIndex(atRule), "url-prefix")
      })
      functionArgumentsSearch(atRuleParamsLowerCase, "domain", (args, index) =&gt; {
        checkArgs(args, atRule, index + atRuleParamIndex(atRule), "domain")
      })
    }

    function checkArgs(args, node, index, functionName) {
      let shouldHasQuotes = expectation === "always"

      const leftTrimmedArgs = args.trimLeft()
      if (!isStandardSyntaxUrl(leftTrimmedArgs)) {
        return
      }
      const complaintIndex = index + args.length - leftTrimmedArgs.length
      const hasQuotes = leftTrimmedArgs[0] === "'" || leftTrimmedArgs[0] === "\""

      const trimmedArg = args.trim()
      const isEmptyArgument = _.includes([
        "",
        "''",
        "\"\"",
      ], trimmedArg)
      if (optionsMatches(options, "except", "empty") &amp;&amp; isEmptyArgument) {
        shouldHasQuotes = !shouldHasQuotes
      }

      if (shouldHasQuotes) {
        if (hasQuotes) {
          return
        }
        complain(messages.expected(functionName), node, complaintIndex)
      } else {
        if (!hasQuotes) {
          return
        }
        complain(messages.rejected(functionName), node, complaintIndex)
      }
    }

    function complain(message, node, index) {
      report({
        message,
        node,
        index,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-url-scheme-whitelist" id="apidoc.element.stylelint.rules.function-url-scheme-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-scheme-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-url-scheme-whitelist = function (whitelist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      functionArgumentsSearch(decl.toString().toLowerCase(), "url", (args, index) =&gt; {
        const unspacedUrlString = _.trim(args, " ")
        if (!isStandardSyntaxUrl(unspacedUrlString)) {
          return
        }
        const urlString = _.trim(unspacedUrlString, "'\"")

        const url = parse(urlString)
        if (url.protocol === null) {
          return
        }

        const scheme = url.protocol.toLowerCase().slice(0, -1) // strip trailing `:`

        // The URL spec does not require a scheme to be followed by `//`, but checking
        // for it allows this rule to differentiate &lt;scheme&gt;:&lt;hostname&gt; urls from
        // &lt;hostname&gt;:&lt;port&gt; urls. `data:` scheme urls are an exception to this rule.
        const slashIndex = url.protocol.length
        const expectedSlashes = urlString.slice(slashIndex, slashIndex + 2)
        const isSchemeLessUrl = expectedSlashes !== "//" &amp;&amp; scheme !== "data"
        if (isSchemeLessUrl) {
          return
        }

        const whitelistLowerCase = typeof whitelist === "string" ? whitelist.toLowerCase() : whitelist.join("|").toLowerCase().split
("|")

        if (containsString(scheme, whitelistLowerCase)) {
          return
        }

        report({
          message: messages.rejected(scheme),
          node: decl,
          index,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-whitelist" id="apidoc.element.stylelint.rules.function-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-whitelist
        <span class="apidocSignatureSpan">(whitelistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-whitelist = function (whitelistInput) {
  const whitelist = [].concat(whitelistInput)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }
    root.walkDecls(decl =&gt; {
      const value = decl.value

      valueParser(value).walk(function (node) {
        if (node.type !== "function") {
          return
        }
        if (!isStandardSyntaxFunction(node)) {
          return
        }
        if (matchesStringOrRegExp(postcss.vendor.unprefixed(node.value).toLowerCase(), whitelist)) {
          return
        }
        report({
          message: messages.rejected(node.value),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-whitespace-after" id="apidoc.element.stylelint.rules.function-whitespace-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-whitespace-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-whitespace-after = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const declString = decl.toString()

      styleSearch({
        source: declString,
        target: ")",
        functionArguments: "only",
      }, match =&gt; {
        checkClosingParen(declString, match.startIndex, decl)
      })
    })

    function checkClosingParen(source, index, node) {
      const nextChar = source[index + 1]
      if (expectation === "always") {
        // Allow for the next character to be a single empty space,
        // another closing parenthesis, a comma, or the end of the value
        if (nextChar === " ") {
          return
        }
        if (nextChar === "\n") {
          return
        }
        if (source.substr(index + 1, 2) === "\r\n") {
          return
        }
        if (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {
          return
        }
        report({
          message: messages.expected,
          node,
          index: index + 1,
          result,
          ruleName,
        })
      } else if (expectation === "never") {
        if (isWhitespace(nextChar)) {
          report({
            message: messages.rejected,
            node,
            index: index + 1,
            result,
            ruleName,
          })
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.indentation" id="apidoc.element.stylelint.rules.indentation">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>indentation
        <span class="apidocSignatureSpan">(space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indentation = function (space) {
  const options = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : {}

  const isTab = space === "tab"
  const indentChar = isTab ? "\t" : _.repeat(" ", space)
  const warningWord = isTab ? "tab" : "space"

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: space,
      possible: [
        _.isNumber,
        "tab",
      ],
    }, {
      actual: options,
      possible: {
        except: [
          "block",
          "value",
          "param",
        ],
        ignore: [
          "value",
          "param",
          "inside-parens",
        ],
        indentInsideParens: [
          "twice",
          "once-at-root-twice-in-block",
        ],
        indentClosingBrace: [_.isBoolean],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    // Cycle through all nodes using walk.
    root.walk(node =&gt; {
      const nodeLevel = indentationLevel(node)
      const expectedWhitespace = _.repeat(indentChar, nodeLevel)

      let before = (node.raws.before || "")
      const after = (node.raws.after || "")

      // Only inspect the spaces before the node
      // if this is the first node in root
      // or there is a newline in the `before` string.
      // (If there is no newline before a node,
      // there is no "indentation" to check.)
      const inspectBefore = root.first === node || before.indexOf("\n") !== -1

      // Cut out any * hacks from `before`
      before = before[before.length - 1] === "*" || before[before.length - 1] === "_" ? before.slice(0, before.length - 1) : before

      // Inspect whitespace in the `before` string that is
      // *after* the *last* newline character,
      // because anything besides that is not indentation for this node:
      // it is some other kind of separation, checked by some separate rule
      if (inspectBefore &amp;&amp; before.slice(before.lastIndexOf("\n") + 1) !== expectedWhitespace) {
        report({
          message: messages.expected(legibleExpectation(nodeLevel)),
          node,
          result,
          ruleName,
        })
      }

      // Only blocks have the `after` string to check.
      // Only inspect `after` strings that start with a newline;
      // otherwise there's no indentation involved.
      // And check `indentClosingBrace` to see if it should be indented an extra level.
      const closingBraceLevel = options.indentClosingBrace ? nodeLevel + 1 : nodeLevel
      if (hasBlock(node) &amp;&amp; after &amp;&amp; after.indexOf("\n") !== -1 &amp;&amp; after.slice(after.lastIndexOf("\n") + 1) !== _.repeat(indentChar
, closingBraceLevel)) {
        report({
          message: messages.expected(legibleExpectation(closingBraceLevel)),
          node,
          index: node.toString().length - 1,
          result,
          ruleName,
        })
      }

      // If this is a declaration, check the value
      if (node.value) {
        checkValue(node, nodeLevel)
      }

      // If this is a rule, check the selector
      if (node.selector) {
        checkSelector(node, nodeLevel)
      }

      // If this is an at rule, check the params
      if (node.type === "atrule") {
        checkAtRuleParams(node, nodeLevel)
      }
    })

    function indentationLevel(node) {
      const level = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0

      if (node.parent.type === "root") {
        return level
      }

      let calculatedLevel

      // Indentation level equals the ancestor nodes
      // separating this node from root; so recursively
      // run this operation
      calculatedLevel = indentationLevel(node.parent, level + 1)

      // If options.except includes "block",
      // blocks are taken down one from their calculated level
      // (all blocks are the same level as their parents)
      if (optionsMatches(options, "except", "block") &amp;&amp; (node.type === "rule" || node.type === "atrule") &amp;&amp; hasBlock(node)) {
        calculatedLevel--
      }

      return calculatedLevel
    }

    function checkValue(decl, declLevel) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.keyframe-declaration-no-important" id="apidoc.element.stylelint.rules.keyframe-declaration-no-important">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>keyframe-declaration-no-important
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keyframe-declaration-no-important = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes =&gt; {
      atRuleKeyframes.walkDecls(decl =&gt; {
        if (!decl.important) {
          return
        }
        report({
          message: messages.rejected,
          node: decl,
          word: "important",
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.length-zero-no-unit" id="apidoc.element.stylelint.rules.length-zero-no-unit">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>length-zero-no-unit
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">length-zero-no-unit = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      check(blurComments(decl.toString()), decl)
    })

    root.walkAtRules(atRule =&gt; {
      const source = hasBlock(atRule) ? beforeBlockString(atRule, { noRawBefore: true }) : atRule.toString()
      check(source, atRule)
    })

    function check(value, node) {
      const ignorableIndexes = new Set()

      styleSearch({ source: value, target: "0" }, match =&gt; {
        const index = match.startIndex

        // Given a 0 somewhere in the full property value (not in a string, thanks
        // to styleSearch) we need to isolate the value that contains the zero.
        // To do so, we'll find the last index before the 0 of a character that would
        // divide one value in a list from another, and the next index of such a
        // character; then we build a substring from those indexes, which we can
        // assess.

        // If a single value includes multiple 0's (e.g. 100.01px), we don't want
        // each 0 to be treated as a separate value, possibly resulting in multiple
        // warnings for the same value (e.g. 0.00px).
        //
        // This check prevents that from happening: we build and check against a
        // Set containing all the indexes that are part of a value already validated.
        if (ignorableIndexes.has(index)) {
          return
        }

        const prevValueBreakIndex = _.findLastIndex(value.substr(0, index), char =&gt; {
          return [
            " ",
            ",",
            ")",
            "(",
            "#",
          ].indexOf(char) !== -1
        })

        // Ignore hex colors
        if (value[prevValueBreakIndex] === "#") {
          return
        }

        // If no prev break was found, this value starts at 0
        const valueWithZeroStart = prevValueBreakIndex === -1 ? 0 : prevValueBreakIndex + 1

        const nextValueBreakIndex = _.findIndex(value.substr(valueWithZeroStart), char =&gt; {
          return [
            " ",
            ",",
            ")",
          ].indexOf(char) !== -1
        })

        // If no next break was found, this value ends at the end of the string
        const valueWithZeroEnd = nextValueBreakIndex === -1 ? value.length : nextValueBreakIndex + valueWithZeroStart

        const valueWithZero = value.slice(valueWithZeroStart, valueWithZeroEnd)
        const parsedValue = valueParser.unit(valueWithZero)

        if (!parsedValue || parsedValue &amp;&amp; !parsedValue.unit) {
          return
        }

        // Add the indexes to ignorableIndexes so the same value will not
        // be checked multiple times.
        _.range(valueWithZeroStart, valueWithZeroEnd).forEach(i =&gt; ignorableIndexes.add(i))

        // Only pay attention if the value parses to 0
        // and units with lengths
        if (parseFloat(valueWithZero, 10) !== 0 || !keywordSets.lengthUnits.has(parsedValue.unit.toLowerCase())) {
          return
        }

        report({
          message: messages.rejected,
          node,
          index: valueWithZeroEnd - parsedValue.unit.length,
          result,
          ruleName,
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.max-empty-lines" id="apidoc.element.stylelint.rules.max-empty-lines">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>max-empty-lines
        <span class="apidocSignatureSpan">(max, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max-empty-lines = function (max, options) {
  const maxAdjacentNewlines = max + 1

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: _.isNumber,
    }, {
      actual: options,
      possible: {
        ignore: [
          "comments",
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const rootString = root.toString()
    const repeatLFNewLines = _.repeat("\n", maxAdjacentNewlines)
    const repeatCRLFNewLines = _.repeat("\r\n", maxAdjacentNewlines)
    const ignoreComments = optionsMatches(options, "ignore", "comments")

    styleSearch({ source: rootString, target: "\n" }, match =&gt; {
      checkMatch(rootString, match.endIndex, root)
    })

    // We must check comments separately in order to accommodate stupid
    // `//`-comments from SCSS, which postcss-scss converts to `/* ... */`,
    // which adds to extra characters at the end, which messes up our
    // warning position
    if (!ignoreComments) {
      root.walkComments(comment =&gt; {
        const source = (comment.raws.left || "") + comment.text + (comment.raws.right || "")
        styleSearch({ source, target: "\n" }, match =&gt; {
          checkMatch(source, match.endIndex, comment, 2)
        })
      })
    }

    function checkMatch(source, matchEndIndex, node) {
      const offset = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : 0

      let violationIndex = false
      if (source.substr(matchEndIndex, maxAdjacentNewlines) === repeatLFNewLines) {
        violationIndex = matchEndIndex + maxAdjacentNewlines
      } else if (source.substr(matchEndIndex, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {
        violationIndex = matchEndIndex + maxAdjacentNewlines * 2
      }

      if (!violationIndex) {
        return
      }

      report({
        message: messages.expected(max),
        node,
        index: violationIndex + offset,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.max-line-length" id="apidoc.element.stylelint.rules.max-line-length">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>max-line-length
        <span class="apidocSignatureSpan">(maxLength, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max-line-length = function (maxLength, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: maxLength,
      possible: _.isNumber,
    }, {
      actual: options,
      possible: {
        ignore: [
          "non-comments",
          "comments",
        ],
        ignorePattern: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const rootString = root.source.input.css

    const ignoreNonComments = optionsMatches(options, "ignore", "non-comments")
    const ignoreComments = optionsMatches(options, "ignore", "comments")

    // Check first line
    checkNewline({ endIndex: 0 })

    // Check subsequent lines
    styleSearch({ source: rootString, target: ["\n"], comments: "check" }, checkNewline)

    function complain(index) {
      report({
        index,
        result,
        ruleName,
        message: messages.expected(maxLength),
        node: root,
      })
    }

    function checkNewline(match) {
      let nextNewlineIndex = rootString.indexOf("\n", match.endIndex)
      if (rootString[nextNewlineIndex - 1] === "\r") {
        nextNewlineIndex -= 1
      }

      // Accommodate last line
      if (nextNewlineIndex === -1) {
        nextNewlineIndex = rootString.length
      }

      const rawLineLength = nextNewlineIndex - match.endIndex
      const lineText = rootString.slice(match.endIndex, nextNewlineIndex)

      if (optionsMatches(options, "ignorePattern", lineText)) {
        return
      }

      const urlArgumentsLength = execall(/url\((.*)\)/ig, lineText).reduce((result, match) =&gt; {
        return result + _.get(match, "sub[0].length", 0)
      }, 0)

      const importUrlsLength = execall(/\@import\s+(['"].*['"])/ig, lineText).reduce((result, match) =&gt; {
        return result + _.get(match, "sub[0].length", 0)
      }, 0)

      // If the line's length is less than or equal to the specified
      // max, ignore it ... So anything below is liable to be complained about.
      // **Note that the length of any url arguments or import urls
      // are excluded from the calculation.**
      if (rawLineLength - urlArgumentsLength - importUrlsLength &lt;= maxLength) {
        return
      }

      const complaintIndex = nextNewlineIndex - 1

      if (ignoreComments) {
        if (match.insideComment) {
          return
        }

        // This trimming business is to notice when the line starts a
        // comment but that comment is indented, e.g.
        //<span class="apidocCodeCommentSpan">       /* something here */
</span>        const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2)
        if (nextTwoChars === "/*" || nextTwoChars === "//") {
          return
        }
      }

      if (ignoreNonComments) {
        if (match.insideComment) {
          return complain(complaintIndex)
        }

        // This trimming business is to notice when the line starts a
        // comment but that comment is indented, e.g.
        //       /* something here */
        const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2)
        if (nextTwoChars !== "/*" &amp;&amp; nextTwoChars !== "//") {
          return
        }
        return complain(complaintIndex)
      }

      // If there are no spaces besides initial (indent) spaces, ignore it
      const lineString = rootString.slice(match.endIndex, nextNewlineIndex)
      if (lineString.replace(/^\s+/, "").indexOf(" ") === -1) {
        return
      }

      return complain(complaintIndex)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.max-nesting-depth" id="apidoc.element.stylelint.rules.max-nesting-depth">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>max-nesting-depth
        <span class="apidocSignatureSpan">(max, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max-nesting-depth = function (max, options) {
  const ignoreAtRulesWithoutDeclarationBlocks = optionsMatches(options, "ignore", "at-rules-without-declaration-blocks") || optionsMatches
(options, "ignore", "blockless-at-rules")
  const isIgnoreAtRule = node =&gt; node.type === "atrule" &amp;&amp; optionsMatches(options, "ignoreAtRules", node.name)

  return (root, result) =&gt; {
    validateOptions(result, ruleName, {
      actual: max,
      possible: [_.isNumber],
    }, {
      optional: true,
      actual: options,
      possible: {
        ignore: [
          "at-rules-without-declaration-blocks",
          "blockless-at-rules",
        ],
        ignoreAtRules: [_.isString],
      },
    })

    if (optionsMatches(options, "ignore", "at-rules-without-declaration-blocks")) {
      result.warn((
        "'max-nesting-depth\'s' \"at-rules-without-declaration-blocks\" option has been deprecated and in 8.0 will be removed. Instead
 use the\"blockless-at-rules\" option."
      ), {
        stylelintType: "deprecation",
        stylelintReference: "https://stylelint.io/user-guide/rules/max-nesting-depth/",
      })
    }

    root.walkRules(checkStatement)
    root.walkAtRules(checkStatement)

    function checkStatement(statement) {
      if (isIgnoreAtRule(statement)) {
        return
      }
      if (!hasBlock(statement)) {
        return
      }
      const depth = nestingDepth(statement)
      if (depth &gt; max) {
        report({
          ruleName,
          result,
          node: statement,
          message: messages.expected(max),
        })
      }
    }
  }

  function nestingDepth(node, level) {
    level = level || 0
    const parent = node.parent

    if (isIgnoreAtRule(parent)) {
      return 0
    }

    // The nesting depth level's computation has finished
    // when this function, recursively called, receives
    // a node that is not nested -- a direct child of the
    // root node
    if (parent.type === "root" || parent.type === "atrule" &amp;&amp; parent.parent.type === "root") {
      return level
    }

    if (ignoreAtRulesWithoutDeclarationBlocks &amp;&amp; node.type === "atrule" &amp;&amp; node.every(child =&gt; child.type !== "decl")) {
      return nestingDepth(parent, level)
    }

    // Unless any of the conditions above apply, we want to
    // add 1 to the nesting depth level and then check the parent,
    // continuing to add and move up the hierarchy
    // until we hit the root node
    return nestingDepth(parent, level + 1)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-colon-space-after" id="apidoc.element.stylelint.rules.media-feature-colon-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-colon-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-colon-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    mediaFeatureColonSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-colon-space-before" id="apidoc.element.stylelint.rules.media-feature-colon-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-colon-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-colon-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    mediaFeatureColonSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-blacklist" id="apidoc.element.stylelint.rules.media-feature-name-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-blacklist = function (blacklist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&gt; {
      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode =&gt; {
        const parent = mediaFeatureNode.parent,
          sourceIndex = mediaFeatureNode.sourceIndex,
          value = mediaFeatureNode.value

        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
          return
        }

        if (!matchesStringOrRegExp(value.toLowerCase(), blacklist)) {
          return
        }

        report({
          index: atRuleParamIndex(atRule) + sourceIndex,
          message: messages.rejected(value),
          node: atRule,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-case" id="apidoc.element.stylelint.rules.media-feature-name-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-case = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&gt; {
      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode =&gt; {
        const parent = mediaFeatureNode.parent,
          sourceIndex = mediaFeatureNode.sourceIndex,
          value = mediaFeatureNode.value

        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
          return
        }

        const expectedFeatureName = expectation === "lower" ? value.toLowerCase() : value.toUpperCase()

        if (value === expectedFeatureName) {
          return
        }

        report({
          index: atRuleParamIndex(atRule) + sourceIndex,
          message: messages.expected(value, expectedFeatureName),
          node: atRule,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-no-unknown" id="apidoc.element.stylelint.rules.media-feature-name-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-no-unknown = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreMediaFeatureNames: [_.isString],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&gt; {
      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode =&gt; {
        const parent = mediaFeatureNode.parent,
          sourceIndex = mediaFeatureNode.sourceIndex,
          value = mediaFeatureNode.value

        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
          return
        }

        if (optionsMatches(options, "ignoreMediaFeatureNames", value)) {
          return
        }

        if (postcss.vendor.prefix(value) || keywordSets.mediaFeatureNames.has(value.toLowerCase())) {
          return
        }

        report({
          index: atRuleParamIndex(atRule) + sourceIndex,
          message: messages.rejected(value),
          node: atRule,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-no-vendor-prefix" id="apidoc.element.stylelint.rules.media-feature-name-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-no-vendor-prefix = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&gt; {
      const params = atRule.params

      if (!isAutoprefixable.mediaFeatureName(params)) {
        return
      }
      const matches = atRule.toString().match(/[a-z-]+device-pixel-ratio/ig)

      if (!matches) { return }

      matches.forEach(match =&gt; {
        report({
          message: messages.rejected,
          node: atRule,
          word: match,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-whitelist" id="apidoc.element.stylelint.rules.media-feature-name-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-whitelist = function (whitelist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&gt; {
      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode =&gt; {
        const parent = mediaFeatureNode.parent,
          sourceIndex = mediaFeatureNode.sourceIndex,
          value = mediaFeatureNode.value

        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
          return
        }

        if (matchesStringOrRegExp(value.toLowerCase(), whitelist)) {
          return
        }

        report({
          index: atRuleParamIndex(atRule) + sourceIndex,
          message: messages.rejected(value),
          node: atRule,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-no-missing-punctuation" id="apidoc.element.stylelint.rules.media-feature-no-missing-punctuation">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-no-missing-punctuation
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-no-missing-punctuation = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      "'media-feature-no-missing-punctuation' has been deprecated and in 8.0 will be removed."
    ), {
      stylelintType: "deprecation",
      stylelintReference: "https://stylelint.io/user-guide/rules/media-feature-no-missing-punctuation/",
    })

    root.walkAtRules(/^media$/i, atRule =&gt; {
      execall(/\((.*?)\)/g, atRule.params).forEach(mediaFeatureMatch =&gt; {
        if (!isStandardSyntaxMediaFeature(mediaFeatureMatch.match)) {
          return
        }

        const splitMediaFeature = mediaFeatureMatch.sub[0].trim().split(/\s+/)
        if (splitMediaFeature.length === 1) {
          return
        }

        // Ignore the last one
        for (let i = 0, l = splitMediaFeature.length - 1; i &lt; l; i++) {
          const mediaFeaturePart = splitMediaFeature[i]

          // This part is valid if it is punctuation,
          // it ends with punctuation,
          // the next part is punctuation,
          // or the next part begins with punctuation
          if (isPunctuation(mediaFeaturePart)) {
            continue
          }
          if (endsWithPunctuation(mediaFeaturePart)) {
            continue
          }
          const nextPart = splitMediaFeature[i + 1]
          if (isPunctuation(nextPart)) {
            continue
          }
          if (startsWithPunctuation(nextPart)) {
            continue
          }

          return report({
            result,
            ruleName,
            message: messages.rejected,
            node: atRule,
            index: atRuleParamIndex(atRule) + mediaFeatureMatch.index,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-parentheses-space-inside" id="apidoc.element.stylelint.rules.media-feature-parentheses-space-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-parentheses-space-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-parentheses-space-inside = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&gt; {
      // If there are comments in the params, the complete string
      // will be at atRule.raws.params.raw
      const params = _.get(atRule, "raws.params.raw", atRule.params)
      const indexBoost = atRuleParamIndex(atRule)

      styleSearch({ source: params, target: "(" }, match =&gt; {
        const nextCharIsSpace = params[match.startIndex + 1] === " "
        if (nextCharIsSpace &amp;&amp; expectation === "never") {
          report({
            message: messages.rejectedOpening,
            node: atRule,
            index: match.startIndex + 1 + indexBoost,
            result,
            ruleName,
          })
        }
        if (!nextCharIsSpace &amp;&amp; expectation === "always") {
          report({
            message: messages.expectedOpening,
            node: atRule,
            index: match.startIndex + 1 + indexBoost,
            result,
            ruleName,
          })
        }
      })

      styleSearch({ source: params, target: ")" }, match =&gt; {
        const prevCharIsSpace = params[match.startIndex - 1] === " "
        if (prevCharIsSpace &amp;&amp; expectation === "never") {
          report({
            message: messages.rejectedClosing,
            node: atRule,
            index: match.startIndex - 1 + indexBoost,
            result,
            ruleName,
          })
        }
        if (!prevCharIsSpace &amp;&amp; expectation === "always") {
          report({
            message: messages.expectedClosing,
            node: atRule,
            index: match.startIndex - 1 + indexBoost,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-range-operator-space-after" id="apidoc.element.stylelint.rules.media-feature-range-operator-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-range-operator-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-range-operator-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&gt; {
      findMediaOperator(atRule, checkAfterOperator)
    })

    function checkAfterOperator(match, params, node) {
      const endIndex = match.index + match[1].length

      checker.after({
        source: params,
        index: endIndex,
        err: m =&gt; {
          report({
            message: m,
            node,
            index: endIndex + atRuleParamIndex(node) + 1,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-range-operator-space-before" id="apidoc.element.stylelint.rules.media-feature-range-operator-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-range-operator-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-range-operator-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&gt; {
      findMediaOperator(atRule, checkBeforeOperator)
    })

    function checkBeforeOperator(match, params, node) {
      // The extra `+ 1` is because the match itself contains
      // the character before the operator
      checker.before({
        source: params,
        index: match.index + 1,
        err: m =&gt; {
          report({
            message: m,
            node,
            index: match.index + atRuleParamIndex(node),
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-query-list-comma-newline-after" id="apidoc.element.stylelint.rules.media-query-list-comma-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-query-list-comma-newline-after = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    // Only check for the newline after the comma, while allowing
    // arbitrary indentation after the newline
    mediaQueryListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.afterOneOnly,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-query-list-comma-newline-before" id="apidoc.element.stylelint.rules.media-query-list-comma-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-query-list-comma-newline-before = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }
    mediaQueryListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.beforeAllowingIndentation,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-query-list-comma-space-after" id="apidoc.element.stylelint.rules.media-query-list-comma-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-query-list-comma-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }
    mediaQueryListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-query-list-comma-space-before" id="apidoc.element.stylelint.rules.media-query-list-comma-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-query-list-comma-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    mediaQueryListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-browser-hacks" id="apidoc.element.stylelint.rules.no-browser-hacks">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-browser-hacks
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-browser-hacks = function (on, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      optional: true,
      actual: options,
      possible: {
        browsers: [_.isString],
      },
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed. Use 'stylelint-no-browser-hacks' plugin instead.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    const stylehacksOptions = { lint: true }
    if (options &amp;&amp; options.browsers) {
      stylehacksOptions.browsers = options.browsers
    }

    const stylehacksResult = new Result()
    stylehacks(stylehacksOptions)(root, stylehacksResult)
    stylehacksResult.warnings().forEach(stylehacksWarning =&gt; {
      const message = messages.rejected(stylehacksWarning.identifier, stylehacksWarning.hack)
      report({
        ruleName,
        result,
        message,
        node: stylehacksWarning.node,
        line: stylehacksWarning.line,
        column: stylehacksWarning.column,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-descending-specificity" id="apidoc.element.stylelint.rules.no-descending-specificity">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-descending-specificity
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-descending-specificity = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const selectorContextLookup = nodeContextLookup()

    root.walkRules(rule =&gt; {
      // Ignore custom property set `--foo: {};`
      if (isCustomPropertySet(rule)) {
        return
      }

      const comparisonContext = selectorContextLookup.getContext(rule, findAtRuleContext(rule))

      rule.selectors.forEach(selector =&gt; {
        const trimSelector = selector.trim()
        // Ignore `.selector, { }`
        if (trimSelector === "") {
          return
        }

        // The edge-case of duplicate selectors will act acceptably
        const index = rule.selector.indexOf(trimSelector)
        // Resolve any nested selectors before checking
        resolvedNestedSelector(selector, rule).forEach(resolvedSelector =&gt; {
          parseSelector(resolvedSelector, result, rule, s =&gt; checkSelector(s, rule, index, comparisonContext))
        })
      })
    })

    function checkSelector(selectorNode, rule, sourceIndex, comparisonContext) {
      const selector = selectorNode.toString()
      const referenceSelectorNode = lastCompoundSelectorWithoutPseudoClasses(selectorNode)
      const selectorSpecificity = specificity.calculate(selector)[0].specificityArray
      const entry = { selector, specificity: selectorSpecificity }

      if (!comparisonContext.has(referenceSelectorNode)) {
        comparisonContext.set(referenceSelectorNode, [entry])
        return
      }

      const priorComparableSelectors = comparisonContext.get(referenceSelectorNode)

      priorComparableSelectors.forEach(priorEntry =&gt; {
        if (specificity.compare(selectorSpecificity, priorEntry.specificity) === -1) {
          report({
            ruleName,
            result,
            node: rule,
            message: messages.rejected(selector, priorEntry.selector),
            index: sourceIndex,
          })
        }
      })

      priorComparableSelectors.push(entry)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-duplicate-selectors" id="apidoc.element.stylelint.rules.no-duplicate-selectors">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-duplicate-selectors
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-duplicate-selectors = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    // The top level of this map will be rule sources.
    // Each source maps to another map, which maps rule parents to a set of selectors.
    // This ensures that selectors are only checked against selectors
    // from other rules that share the same parent and the same source.
    const selectorContextLookup = nodeContextLookup()

    root.walkRules(rule =&gt; {
      if (isKeyframeRule(rule)) {
        return
      }

      const contextSelectorSet = selectorContextLookup.getContext(rule, findAtRuleContext(rule))
      const resolvedSelectors = rule.selectors.reduce((result, selector) =&gt; {
        return _.union(result, resolvedNestedSelector(selector, rule))
      }, [])
      const normalizedSelectorList = resolvedSelectors.map(normalizeSelector)
      const selectorLine = rule.source.start.line

      // Complain if the same selector list occurs twice

      // Sort the selectors list so that the order of the constituents
      // doesn't matter
      const sortedSelectorList = normalizedSelectorList.slice().sort().join(",")
      if (contextSelectorSet.has(sortedSelectorList)) {
        // If the selector isn't nested we can use its raw value; otherwise,
        // we have to approximate something for the message -- which is close enough
        const isNestedSelector = resolvedSelectors.join(",") !== rule.selectors.join(",")
        const selectorForMessage = isNestedSelector ? resolvedSelectors.join(", ") : rule.selector
        const previousDuplicatePosition = contextSelectorSet.get(sortedSelectorList)

        return report({
          result,
          ruleName,
          node: rule,
          message: messages.rejected(selectorForMessage, previousDuplicatePosition),
        })
      }

      contextSelectorSet.set(sortedSelectorList, selectorLine)

      // Or complain if one selector list contains the same selector more than one
      rule.selectors.forEach((selector, i) =&gt; {
        if (_.includes(normalizedSelectorList.slice(0, i), normalizeSelector(selector))) {
          report({
            result,
            ruleName,
            node: rule,
            message: messages.rejected(selector, selectorLine),
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-empty-source" id="apidoc.element.stylelint.rules.no-empty-source">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-empty-source
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-empty-source = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    if (!/^\s*$/.test(root.toString())) {
      return
    }

    report({
      message: messages.rejected,
      node: root,
      result,
      ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-eol-whitespace" id="apidoc.element.stylelint.rules.no-eol-whitespace">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-eol-whitespace
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-eol-whitespace = function (on, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: on,
    }, {
      optional: true,
      actual: options,
      possible: {
        ignore: ["empty-lines"],
      },
    })
    if (!validOptions) {
      return
    }

    const rootString = root.toString()
    styleSearch({
      source: rootString,
      target: [
        "\n",
        "\r",
      ],
      comments: "check",
    }, match =&gt; {
      // If the character before newline is not whitespace, ignore
      if (!whitespacesToReject.has(rootString[match.startIndex - 1])) {
        return
      }

      if (optionsMatches(options, "ignore", "empty-lines")) {
        // If there is only whitespace between the previous newline and
        // this newline, ignore
        const lineBefore = rootString.substring(match.startIndex + 1, rootString.lastIndexOf("\n", match.startIndex - 1))
        if (isOnlyWhitespace(lineBefore)) {
          return
        }
      }

      report({
        message: messages.rejected,
        node: root,
        index: match.startIndex - 1,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-extra-semicolons" id="apidoc.element.stylelint.rules.no-extra-semicolons">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-extra-semicolons
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-extra-semicolons = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const rawAfterRoot = root.raws.after

    if (rawAfterRoot &amp;&amp; rawAfterRoot.trim().length !== 0) {
      styleSearch({ source: rawAfterRoot, target: ";" }, match =&gt; {
        complain(root.toString().length - rawAfterRoot.length + match.startIndex)
      })
    }

    root.walk(node =&gt; {
      let rawBeforeNode = node.raws.before

      if (rawBeforeNode &amp;&amp; rawBeforeNode.trim().length !== 0) {
        let allowedSemi = 0

        // Forbid semicolon before first custom properties sets
        if (isCustomPropertySet(node) &amp;&amp; node.parent.index(node) &gt; 0) {
          allowedSemi = 1
        }

        const next = node.next()

        // Ignore semicolon before comment if next node is custom properties sets or comment
        if (node.type === "comment" &amp;&amp; next
          &amp;&amp; (isCustomPropertySet(next) &amp;&amp; node.parent.index(next) &gt; 0 || next.type === "comment")
        ) {
          allowedSemi = 1
        }

        const prev = node.prev()

        // Adding previous node string to custom properties set if previous node is comment
        if (isCustomPropertySet(node) &amp;&amp; node.parent.index(node) &gt; 0 &amp;&amp; prev &amp;&amp; prev.type === "comment") {
          rawBeforeNode = prev.toString() + rawBeforeNode
          allowedSemi = 0
        }

        styleSearch({ source: rawBeforeNode, target: ";" }, (match, count) =&gt; {
          if (count === allowedSemi) {
            return
          }

          complain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex)
        })
      }

      const rawAfterNode = node.raws.after

      if (rawAfterNode &amp;&amp; rawAfterNode.trim().length !== 0) {
        let allowedSemi = 0

        if (!hasEmptyBlock(node) &amp;&amp; isCustomPropertySet(node.nodes[node.nodes.length - 1])) {
          allowedSemi = 1
        }

        styleSearch({ source: rawAfterNode, target: ";" }, (match, count) =&gt; {
          if (count === allowedSemi) {
            return
          }

          const index = getOffsetByNode(node) + node.toString().length - 1 - rawAfterNode.length + match.startIndex
          complain(index)
        })
      }
    })

    function complain(index) {
      report({
        message: messages.rejected,
        node: root,
        index,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-indistinguishable-colors" id="apidoc.element.stylelint.rules.no-indistinguishable-colors">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-indistinguishable-colors
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-indistinguishable-colors = function (on, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      optional: true,
      actual: options,
      possible: {
        ignore: isValidHex,
        threshold: x =&gt; _.isNumber(x) &amp;&amp; x &gt;= 0 &amp;&amp; x &lt;= 100,
        whitelist: x =&gt; _.isArray(x) &amp;&amp; x.every(isValidHex),
      },
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    const colorguardResult = new Result()
    colorguard(options)(root, colorguardResult)
    colorguardResult.warnings().forEach(colorguardWarning =&gt; {
      const message = messages.rejected(colorguardWarning.secondColor, colorguardWarning.firstColor)
      report({
        ruleName,
        result,
        message,
        node: colorguardWarning.node,
        index: colorguardWarning.node.toString().indexOf(colorguardWarning.secondColor),
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-invalid-double-slash-comments" id="apidoc.element.stylelint.rules.no-invalid-double-slash-comments">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-invalid-double-slash-comments
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-invalid-double-slash-comments = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (decl.prop.indexOf("//") === 0) {
        report({
          message: messages.rejected,
          node: decl,
          result,
          ruleName,
        })
      }
    })
    root.walkRules(rule =&gt; {
      rule.selectors.forEach(selector =&gt; {
        if (selector.indexOf("//") === 0) {
          report({
            message: messages.rejected,
            node: rule,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-missing-end-of-source-newline" id="apidoc.element.stylelint.rules.no-missing-end-of-source-newline">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-missing-end-of-source-newline
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-missing-end-of-source-newline = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const sourceCss = root.source.input.css
    if (sourceCss === "" || sourceCss.slice(-1) === "\n") {
      return
    }

    report({
      message: messages.rejected,
      node: root,
      index: sourceCss.length - 1,
      result,
      ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-unknown-animations" id="apidoc.element.stylelint.rules.no-unknown-animations">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-unknown-animations
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-unknown-animations = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const declaredAnimations = new Set()
    root.walkAtRules(/(-(moz|webkit)-)?keyframes/i, atRule =&gt; {
      declaredAnimations.add(atRule.params)
    })

    root.walkDecls(decl =&gt; {
      if (decl.prop.toLowerCase() === "animation" || decl.prop.toLowerCase() === "animation-name") {
        const animationNames = findAnimationName(decl.value)

        if (animationNames.length === 0) {
          return
        }

        animationNames.forEach(animationNameNode =&gt; {
          if (keywordSets.animationNameKeywords.has(animationNameNode.value.toLowerCase())) {
            return
          }
          if (declaredAnimations.has(animationNameNode.value)) {
            return
          }

          report({
            result,
            ruleName,
            message: messages.rejected(animationNameNode.value),
            node: decl,
            index: declarationValueIndex(decl) + animationNameNode.sourceIndex,
          })
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-unsupported-browser-features" id="apidoc.element.stylelint.rules.no-unsupported-browser-features">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-unsupported-browser-features
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-unsupported-browser-features = function (on, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      optional: true,
      actual: options,
      possible: {
        browsers: [_.isString],
        ignore: [_.isString],
      },
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    const doiuseOptions = {}

    if (options &amp;&amp; options.browsers) {
      doiuseOptions.browsers = options.browsers
    }

    if (options &amp;&amp; options.ignore) {
      doiuseOptions.ignore = options.ignore
    }

    const doiuseResult = new Result()
    doiuse(doiuseOptions).postcss(root, doiuseResult)
    doiuseResult.warnings().forEach(doiuseWarning =&gt; {
      report({
        ruleName,
        result,
        message: messages.rejected(cleanDoiuseWarningText(doiuseWarning.text)),
        node: doiuseWarning.node,
        line: doiuseWarning.line,
        column: doiuseWarning.column,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.number-leading-zero" id="apidoc.element.stylelint.rules.number-leading-zero">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>number-leading-zero
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number-leading-zero = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      if (atRule.name.toLowerCase() === "import") {
        return
      }

      check(atRule, atRule.params, atRuleParamIndex)
    })

    root.walkDecls(decl =&gt; check(decl, decl.value, declarationValueIndex))

    function check(node, value, getIndex) {
      // Get out quickly if there are no periods
      if (value.indexOf(".") === -1) {
        return
      }

      valueParser(value).walk(valueNode =&gt; {
        // Ignore `url` function
        if (valueNode.type === "function" &amp;&amp; valueNode.value.toLowerCase() === "url") {
          return false
        }

        // Ignore strings, comments, etc
        if (valueNode.type !== "word") {
          return
        }

        // Check leading zero
        if (expectation === "always") {
          const match = /(?:\D|^)(\.\d+)/.exec(valueNode.value)

          if (match === null) {
            return
          }

          // The regexp above consists of 2 capturing groups (or capturing parentheses).
          // We need the index of the second group. This makes sanse when we have "-.5" as an input
          // for regex. And we need the index of ".5".
          const capturingGroupIndex = match[0].length - match[1].length
          complain(messages.expected, node, getIndex(node) + valueNode.sourceIndex + match.index + capturingGroupIndex)
        }

        if (expectation === "never") {
          const match = /(?:\D|^)(0+\.\d+)/.exec(valueNode.value)

          if (match === null) {
            return
          }

          const capturingGroupIndex = match[0].length - match[1].length
          complain(messages.rejected, node, getIndex(node) + valueNode.sourceIndex + match.index + capturingGroupIndex)
        }
      })
    }

    function complain(message, node, index) {
      report({
        result,
        ruleName,
        message,
        node,
        index,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.number-max-precision" id="apidoc.element.stylelint.rules.number-max-precision">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>number-max-precision
        <span class="apidocSignatureSpan">(precision)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number-max-precision = function (precision) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: precision,
      possible: [_.isNumber],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      if (atRule.name.toLowerCase() === "import") {
        return
      }

      check(atRule, atRule.params, atRuleParamIndex)
    })

    root.walkDecls(decl =&gt; check(decl, decl.value, declarationValueIndex))

    function check(node, value, getIndex) {
      // Get out quickly if there are no periods
      if (value.indexOf(".") === -1) {
        return
      }

      valueParser(value).walk(valueNode =&gt; {
        // Ignore `url` function
        if (valueNode.type === "function" &amp;&amp; valueNode.value.toLowerCase() === "url") {
          return false
        }

        // Ignore strings, comments, etc
        if (valueNode.type !== "word") {
          return
        }

        const match = /\d*\.(\d+)/.exec(valueNode.value)

        if (match === null) {
          return
        }

        if (match[1].length &lt;= precision) {
          return
        }

        report({
          result,
          ruleName,
          node,
          index: getIndex(node) + valueNode.sourceIndex + match.index,
          message: messages.expected(parseFloat(match[0]), precision),
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.number-no-trailing-zeros" id="apidoc.element.stylelint.rules.number-no-trailing-zeros">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>number-no-trailing-zeros
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number-no-trailing-zeros = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&gt; {
      if (atRule.name.toLowerCase() === "import") {
        return
      }

      check(atRule, atRule.params, atRuleParamIndex)
    })

    root.walkDecls(decl =&gt; check(decl, decl.value, declarationValueIndex))

    function check(node, value, getIndex) {
      // Get out quickly if there are no periods
      if (value.indexOf(".") === -1) {
        return
      }

      valueParser(value).walk(valueNode =&gt; {
        // Ignore `url` function
        if (valueNode.type === "function" &amp;&amp; valueNode.value.toLowerCase() === "url") {
          return false
        }

        // Ignore strings, comments, etc
        if (valueNode.type !== "word") {
          return
        }

        const match = /(\.\d*)0+(?:\D|$)/.exec(valueNode.value)

        if (match === null) {
          return
        }

        report({
          message: messages.rejected,
          node,
          index: getIndex(node) + valueNode.sourceIndex + match.index + match[1].length,
          result,
          ruleName,
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-blacklist" id="apidoc.element.stylelint.rules.property-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-blacklist = function (blacklist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop

      if (!isStandardSyntaxProperty(prop)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }
      if (!matchesStringOrRegExp(postcss.vendor.unprefixed(prop), blacklist)) {
        return
      }

      report({
        message: messages.rejected(prop),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-case" id="apidoc.element.stylelint.rules.property-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-case = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop

      if (!isStandardSyntaxProperty(prop)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }

      const expectedProp = expectation === "lower" ? prop.toLowerCase() : prop.toUpperCase()
      if (prop === expectedProp) {
        return
      }

      report({
        message: messages.expected(prop, expectedProp),
        node: decl,
        ruleName,
        result,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-no-unknown" id="apidoc.element.stylelint.rules.property-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-no-unknown = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreProperties: [_.isString],
        checkPrefixed: _.isBoolean,
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    const shouldCheckPrefixed = _.get(options, "checkPrefixed")

    root.walkDecls(decl =&gt; {
      const prop = decl.prop

      if (!isStandardSyntaxProperty(prop)) {
        return
      }
      if (!isStandardSyntaxDeclaration(decl)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }

      if (!shouldCheckPrefixed &amp;&amp; postcss.vendor.prefix(prop)) {
        return
      }

      if (optionsMatches(options, "ignoreProperties", prop)) {
        return
      }

      if (properties.indexOf(prop.toLowerCase()) !== -1) {
        return
      }

      report({
        message: messages.rejected(prop),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-no-vendor-prefix" id="apidoc.element.stylelint.rules.property-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-no-vendor-prefix = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop

      // Make sure there's a vendor prefix,
      // but this isn't a custom property

      if (prop[0] !== "-" || prop[1] === "-") {
        return
      }

      if (!isAutoprefixable.property(prop)) {
        return
      }
      report({
        message: messages.rejected(prop),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-whitelist" id="apidoc.element.stylelint.rules.property-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-whitelist = function (whitelist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop

      if (!isStandardSyntaxProperty(prop)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }
      if (matchesStringOrRegExp(postcss.vendor.unprefixed(prop), whitelist)) {
        return
      }

      report({
        message: messages.rejected(prop),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.root-no-standard-properties" id="apidoc.element.stylelint.rules.root-no-standard-properties">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>root-no-standard-properties
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">root-no-standard-properties = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use the community 'stylelint-suitcss' plugin pack.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&gt; {
      if (rule.selector.toLowerCase().indexOf(":root") === -1) {
        return
      }
      parseSelector(rule.selector, result, rule, checkSelector)

      function checkSelector(selectorAST) {
        if (ignoreRule(selectorAST)) {
          return
        }

        rule.each(function (node) {
          if (node.type !== "decl") {
            return
          }

          const prop = node.prop

          if (!isStandardSyntaxProperty(prop)) {
            return
          }
          if (isCustomProperty(prop)) {
            return
          }

          report({
            message: messages.rejected(prop),
            node,
            result,
            ruleName,
          })
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.rule-empty-line-before" id="apidoc.element.stylelint.rules.rule-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rule-empty-line-before = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-multi-line",
        "never-multi-line",
      ],
    }, {
      actual: options,
      possible: {
        ignore: [
          "after-comment",
          "inside-block",
        ],
        except: [
          "after-rule",
          "after-single-line-comment",
          "first-nested",
          "inside-block-and-after-rule",
        ],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      // Ignore the first node
      if (rule === root.first) {
        return
      }

      let expectEmptyLineBefore = expectation.indexOf("always") !== -1 ? true : false

      // Optionally ignore the expectation if a comment precedes this node
      if (
        optionsMatches(options, "ignore", "after-comment")
        &amp;&amp; rule.prev()
        &amp;&amp; rule.prev().type === "comment"
      ) {
        return
      }

      // Optionally ignore the expectation if inside a block
      if (
        optionsMatches(options, "ignore", "inside-block")
        &amp;&amp; rule.parent !== root
      ) {
        return
      }

      // Ignore if the expectation is for multiple and the rule is single-line
      if (
        expectation.indexOf("multi-line") !== -1
        &amp;&amp; isSingleLineString(rule.toString())
      ) {
        return
      }

      // Optionally reverse the expectation for the first nested node
      if (
        optionsMatches(options, "except", "first-nested")
        &amp;&amp; rule === rule.parent.first
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a rule precedes this node
      if (
        optionsMatches(options, "except", "after-rule")
        &amp;&amp; rule.prev()
        &amp;&amp; rule.prev().type === "rule"
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a rule precedes this node and is inside a block
      if (
        optionsMatches(options, "except", "inside-block-and-after-rule")
        &amp;&amp; rule.prev()
        &amp;&amp; rule.prev().type === "rule"
        &amp;&amp; rule.parent !== root
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation for single line comments
      if (
        optionsMatches(options, "except", "after-single-line-comment")
        &amp;&amp; rule.prev()
        &amp;&amp; rule.prev().type === "comment"
        &amp;&amp; isSingleLineString(rule.prev().toString())
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      const hasEmptyLineBefore = hasEmptyLine(rule.raws.before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore ? messages.expected : messages.rejected

      report({
        message,
        node: rule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.rule-nested-empty-line-before" id="apidoc.element.stylelint.rules.rule-nested-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-nested-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rule-nested-empty-line-before = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-multi-line",
        "never-multi-line",
      ],
    }, {
      actual: options,
      possible: {
        ignore: ["after-comment"],
        except: [
          "first-nested",
          "after-comment",
          "after-rule",
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use 'rule-empty-line-before'.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      // Only attend to nested rule sets
      if (rule.parent === root) {
        return
      }

      checkRuleEmptyLineBefore({ rule, expectation, options, result, messages, checkedRuleName: ruleName })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.rule-non-nested-empty-line-before" id="apidoc.element.stylelint.rules.rule-non-nested-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-non-nested-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rule-non-nested-empty-line-before = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-multi-line",
        "never-multi-line",
      ],
    }, {
      actual: options,
      possible: {
        ignore: ["after-comment"],
        except: ["after-single-line-comment"],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use 'rule-empty-line-before'.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      // Ignore nested rule sets
      if (rule.parent !== root) {
        return
      }

      // Ignore the first node
      if (rule === root.first) {
        return
      }

      checkRuleEmptyLineBefore({ rule, expectation, options, result, messages, checkedRuleName: ruleName })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-brackets-space-inside" id="apidoc.element.stylelint.rules.selector-attribute-brackets-space-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-brackets-space-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-brackets-space-inside = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf("[") === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&gt; {
        selectorTree.walkAttributes(attributeNode =&gt; {
          const attributeSelectorString = attributeNode.toString()

          styleSearch({ source: attributeSelectorString, target: "[" }, match =&gt; {
            const nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === " "
            const index = attributeNode.sourceIndex + match.startIndex + 1
            if (nextCharIsSpace &amp;&amp; expectation === "never") {
              complain(messages.rejectedOpening, index)
            }
            if (!nextCharIsSpace &amp;&amp; expectation === "always") {
              complain(messages.expectedOpening, index)
            }
          })

          styleSearch({ source: attributeSelectorString, target: "]" }, match =&gt; {
            const prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === " "
            const index = attributeNode.sourceIndex + match.startIndex - 1
            if (prevCharIsSpace &amp;&amp; expectation === "never") {
              complain(messages.rejectedClosing, index)
            }
            if (!prevCharIsSpace &amp;&amp; expectation === "always") {
              complain(messages.expectedClosing, index)
            }
          })
        })
      })

      function complain(message, index) {
        report({
          message,
          index,
          result,
          ruleName,
          node: rule,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-operator-blacklist" id="apidoc.element.stylelint.rules.selector-attribute-operator-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-blacklist
        <span class="apidocSignatureSpan">(blacklistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-operator-blacklist = function (blacklistInput) {
  const blacklist = [].concat(blacklistInput)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf("[") === -1 || rule.selector.indexOf("=") === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&gt; {
        selectorTree.walkAttributes(attributeNode =&gt; {
          const operator = attributeNode.operator

          if (!operator || operator &amp;&amp; blacklist.indexOf(operator) === -1) {
            return
          }

          report({
            message: messages.rejected(operator),
            node: rule,
            index: attributeNode.attribute.length + 1,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-operator-space-after" id="apidoc.element.stylelint.rules.selector-attribute-operator-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-operator-space-after = function (expectation) {
  return (root, result) =&gt; {
    const checker = whitespaceChecker("space", expectation, messages)
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    selectorAttributeOperatorSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
      checkBeforeOperator: false,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-operator-space-before" id="apidoc.element.stylelint.rules.selector-attribute-operator-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-operator-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    selectorAttributeOperatorSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
      checkBeforeOperator: true,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-operator-whitelist" id="apidoc.element.stylelint.rules.selector-attribute-operator-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-whitelist
        <span class="apidocSignatureSpan">(whitelistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-operator-whitelist = function (whitelistInput) {
  const whitelist = [].concat(whitelistInput)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf("[") === -1 || rule.selector.indexOf("=") === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&gt; {
        selectorTree.walkAttributes(attributeNode =&gt; {
          const operator = attributeNode.operator

          if (!operator || operator &amp;&amp; whitelist.indexOf(operator) !== -1) {
            return
          }

          report({
            message: messages.rejected(operator),
            node: rule,
            index: attributeNode.attribute.length + 1,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-quotes" id="apidoc.element.stylelint.rules.selector-attribute-quotes">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-quotes
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-quotes = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf("[") === -1 || rule.selector.indexOf("=") === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&gt; {
        selectorTree.walkAttributes(attributeNode =&gt; {
          if (!attributeNode.operator) {
            return
          }

          const attributeSelectorString = attributeNode.toString()

          if (!attributeNode.quoted &amp;&amp; expectation === "always") {
            complain(messages.expected(attributeNode.raws.unquoted), attributeNode.sourceIndex + attributeSelectorString.indexOf
(attributeNode.value))
          }

          if (attributeNode.quoted &amp;&amp; expectation === "never") {
            complain(messages.rejected(attributeNode.raws.unquoted), attributeNode.sourceIndex + attributeSelectorString.indexOf
(attributeNode.value))
          }
        })
      })

      function complain(message, index) {
        report({
          message,
          index,
          result,
          ruleName,
          node: rule,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-class-pattern" id="apidoc.element.stylelint.rules.selector-class-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-class-pattern
        <span class="apidocSignatureSpan">(pattern, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-class-pattern = function (pattern, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    }, {
      actual: options,
      possible: {
        resolveNestedSelectors: _.isBoolean,
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const shouldResolveNestedSelectors = _.get(options, "resolveNestedSelectors")
    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkRules(rule =&gt; {
      const selector = rule.selector,
        selectors = rule.selectors

      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selectors.some(s =&gt; isKeyframeSelector(s))) {
        return
      }

      // Only bother resolving selectors that have an interpolating &amp;
      if (shouldResolveNestedSelectors &amp;&amp; hasInterpolatingAmpersand(selector)) {
        resolveNestedSelector(selector, rule).forEach(selector =&gt; {
          if (!isStandardSyntaxSelector(selector)) {
            return
          }

          parseSelector(selector, result, rule, s =&gt; checkSelector(s, rule))
        })
      } else {
        parseSelector(selector, result, rule, s =&gt; checkSelector(s, rule))
      }
    })

    function checkSelector(fullSelector, rule) {
      fullSelector.walkClasses(classNode =&gt; {
        const value = classNode.value,
          sourceIndex = classNode.sourceIndex

        if (normalizedPattern.test(value)) {
          return
        }
        report({
          result,
          ruleName,
          message: messages.expected(value),
          node: rule,
          index: sourceIndex,
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-combinator-space-after" id="apidoc.element.stylelint.rules.selector-combinator-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-combinator-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-combinator-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    selectorCombinatorSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-combinator-space-before" id="apidoc.element.stylelint.rules.selector-combinator-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-combinator-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-combinator-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    selectorCombinatorSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-descendant-combinator-no-non-space" id="apidoc.element.stylelint.rules.selector-descendant-combinator-no-non-space">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-descendant-combinator-no-non-space
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-descendant-combinator-no-non-space = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      const selector = rule.selector

      parseSelector(selector, result, rule, fullSelector =&gt; {
        fullSelector.walkCombinators(combinatorNode =&gt; {
          const value = combinatorNode.value

          if (punctuationSets.nonSpaceCombinators.has(value)) {
            return
          }
          if (value === " ") {
            return
          }

          report({
            result,
            ruleName,
            message: messages.rejected(value),
            node: rule,
            index: combinatorNode.sourceIndex,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-id-pattern" id="apidoc.element.stylelint.rules.selector-id-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-id-pattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-id-pattern = function (pattern) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    })
    if (!validOptions) {
      return
    }

    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }

      parseSelector(selector, result, rule, fullSelector =&gt; {
        fullSelector.walk(selectorNode =&gt; {
          if (selectorNode.type !== "id") {
            return
          }
          const value = selectorNode.value,
            sourceIndex = selectorNode.sourceIndex

          if (normalizedPattern.test(value)) {
            return
          }

          report({
            result,
            ruleName,
            message: messages.expected(value),
            node: rule,
            index: sourceIndex,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-list-comma-newline-after" id="apidoc.element.stylelint.rules.selector-list-comma-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-list-comma-newline-after = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      // Get raw selector so we can allow end-of-line comments, e.g.
      // a,<span class="apidocCodeCommentSpan"> /* comment */
</span>      // b {}
      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector
      styleSearch({
        source: selector,
        target: ",",
        functionArguments: "skip",
      }, match =&gt; {
        const nextThreeChars = selector.substr(match.endIndex, 3)

        // If there's a // comment, that means there has to be a newline
        // ending the comment so we're fine
        if (nextThreeChars === " //") {
          return
        }

        // If there is a space and then a comment begins, look for the newline
        // after that comment
        const indextoCheckAfter = nextThreeChars === " /*" ? selector.indexOf("*/", match.endIndex) + 1 : match.startIndex
        checker.afterOneOnly({
          source: selector,
          index: indextoCheckAfter,
          err: m =&gt; report({
            message: m,
            node: rule,
            index: match.startIndex,
            result,
            ruleName,
          }),
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-list-comma-newline-before" id="apidoc.element.stylelint.rules.selector-list-comma-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-list-comma-newline-before = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    selectorListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.beforeAllowingIndentation,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-list-comma-space-after" id="apidoc.element.stylelint.rules.selector-list-comma-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-list-comma-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    selectorListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-list-comma-space-before" id="apidoc.element.stylelint.rules.selector-list-comma-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-list-comma-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    selectorListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-max-compound-selectors" id="apidoc.element.stylelint.rules.selector-max-compound-selectors">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-compound-selectors
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-max-compound-selectors = function (max) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: [
        function (max) {
          return typeof max === "number" &amp;&amp; max &gt; 0
        },
      ],
    })
    if (!validOptions) {
      return
    }

    // Finds actual selectors in selectorNode object and checks them
    function checkSelector(selectorNode, rule) {
      let compoundCount = 1

      selectorNode.each(childNode =&gt; {
        // Only traverse inside actual selectors and :not()
        if (childNode.type === "selector" || childNode.value === ":not") {
          checkSelector(childNode, rule)
        }

        // Compound selectors are separated by combinators, so increase count when meeting one
        if (childNode.type === "combinator") {
          compoundCount++
        }
      })

      if (selectorNode.type !== "root" &amp;&amp; selectorNode.type !== "pseudo" &amp;&amp; compoundCount &gt; max) {
        report({
          ruleName,
          result,
          node: rule,
          message: messages.expected(selectorNode, max),
          word: selectorNode,
        })
      }
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(rule.selector)) {
        return
      }

      // Nested selectors are processed in steps, as nesting levels are resolved.
      // Here we skip processing the intermediate parts of selectors (to process only fully resolved selectors)
      if (rule.nodes.some(node =&gt; node.type === "rule" || node.type === "atrule")) {
        return
      }

      // Using `rule.selectors` gets us each selector if there is a comma separated set
      rule.selectors.forEach(selector =&gt; {
        resolvedNestedSelector(selector, rule).forEach(resolvedSelector =&gt; {
          // Process each resolved selector with `checkSelector` via postcss-selector-parser
          selectorParser(s =&gt; checkSelector(s, rule)).process(resolvedSelector)
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-max-empty-lines" id="apidoc.element.stylelint.rules.selector-max-empty-lines">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-empty-lines
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-max-empty-lines = function (max) {
  const maxAdjacentNewlines = max + 1

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: _.isNumber,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector
      const repeatLFNewLines = _.repeat("\n", maxAdjacentNewlines)
      const repeatCRLFNewLines = _.repeat("\r\n", maxAdjacentNewlines)

      styleSearch({ source: selector, target: "\n" }, match =&gt; {
        if (selector.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || selector.substr(match.startIndex +
1, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {
          // Put index at `\r` if it's CRLF, otherwise leave it at `\n`
          let index = match.startIndex
          if (selector[index - 1] === "\r") {
            index -= 1
          }

          report({
            message: messages.expected(max),
            node: rule,
            index,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-max-specificity" id="apidoc.element.stylelint.rules.selector-max-specificity">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-specificity
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-max-specificity = function (max) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: [
        function (max) {
        // Check that the max specificity is in the form "a,b,c"
          const pattern = new RegExp("^\\d+,\\d+,\\d+$")
          return pattern.test(max)
        },
      ],
    })
    if (!validOptions) {
      return
    }

    const maxSpecificityArray = ("0," + max).split(",").map(parseFloat)
    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(rule.selector)) {
        return
      }
      // Using rule.selectors gets us each selector in the eventuality we have a comma separated set
      rule.selectors.forEach(selector =&gt; {
        resolvedNestedSelector(selector, rule).forEach(resolvedSelector =&gt; {
          // Return early if selector contains a not pseudo-class
          if (selector.indexOf(":not(") !== -1) {
            return
          }
          // Return early if selector contains a matches
          if (selector.indexOf(":matches(") !== -1) {
            return
          }
          // Check if the selector specificity exceeds the allowed maximum
          try {
            if (specificity.compare(resolvedSelector, maxSpecificityArray) === 1) {
              report({
                ruleName,
                result,
                node: rule,
                message: messages.expected(resolvedSelector, max),
                word: selector,
              })
            }
          } catch (e) {
            result.warn("Cannot parse selector", { node: rule })
          }
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-nested-pattern" id="apidoc.element.stylelint.rules.selector-nested-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-nested-pattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-nested-pattern = function (pattern) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    })
    if (!validOptions) {
      return
    }

    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkRules(rule =&gt; {
      if (rule.parent.type !== "rule") {
        return
      }
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }

      if (normalizedPattern.test(selector)) {
        return
      }

      report({
        result,
        ruleName,
        message: messages.expected(selector),
        node: rule,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-attribute" id="apidoc.element.stylelint.rules.selector-no-attribute">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-attribute
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-attribute = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorAST =&gt; {
        selectorAST.walkAttributes(attribute =&gt; {
          report({
            message: messages.rejected,
            node: rule,
            index: attribute.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-combinator" id="apidoc.element.stylelint.rules.selector-no-combinator">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-combinator
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-combinator = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorAST =&gt; {
        selectorAST.walkCombinators(combinator =&gt; {
          report({
            message: messages.rejected,
            node: rule,
            index: combinator.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-empty" id="apidoc.element.stylelint.rules.selector-no-empty">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-empty
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-empty = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      "'selector-no-empty' has been deprecated and in 8.0 will be removed."
    ), {
      stylelintType: "deprecation",
      stylelintReference: "https://stylelint.io/user-guide/rules/selector-no-empty/",
    })

    root.walkRules(rule =&gt; {
      let index = 0

      rule.selector.split(",").forEach(item =&gt; {
        index += item.length + 1

        if (item.trim() !== "") {
          return
        }

        report({
          message: messages.rejected,
          node: rule,
          index: index - 1,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-id" id="apidoc.element.stylelint.rules.selector-no-id">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-id
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-id = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (isKeyframeRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorAST =&gt; {
        selectorAST.walkIds(idNode =&gt; {
          if (idNode.parent.parent.type === "pseudo") {
            return
          }

          report({
            message: messages.rejected,
            node: rule,
            index: idNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-qualifying-type" id="apidoc.element.stylelint.rules.selector-no-qualifying-type">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-qualifying-type
        <span class="apidocSignatureSpan">(enabled, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-qualifying-type = function (enabled, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: enabled,
      possible: [
        true,
        false,
      ],
    }, {
      actual: options,
      possible: {
        ignore: [
          "attribute",
          "class",
          "id",
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (isKeyframeRule(rule)) {
        return
      }
      // Increasing performance
      if (!isStandardSyntaxSelector(rule.selector)) {
        return
      }
      if (!isSelectorCharacters(rule.selector)) {
        return
      }

      function checkSelector(selectorAST) {
        selectorAST.walkTags(selector =&gt; {
          const selectorParent = selector.parent

          if (selectorParent.nodes.length === 1) {
            return
          }

          const selectorNodes = getRightNodes(selector)
          const index = selector.sourceIndex

          selectorNodes.forEach(selectorNode =&gt; {
            if (selectorNode.type === "id" &amp;&amp; !optionsMatches(options, "ignore", "id")) {
              complain(index)
            }

            if (selectorNode.type === "class" &amp;&amp; !optionsMatches(options, "ignore", "class")) {
              complain(index)
            }

            if (selectorNode.type === "attribute" &amp;&amp; !optionsMatches(options, "ignore", "attribute")) {
              complain(index)
            }
          })
        })
      }

      resolvedNestedSelector(rule.selector, rule).forEach(resolvedSelector =&gt; {
        if (!isStandardSyntaxSelector(resolvedSelector)) {
          return
        }

        parseSelector(resolvedSelector, result, rule, checkSelector)
      })

      function complain(index) {
        report({
          ruleName,
          result,
          node: rule,
          message: messages.rejected,
          index,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-type" id="apidoc.element.stylelint.rules.selector-no-type">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-type
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-type = function (on, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      actual: options,
      possible: {
        ignore: [
          "descendant",
          "compounded",
        ],
        ignoreTypes: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const ignoreDescendant = optionsMatches(options, "ignore", "descendant")
    const ignoreCompounded = optionsMatches(options, "ignore", "compounded")

    root.walkRules(rule =&gt; {
      const selector = rule.selector,
        selectors = rule.selectors

      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selectors.some(s =&gt; isKeyframeSelector(s))) {
        return
      }

      if (ignoreDescendant) {
        // Resolve each selector within the list before checking
        selectors.forEach(selector =&gt; {
          resolveNestedSelector(selector, rule).forEach(selector =&gt; {
            checkSelector(selector, rule)
          })
        })
      } else {
        checkSelector(selector, rule)
      }
    })

    function checkSelector(selector, rule) {
      parseSelector(selector, result, rule, selectorAST =&gt; {
        selectorAST.walkTags(tag =&gt; {
          if (!isStandardSyntaxTypeSelector(tag)) {
            return
          }

          if (optionsMatches(options, "ignoreTypes", tag.value)) {
            return
          }

          if (ignoreDescendant &amp;&amp; hasCombinatorBefore(tag)) {
            return
          }

          if (ignoreCompounded &amp;&amp; isCompounded(tag)) {
            return
          }

          report({
            message: messages.rejected,
            node: rule,
            index: tag.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-universal" id="apidoc.element.stylelint.rules.selector-no-universal">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-universal
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-universal = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorAST =&gt; {
        selectorAST.walkUniversals(universal =&gt; {
          report({
            message: messages.rejected,
            node: rule,
            index: universal.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-vendor-prefix" id="apidoc.element.stylelint.rules.selector-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-vendor-prefix = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorTree =&gt; {
        selectorTree.walkPseudos(pseudoNode =&gt; {
          if (isAutoprefixable.selector(pseudoNode.value)) {
            report({
              result,
              ruleName,
              message: messages.rejected(pseudoNode.value),
              node: rule,
              index: (rule.raws.before || "").length + pseudoNode.sourceIndex,
            })
          }
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-blacklist" id="apidoc.element.stylelint.rules.selector-pseudo-class-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-blacklist = function (blacklist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selector.indexOf(":") === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&gt; {
        selectorTree.walkPseudos(pseudoNode =&gt; {
          const value = pseudoNode.value

          // Ignore pseudo-elements

          if (value.slice(0, 2) === "::") {
            return
          }

          const name = value.slice(1)

          if (!matchesStringOrRegExp(postcss.vendor.unprefixed(name).toLowerCase(), blacklist)) {
            return
          }

          report({
            index: pseudoNode.sourceIndex,
            message: messages.rejected(name),
            node: rule,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-case" id="apidoc.element.stylelint.rules.selector-pseudo-class-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-case = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector
      const startIndexPseudo = selector.indexOf(":")

      if (startIndexPseudo === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&gt; {
        selectorTree.walkPseudos(pseudoNode =&gt; {
          const pseudo = pseudoNode.value

          if (!isStandardSyntaxSelector(pseudo)) {
            return
          }

          if (pseudo.indexOf("::") !== -1 || keywordSets.levelOneAndTwoPseudoElements.has(pseudo.toLowerCase().slice(1))) {
            return
          }

          const expectedPseudo = expectation === "lower" ? pseudo.toLowerCase() : pseudo.toUpperCase()

          if (pseudo === expectedPseudo) {
            return
          }

          report({
            message: messages.expected(pseudo, expectedPseudo),
            node: rule,
            index: pseudoNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-no-unknown" id="apidoc.element.stylelint.rules.selector-pseudo-class-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-no-unknown = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignorePseudoClasses: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      // Return early before parse if no pseudos for performance

      if (selector.indexOf(":") === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&gt; {
        selectorTree.walkPseudos(pseudoNode =&gt; {
          const value = pseudoNode.value

          if (!isStandardSyntaxSelector(value)) {
            return
          }

          if (isCustomSelector(value)) {
            return
          }

          // Ignore pseudo-elements
          if (value.slice(0, 2) === "::") {
            return
          }

          if (optionsMatches(options, "ignorePseudoClasses", pseudoNode.value.slice(1))) {
            return
          }

          const name = value.slice(1)

          if (postcss.vendor.prefix(name)
            || keywordSets.pseudoClasses.has(name.toLowerCase())
            || keywordSets.pseudoElements.has(name.toLowerCase())
          ) {
            return
          }

          if (pseudoNode.prev()) {
            const prevPseudoNodeValue = postcss.vendor.unprefixed(pseudoNode.prev().value.toLowerCase().slice(2))

            if (keywordSets.webkitProprietaryPseudoElements.has(prevPseudoNodeValue)
              &amp;&amp; keywordSets.webkitProprietaryPseudoClasses.has(name.toLowerCase())
            ) {
              return
            }
          }

          report({
            message: messages.rejected(value),
            node: rule,
            index: pseudoNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-parentheses-space-inside" id="apidoc.element.stylelint.rules.selector-pseudo-class-parentheses-space-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-parentheses-space-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-parentheses-space-inside = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf("(") === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&gt; {
        selectorTree.walkPseudos(pseudoNode =&gt; {
          if (_.get(pseudoNode, "parent.parent.type") === "pseudo") {
            return
          }

          const pseudoSelectorString = pseudoNode.toString()

          styleSearch({ source: pseudoSelectorString, target: "(" }, match =&gt; {
            const nextCharIsSpace = pseudoSelectorString[match.startIndex + 1] === " "
            const index = pseudoNode.sourceIndex + match.startIndex + 1
            if (nextCharIsSpace &amp;&amp; expectation === "never") {
              complain(messages.rejectedOpening, index)
            }
            if (!nextCharIsSpace &amp;&amp; expectation === "always") {
              complain(messages.expectedOpening, index)
            }
          })

          styleSearch({ source: pseudoSelectorString, target: ")" }, match =&gt; {
            const prevCharIsSpace = pseudoSelectorString[match.startIndex - 1] === " "
            const index = pseudoNode.sourceIndex + match.startIndex - 1
            if (prevCharIsSpace &amp;&amp; expectation === "never") {
              complain(messages.rejectedClosing, index)
            }
            if (!prevCharIsSpace &amp;&amp; expectation === "always") {
              complain(messages.expectedClosing, index)
            }
          })
        })
      })

      function complain(message, index) {
        report({
          message,
          index,
          result,
          ruleName,
          node: rule,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-whitelist" id="apidoc.element.stylelint.rules.selector-pseudo-class-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-whitelist = function (whitelist) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selector.indexOf(":") === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&gt; {
        selectorTree.walkPseudos(pseudoNode =&gt; {
          const value = pseudoNode.value

          // Ignore pseudo-elements

          if (value.slice(0, 2) === "::") {
            return
          }

          const name = value.slice(1)

          if (matchesStringOrRegExp(postcss.vendor.unprefixed(name).toLowerCase(), whitelist)) {
            return
          }

          report({
            index: pseudoNode.sourceIndex,
            message: messages.rejected(name),
            node: rule,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-element-case" id="apidoc.element.stylelint.rules.selector-pseudo-element-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-element-case = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector
      const startIndexPseudoElement = selector.indexOf(":")

      if (startIndexPseudoElement === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&gt; {
        selectorTree.walkPseudos(pseudoNode =&gt; {
          const pseudoElement = pseudoNode.value

          if (!isStandardSyntaxSelector(pseudoElement)) {
            return
          }

          if (pseudoElement.indexOf("::") === -1 &amp;&amp; !keywordSets.levelOneAndTwoPseudoElements.has(pseudoElement.toLowerCase().slice
(1))) {
            return
          }

          const expectedPseudoElement = expectation === "lower" ? pseudoElement.toLowerCase() : pseudoElement.toUpperCase()

          if (pseudoElement === expectedPseudoElement) {
            return
          }

          report({
            message: messages.expected(pseudoElement, expectedPseudoElement),
            node: rule,
            index: pseudoNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-element-colon-notation" id="apidoc.element.stylelint.rules.selector-pseudo-element-colon-notation">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-colon-notation
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-element-colon-notation = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "single",
        "double",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      // get out early if no pseudo elements or classes
      if (selector.indexOf(":") === -1) {
        return
      }

      // match only level 1 and 2 pseudo elements
      const pseudoElementsWithColons = _.toArray(keywordSets.levelOneAndTwoPseudoElements).map(x =&gt; `:${x}`)
      styleSearch({ source: selector.toLowerCase(), target: pseudoElementsWithColons }, match =&gt; {
        const prevCharIsColon = selector[match.startIndex - 1] === ":"

        if (expectation === "single" &amp;&amp; !prevCharIsColon) {
          return
        }
        if (expectation === "double" &amp;&amp; prevCharIsColon) {
          return
        }

        report({
          message: messages.expected(expectation),
          node: rule,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-element-no-unknown" id="apidoc.element.stylelint.rules.selector-pseudo-element-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-element-no-unknown = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignorePseudoElements: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      // Return early before parse if no pseudos for performance

      if (selector.indexOf(":") === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&gt; {
        selectorTree.walkPseudos(pseudoNode =&gt; {
          const value = pseudoNode.value

          if (!isStandardSyntaxSelector(value)) {
            return
          }

          // Ignore pseudo-classes
          if (value.slice(0, 2) !== "::") {
            return
          }

          if (optionsMatches(options, "ignorePseudoElements", pseudoNode.value.slice(2))) {
            return
          }

          const name = value.slice(2)

          if (postcss.vendor.prefix(name) || keywordSets.pseudoElements.has(name.toLowerCase())) {
            return
          }

          report({
            message: messages.rejected(value),
            node: rule,
            index: pseudoNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-root-no-composition" id="apidoc.element.stylelint.rules.selector-root-no-composition">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-root-no-composition
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-root-no-composition = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use the community 'stylelint-suitcss' plugin pack.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&gt; {
      if (rule.selector.toLowerCase().indexOf(":root") === -1 || rule.selector.toLowerCase().trim() === ":root") {
        return
      }

      report({
        message: messages.rejected,
        node: rule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-type-case" id="apidoc.element.stylelint.rules.selector-type-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-type-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-type-case = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      const selector = rule.selector,
        selectors = rule.selectors

      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selectors.some(s =&gt; isKeyframeSelector(s))) {
        return
      }

      parseSelector(selector, result, rule, selectorAST =&gt; {
        selectorAST.walkTags(tag =&gt; {
          if (!isStandardSyntaxTypeSelector(tag)) {
            return
          }

          const sourceIndex = tag.sourceIndex,
            value = tag.value

          const expectedValue = expectation === "lower" ? value.toLowerCase() : value.toUpperCase()

          if (value === expectedValue) {
            return
          }

          report({
            message: messages.expected(value, expectedValue),
            node: rule,
            index: sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-type-no-unknown" id="apidoc.element.stylelint.rules.selector-type-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-type-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-type-no-unknown = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignore: [
          "default-namespace",
        ],
        ignoreNamespaces: [_.isString],
        ignoreTypes: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&gt; {
      const selector = rule.selector,
        selectors = rule.selectors

      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selectors.some(s =&gt; isKeyframeSelector(s))) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&gt; {
        selectorTree.walkTags(tagNode =&gt; {
          if (!isStandardSyntaxTypeSelector(tagNode)) {
            return
          }

          if (
            optionsMatches(options, "ignore", "default-namespace")
            &amp;&amp; !tagNode.hasOwnProperty("namespace")
          ) {
            return
          }

          if (optionsMatches(options, "ignoreNamespaces", tagNode.namespace)) {
            return
          }

          if (optionsMatches(options, "ignoreTypes", tagNode.value)) {
            return
          }

          const tagName = tagNode.value
          const tagNameLowerCase = tagName.toLowerCase()

          if (htmlTags.indexOf(tagNameLowerCase) !== -1 || svgTags.indexOf(tagNameLowerCase) !== -1 || nonStandardHtmlTags.has(tagNameLowerCase
)) {
            return
          }

          report({
            message: messages.rejected(tagName),
            node: rule,
            index: tagNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.shorthand-property-no-redundant-values" id="apidoc.element.stylelint.rules.shorthand-property-no-redundant-values">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>shorthand-property-no-redundant-values
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shorthand-property-no-redundant-values = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
        return
      }

      const prop = decl.prop,
        value = decl.value

      const normalizedProp = postcss.vendor.unprefixed(prop.toLowerCase())

      // Ignore not shorthandable properties, and math operations
      if (isIgnoredCharacters(value) || !shorthandableProperties.has(normalizedProp) || ignoredShorthandProperties.has(normalizedProp
)) {
        return
      }

      const valuesToShorthand = []

      valueParser(value).walk(valueNode =&gt; {
        if (valueNode.type !== "word") {
          return
        }

        valuesToShorthand.push(valueParser.stringify(valueNode))
      })

      if (valuesToShorthand.length &lt;= 1 || valuesToShorthand.length &gt; 4) {
        return
      }

      const shortestForm = canCondense.apply(undefined, valuesToShorthand)
      const shortestFormString = shortestForm.filter(value =&gt; {
        return value
      }).join(" ")
      const valuesFormString = valuesToShorthand.join(" ")

      if (shortestFormString.toLowerCase() === valuesFormString.toLowerCase()) {
        return
      }

      report({
        message: messages.rejected(value, shortestFormString),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.string-no-newline" id="apidoc.element.stylelint.rules.string-no-newline">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>string-no-newline
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string-no-newline = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const cssString = root.toString()
    styleSearch({
      source: cssString,
      target: "\n",
      strings: "only",
    }, match =&gt; {
      const charBefore = cssString[match.startIndex - 1]
      let index = match.startIndex
      if (charBefore === "\\") {
        return
      }
      if (charBefore === "\r") index -= 1
      report({
        message: messages.rejected,
        node: root,
        index,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.string-quotes" id="apidoc.element.stylelint.rules.string-quotes">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>string-quotes
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string-quotes = function (expectation) {
  const erroneousQuote = expectation === "single" ? "\"" : "'"

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "single",
        "double",
      ],
    })
    if (!validOptions) {
      return
    }

    const cssString = root.toString()
    styleSearch({ source: cssString, target: erroneousQuote }, match =&gt; {
      report({
        message: messages.expected(expectation),
        node: root,
        index: match.startIndex,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.stylelint-disable-reason" id="apidoc.element.stylelint.rules.stylelint-disable-reason">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>stylelint-disable-reason
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stylelint-disable-reason = function (expectation) {
  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always-before",
        "always-after",
      ],
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkComments(function (comment) {
      if (comment.text.indexOf(stylelintDisableCommand) !== 0) {
        return
      }

      if (expectation === "always-before") {
        const prev = comment.prev()
        const prevIsCommentAndValid = prev &amp;&amp; prev.type === "comment" &amp;&amp; !isDisableCommand(prev.text)

        let prevDisableLineIsCommentAndValid = false

        if (comment.text.indexOf(stylelintDisableLineCommand) === 0 &amp;&amp; !prevIsCommentAndValid &amp;&amp; prev) {
          const friendlyPrev = prev.prev()

          prevDisableLineIsCommentAndValid = friendlyPrev &amp;&amp; friendlyPrev.type === "comment" &amp;&amp; !isDisableCommand(friendlyPrev.text
)
        }

        if (!prevIsCommentAndValid &amp;&amp; !prevDisableLineIsCommentAndValid) {
          const disabledRanges = result.stylelint.disabledRanges
          result.stylelint.disabledRanges = false

          report({
            message: messages.expectedBefore,
            node: comment,
            result,
            ruleName,
          })
          result.stylelint.disabledRanges = disabledRanges
        }
      } else if (expectation === "always-after") {
        const next = comment.next()
        const nextIsCommentAndValid = next &amp;&amp; next.type === "comment" &amp;&amp; !isDisableCommand(next.text)

        if (!nextIsCommentAndValid) {
          const disabledRanges = result.stylelint.disabledRanges
          result.stylelint.disabledRanges = false

          report({
            message: messages.expectedAfter,
            node: comment,
            result,
            ruleName,
          })
          result.stylelint.disabledRanges = disabledRanges
        }
      }
    })

    function isDisableCommand(text) {
      return text.indexOf(stylelintDisableCommand) === 0
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.time-min-milliseconds" id="apidoc.element.stylelint.rules.time-min-milliseconds">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>time-min-milliseconds
        <span class="apidocSignatureSpan">(minimum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time-min-milliseconds = function (minimum) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: minimum,
      possible: _.isNumber,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const propertyName = postcss.vendor.unprefixed(decl.prop.toLowerCase())

      if (
        keywordSets.longhandTimeProperties.has(propertyName)
        &amp;&amp; !isAcceptableTime(decl.value)
      ) {
        complain(decl)
      }

      if (keywordSets.shorthandTimeProperties.has(propertyName)) {
        const valueList = postcss.list.space(decl.value)

        for (const value of valueList) {
          if (!isAcceptableTime(value)) {
            complain(decl, decl.value.indexOf(value))
          }
        }
      }
    })

    function isAcceptableTime(time) {
      const parsedTime = valueParser.unit(time)

      if (!parsedTime) return true

      if (parsedTime.number &lt;= 0) {
        return true
      }

      if (parsedTime.unit.toLowerCase() === "ms" &amp;&amp; parsedTime.number &lt; minimum) {
        return false
      }

      if (parsedTime.unit.toLowerCase() === "s" &amp;&amp; parsedTime.number * 1000 &lt; minimum) {
        return false
      }

      return true
    }

    function complain(decl, offset) {
      offset = offset || 0

      report({
        result,
        ruleName,
        message: messages.expected(minimum),
        index: declarationValueIndex(decl) + offset,
        node: decl,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.time-no-imperceptible" id="apidoc.element.stylelint.rules.time-no-imperceptible">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>time-no-imperceptible
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time-no-imperceptible = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use 'time-min-milliseconds' with '100' as its primary
 option.`
    ), {
      stylelintType: "deprecation",
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkDecls(decl =&gt; {
      if (keywordSets.longhandTimeProperties.has(postcss.vendor.unprefixed(decl.prop.toLowerCase()))) {
        if (isImperceptibleTime(decl.value)) {
          complain(messages.rejected(decl.value), decl)
        }
      }

      if (keywordSets.shorthandTimeProperties.has(postcss.vendor.unprefixed(decl.prop.toLowerCase()))) {
        const valueList = postcss.list.space(decl.value)
        for (const value of valueList) {
          if (isImperceptibleTime(value)) {
            complain(messages.rejected(value), decl, decl.value.indexOf(value))
          }
        }
      }
    })

    function isImperceptibleTime(time) {
      const parsedTime = valueParser.unit(time)
      if (!parsedTime) return false
      const absoluteTime = Math.abs(parsedTime.number)
      if (parsedTime.unit.toLowerCase() === "ms" &amp;&amp; absoluteTime &lt;= MINIMUM_MILLISECONDS) {
        return true
      }
      if (parsedTime.unit.toLowerCase() === "s" &amp;&amp; absoluteTime * 1000 &lt;= MINIMUM_MILLISECONDS) {
        return true
      }
      return false
    }

    function complain(message, decl) {
      const offset = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : 0

      report({
        result,
        ruleName,
        message,
        index: declarationValueIndex(decl) + offset,
        node: decl,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.unit-blacklist" id="apidoc.element.stylelint.rules.unit-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-blacklist
        <span class="apidocSignatureSpan">(blacklistInput, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit-blacklist = function (blacklistInput, options) {
  const blacklist = [].concat(blacklistInput)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    }, {
      optional: true,
      actual: options,
      possible: {
        ignoreProperties: validateObjectWithStringArrayProps,
      },
    })
    if (!validOptions) {
      return
    }

    function check(node, value, getIndex) {
      valueParser(value).walk(function (valueNode) {
        // Ignore wrong units within `url` function
        if (valueNode.type === "function" &amp;&amp; valueNode.value.toLowerCase() === "url") {
          return false
        }

        const unit = getUnitFromValueNode(valueNode)

        if (!unit || unit &amp;&amp; blacklist.indexOf(unit.toLowerCase()) === -1) {
          return
        }

        if (options &amp;&amp; optionsMatches(options.ignoreProperties, unit.toLowerCase(), node.prop)) {
          return
        }

        report({
          index: getIndex(node) + valueNode.sourceIndex,
          message: messages.rejected(unit),
          node,
          result,
          ruleName,
        })
      })
    }

    root.walkAtRules(/^media$/i, atRule =&gt; check(atRule, atRule.params, atRuleParamIndex))
    root.walkDecls(decl =&gt; check(decl, decl.value, declarationValueIndex))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.unit-case" id="apidoc.element.stylelint.rules.unit-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit-case = function (expectation) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    })
    if (!validOptions) {
      return
    }

    function check(node, value, getIndex) {
      valueParser(value).walk(valueNode =&gt; {
        // Ignore wrong units within `url` function
        if (valueNode.type === "function" &amp;&amp; valueNode.value.toLowerCase() === "url") {
          return false
        }

        const unit = getUnitFromValueNode(valueNode)

        if (!unit) {
          return
        }

        const expectedUnit = expectation === "lower" ? unit.toLowerCase() : unit.toUpperCase()

        if (unit === expectedUnit) {
          return
        }

        report({
          index: getIndex(node) + valueNode.sourceIndex,
          message: messages.expected(unit, expectedUnit),
          node,
          result,
          ruleName,
        })
      })
    }

    root.walkAtRules(/^media$/i, atRule =&gt; check(atRule, atRule.params, atRuleParamIndex))
    root.walkDecls(decl =&gt; check(decl, decl.value, declarationValueIndex))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.unit-no-unknown" id="apidoc.element.stylelint.rules.unit-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit-no-unknown = function (actual, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreUnits: [_.isString],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    function check(node, value, getIndex) {
      valueParser(value).walk(function (valueNode) {
        // Ignore wrong units within `url` function
        if (valueNode.type === "function" &amp;&amp; valueNode.value.toLowerCase() === "url") {
          return false
        }

        const unit = getUnitFromValueNode(valueNode)
        if (!unit) {
          return
        }

        if (optionsMatches(options, "ignoreUnits", unit)) {
          return
        }

        if (keywordSets.units.has(unit.toLowerCase())) {
          return
        }

        report({
          index: getIndex(node) + valueNode.sourceIndex,
          message: messages.rejected(unit),
          node,
          result,
          ruleName,
        })
      })
    }

    root.walkAtRules(/^media$/i, atRule =&gt; check(atRule, atRule.params, atRuleParamIndex))
    root.walkDecls(decl =&gt; check(decl, decl.value, declarationValueIndex))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.unit-whitelist" id="apidoc.element.stylelint.rules.unit-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-whitelist
        <span class="apidocSignatureSpan">(whitelistInput, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit-whitelist = function (whitelistInput, options) {
  const whitelist = [].concat(whitelistInput)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    }, {
      optional: true,
      actual: options,
      possible: {
        ignoreProperties: validateObjectWithStringArrayProps,
      },
    })
    if (!validOptions) {
      return
    }

    function check(node, value, getIndex) {
      valueParser(value).walk(function (valueNode) {
        // Ignore wrong units within `url` function
        if (valueNode.type === "function" &amp;&amp; valueNode.value.toLowerCase() === "url") {
          return false
        }

        const unit = getUnitFromValueNode(valueNode)

        if (!unit || unit &amp;&amp; whitelist.indexOf(unit.toLowerCase()) !== -1) {
          return
        }

        if (options &amp;&amp; optionsMatches(options["ignoreProperties"], unit.toLowerCase(), node.prop)) {
          return
        }

        report({
          index: getIndex(node) + valueNode.sourceIndex,
          message: messages.rejected(unit),
          node,
          result,
          ruleName,
        })
      })
    }

    root.walkAtRules(/^media$/i, atRule =&gt; check(atRule, atRule.params, atRuleParamIndex))
    root.walkDecls(decl =&gt; check(decl, decl.value, declarationValueIndex))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-keyword-case" id="apidoc.element.stylelint.rules.value-keyword-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-keyword-case
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-keyword-case = function (expectation, options) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "lower",
        "upper",
      ],
    }, {
      actual: options,
      possible: {
        ignoreKeywords: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const prop = decl.prop,
        value = decl.value

      valueParser(value).walk(node =&gt; {
        const valueLowerCase = node.value.toLowerCase()

        // Ignore system colors
        if (keywordSets.systemColors.has(valueLowerCase)) {
          return
        }

        // Ignore keywords within `url` and `var` function
        if (node.type === "function" &amp;&amp; (valueLowerCase === "url" || valueLowerCase === "var" || valueLowerCase === "counter" ||
valueLowerCase === "counters" || valueLowerCase === "attr")) {
          return false
        }

        const keyword = node.value

        // Ignore css variables, and hex values, and math operators, and sass interpolation
        if (node.type !== "word" || !isStandardSyntaxValue(node.value) || value.indexOf("#") !== -1 || ignoredCharacters.has(keyword
) || getUnitFromValueNode(node)) {
          return
        }

        if (prop === "animation" &amp;&amp; !keywordSets.animationShorthandKeywords.has(valueLowerCase) &amp;&amp; !keywordSets.animationNameKeywords
.has(valueLowerCase)) {
          return
        }
        if (prop === "animation-name" &amp;&amp; !keywordSets.animationNameKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === "font" &amp;&amp; !keywordSets.fontShorthandKeywords.has(valueLowerCase) &amp;&amp; !keywordSets.fontFamilyKeywords.has(valueLowerCase
)) {
          return
        }
        if (prop === "font-family" &amp;&amp; !keywordSets.fontFamilyKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === "counter-increment" &amp;&amp; isCounterIncrementCustomIdentValue(valueLowerCase)) {
          return
        }
        if (prop === "counter-reset" &amp;&amp; isCounterResetCustomIdentValue(valueLowerCase)) {
          return
        }
        if (prop === "grid-row" &amp;&amp; !keywordSets.gridRowKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === "grid-column" &amp;&amp; !keywordSets.gridColumnKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === "grid-area" &amp;&amp; !keywordSets.gridAreaKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === "list-style" &amp;&amp; !keywordSets.listStyleShorthandKeywords.has(valueLowerCase) &amp;&amp; !keywordSets.listStyleTypeKeywords
.has(valueLowerCase)) {
          return
        }
        if (prop === "list-style-type" &amp;&amp; !keywordSets.listStyleTypeKeywords.has(valueLowerCase)) {
          return
        }

        const ignoreKeywords = options &amp;&amp; options.ignoreKeywords || []

        if (ignoreKeywords.length &gt; 0 &amp;&amp; matchesStringOrRegExp(keyword, ignoreKeywords)) {
          return
        }

        const keywordLowerCase = keyword.toLocaleLowerCase()
        let expectedKeyword = null

        if (expectation === "lower" &amp;&amp; mapLowercaseKeywordsToCamelCase.has(keywordLowerCase)) {
          expectedKeyword = mapLowercaseKeywordsToCamelCase.get(keywordLowerCase)
        } else if (expectation === "lower") {
          expectedKeyword = keyword.toLowerCase()
        } else {
          expectedKeyword = keyword.toUpperCase()
        }

        if (keyword === expectedKeyword) {
          return
        }

        report({
          message: messages.expected(keyword, expectedKeyword),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-comma-newline-after" id="apidoc.element.stylelint.rules.value-list-comma-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-comma-newline-after = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    valueListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.afterOneOnly,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-comma-newline-before" id="apidoc.element.stylelint.rules.value-list-comma-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-comma-newline-before = function (expectation) {
  const checker = whitespaceChecker("newline", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "always-multi-line",
        "never-multi-line",
      ],
    })
    if (!validOptions) {
      return
    }

    valueListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.beforeAllowingIndentation,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-comma-space-after" id="apidoc.element.stylelint.rules.value-list-comma-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-comma-space-after = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    valueListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-comma-space-before" id="apidoc.element.stylelint.rules.value-list-comma-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-comma-space-before = function (expectation) {
  const checker = whitespaceChecker("space", expectation, messages)
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        "always",
        "never",
        "always-single-line",
        "never-single-line",
      ],
    })
    if (!validOptions) {
      return
    }

    valueListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-max-empty-lines" id="apidoc.element.stylelint.rules.value-list-max-empty-lines">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-max-empty-lines
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-max-empty-lines = function (max) {
  const maxAdjacentNewlines = max + 1

  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: _.isNumber,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      const value = decl.value
      const repeatLFNewLines = _.repeat("\n", maxAdjacentNewlines)
      const repeatCRLFNewLines = _.repeat("\r\n", maxAdjacentNewlines)

      styleSearch({ source: value, target: "\n" }, match =&gt; {
        if (value.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || value.substr(match.startIndex + 1, maxAdjacentNewlines
 * 2) === repeatCRLFNewLines) {
          // Put index at `\r` if it's CRLF, otherwise leave it at `\n`
          let index = match.startIndex
          if (value[index - 1] === "\r") {
            index -= 1
          }

          report({
            message: messages.expected(max),
            node: decl,
            index,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-no-vendor-prefix" id="apidoc.element.stylelint.rules.value-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-no-vendor-prefix = function (actual) {
  return (root, result) =&gt; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&gt; {
      if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop) || decl.value[0] !== "-") {
        return
      }

      const prop = decl.prop,
        value = decl.value

      // Search the full declaration in order to get an accurate index

      styleSearch({ source: value.toLowerCase(), target: valuePrefixes }, match =&gt; {
        const fullIdentifier = /^(-[a-z-]+)\b/i.exec(value.slice(match.startIndex))[1]
        if (!isAutoprefixable.propertyValue(prop, fullIdentifier)) {
          return
        }

        report({
          message: messages.rejected(fullIdentifier),
          node: decl,
          index: prop.length + (decl.raws.between || "").length + match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.utils" id="apidoc.module.stylelint.utils">module stylelint.utils</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.utils.checkAgainstRule" id="apidoc.element.stylelint.utils.checkAgainstRule">
        function <span class="apidocSignatureSpan">stylelint.utils.</span>checkAgainstRule
        <span class="apidocSignatureSpan">( options, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAgainstRule = function ( options, callback ) {
  if (!options) throw new Error("checkAgainstRule requires an options object with 'ruleName', 'ruleSettings', and 'root' properties
")
  if (!callback) throw new Error("checkAgainstRule requires a callback")
  if (!options.ruleName) throw new Error("checkAgainstRule requires a 'ruleName' option")
  if (!rules[options.ruleName]) throw new Error(`Rule '${options.ruleName}' does not exist`)
  if (!options.ruleSettings) throw new Error("checkAgainstRule requires a 'ruleSettings' option")
  if (!options.root) throw new Error("checkAgainstRule requires a 'root' option")

  const settings = normalizeRuleSettings(options.ruleSettings, options.ruleName)
  if (!settings) { return }

  const tmpPostcssResult = new Result()
  rules[options.ruleName](settings[0], settings[1])(options.root, tmpPostcssResult)
  tmpPostcssResult.warnings().forEach(callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.utils.report" id="apidoc.element.stylelint.utils.report">
        function <span class="apidocSignatureSpan">stylelint.utils.</span>report
        <span class="apidocSignatureSpan">(violation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function (violation) {
  const ruleName = violation.ruleName
  const result = violation.result
  const message = violation.message
  const line = violation.line
  const node = violation.node
  const index = violation.index
  const word = violation.word

  result.stylelint = result.stylelint || {}

  // In quiet mode, mere warnings are ignored
  if (result.stylelint.quiet &amp;&amp; result.stylelint.ruleSeverities[ruleName] !== "error") {
    return
  }

  // If a line is not passed, use the node.positionBy method to get the
  // line number that the complaint pertains to
  const startLine = line || node.positionBy({ index }).line

  if (result.stylelint.disabledRanges &amp;&amp; !result.stylelint.ignoreDisables) {
    const ranges = result.stylelint.disabledRanges[ruleName] || result.stylelint.disabledRanges.all
    for (const range of ranges) {
      if (
      // If the violation is within a disabledRange,
      // and that disabledRange's rules include this one,
      // do not register a warning
      range.start &lt;= startLine &amp;&amp; (range.end &gt;= startLine || range.end === undefined) &amp;&amp; (!range.rules || range.rules.indexOf(ruleName
) !== -1)) {
        return
      }
    }
  }

  const severity = _.get(result.stylelint, [ "ruleSeverities", ruleName ], "ignore")

  if (!result.stylelint.stylelintError &amp;&amp; severity === "error") {
    result.stylelint.stylelintError = true
  }

  const warningProperties/*: Object*/ = {
    severity,
    rule: ruleName,
  }
  if (node) {
    warningProperties.node = node
  }
  if (index) {
    warningProperties.index = index
  }
  if (word) {
    warningProperties.word = word
  }

  const warningMessage = _.get(result.stylelint, [ "customMessages", ruleName ], message)
  result.warn(warningMessage, warningProperties)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.utils.ruleMessages" id="apidoc.element.stylelint.utils.ruleMessages">
        function <span class="apidocSignatureSpan">stylelint.utils.</span>ruleMessages
        <span class="apidocSignatureSpan">( ruleName, messages )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ruleMessages = function ( ruleName, messages )/*: Object*/ {
  return Object.keys(messages).reduce((newMessages, messageId) =&gt; {
    const messageText = messages[messageId]
    if (typeof messageText === "string") {
      newMessages[messageId] = `${messageText} (${ruleName})`
    } else {
      newMessages[messageId] = function () {
        return `${messageText.apply(null, arguments)} (${ruleName})`
      }
    }
    return newMessages
  }, {})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.utils.validateOptions" id="apidoc.element.stylelint.utils.validateOptions">
        function <span class="apidocSignatureSpan">stylelint.utils.</span>validateOptions
        <span class="apidocSignatureSpan">( result, ruleName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateOptions = function ( result, ruleName )/*: boolean*/ {
  let noErrors = true

  const optionDescriptions = Array.from(arguments).slice(2)

  optionDescriptions.forEach(optionDescription =&gt; {
    validate(optionDescription, ruleName, complain)
  })

  function complain(message) {
    noErrors = false
    result.warn(message, {
      stylelintType: "invalidOption",
    })
    _.set(result, "stylelint.stylelintError", true)
  }

  return noErrors
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>