<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://stylelint.io"

    >stylelint (v7.10.1)</a>
</h1>
<h4>A mighty, modern CSS linter.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint">module stylelint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.createLinter">
            function <span class="apidocSignatureSpan">stylelint.</span>createLinter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.createPlugin">
            function <span class="apidocSignatureSpan">stylelint.</span>createPlugin
            <span class="apidocSignatureSpan">(ruleName, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.createRuleTester">
            function <span class="apidocSignatureSpan">stylelint.</span>createRuleTester
            <span class="apidocSignatureSpan">(equalityCheck)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.lint">
            function <span class="apidocSignatureSpan">stylelint.</span>lint
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.process">
            function <span class="apidocSignatureSpan">stylelint.</span>process
            <span class="apidocSignatureSpan">(root, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.</span>augmentConfig</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.</span>formatters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.</span>rules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">stylelint.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.augmentConfig">module stylelint.augmentConfig</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.augmentConfig.augmentConfigExtended">
            function <span class="apidocSignatureSpan">stylelint.augmentConfig.</span>augmentConfigExtended
            <span class="apidocSignatureSpan">( stylelint, cosmiconfigResultArg )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.augmentConfig.augmentConfigFull">
            function <span class="apidocSignatureSpan">stylelint.augmentConfig.</span>augmentConfigFull
            <span class="apidocSignatureSpan">( stylelint, cosmiconfigResultArg )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.formatters">module stylelint.formatters</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.formatters.json">
            function <span class="apidocSignatureSpan">stylelint.formatters.</span>json
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.formatters.string">
            function <span class="apidocSignatureSpan">stylelint.formatters.</span>string
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.formatters.verbose">
            function <span class="apidocSignatureSpan">stylelint.formatters.</span>verbose
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.rules">module stylelint.rules</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-blacklist
            <span class="apidocSignatureSpan">(blacklistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-name-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-name-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-name-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-semicolon-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-semicolon-newline-after
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-semicolon-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-semicolon-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.at-rule-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-whitelist
            <span class="apidocSignatureSpan">(whitelistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-empty-line-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-newline-after
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-closing-brace-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-no-empty">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-no-empty
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-no-single-line">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-no-single-line
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-opening-brace-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-opening-brace-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-opening-brace-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.block-opening-brace-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-space-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-hex-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-hex-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-hex-length">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-hex-length
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-named">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-named
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-no-hex">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-no-hex
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.color-no-invalid-hex">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>color-no-invalid-hex
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.comment-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.comment-no-empty">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-no-empty
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.comment-whitespace-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-whitespace-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.comment-word-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-word-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.custom-media-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-media-pattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.custom-property-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.custom-property-no-outside-root">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-no-outside-root
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.custom-property-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-pattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-bang-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-bang-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-bang-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-bang-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-no-duplicate-properties">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-duplicate-properties
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-no-ignored-properties">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-ignored-properties
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-no-redundant-longhand-properties">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-redundant-longhand-properties
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-no-shorthand-property-overrides">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-shorthand-property-overrides
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-properties-order">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-properties-order
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-semicolon-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-semicolon-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-semicolon-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-semicolon-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-single-line-max-declarations">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-single-line-max-declarations
            <span class="apidocSignatureSpan">(quantity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-block-trailing-semicolon">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-trailing-semicolon
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-colon-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-colon-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-colon-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-no-important">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-no-important
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-property-unit-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-unit-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-property-unit-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-unit-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-property-value-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-value-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.declaration-property-value-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-value-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.font-family-name-quotes">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>font-family-name-quotes
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.font-family-no-duplicate-names">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>font-family-no-duplicate-names
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.font-weight-notation">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>font-weight-notation
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-calc-no-unspaced-operator">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-calc-no-unspaced-operator
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-comma-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-comma-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-comma-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-comma-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-linear-gradient-no-nonstandard-direction">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-linear-gradient-no-nonstandard-direction
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-max-empty-lines">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-max-empty-lines
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-name-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-name-case
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-parentheses-newline-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-parentheses-newline-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-parentheses-space-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-parentheses-space-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-url-data-uris">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-data-uris
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-url-no-scheme-relative">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-no-scheme-relative
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-url-quotes">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-quotes
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-url-scheme-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-scheme-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-whitelist
            <span class="apidocSignatureSpan">(whitelistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.function-whitespace-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>function-whitespace-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.indentation">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>indentation
            <span class="apidocSignatureSpan">(space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.keyframe-declaration-no-important">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>keyframe-declaration-no-important
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.length-zero-no-unit">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>length-zero-no-unit
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.max-empty-lines">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>max-empty-lines
            <span class="apidocSignatureSpan">(max, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.max-line-length">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>max-line-length
            <span class="apidocSignatureSpan">(maxLength, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.max-nesting-depth">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>max-nesting-depth
            <span class="apidocSignatureSpan">(max, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-colon-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-colon-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-colon-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-colon-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-name-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-no-missing-punctuation">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-no-missing-punctuation
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-parentheses-space-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-parentheses-space-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-range-operator-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-range-operator-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-feature-range-operator-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-range-operator-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-query-list-comma-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-query-list-comma-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-query-list-comma-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.media-query-list-comma-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-browser-hacks">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-browser-hacks
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-descending-specificity">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-descending-specificity
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-duplicate-selectors">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-duplicate-selectors
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-empty-source">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-empty-source
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-eol-whitespace">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-eol-whitespace
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-extra-semicolons">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-extra-semicolons
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-indistinguishable-colors">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-indistinguishable-colors
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-invalid-double-slash-comments">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-invalid-double-slash-comments
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-missing-end-of-source-newline">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-missing-end-of-source-newline
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-unknown-animations">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-unknown-animations
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.no-unsupported-browser-features">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>no-unsupported-browser-features
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.number-leading-zero">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>number-leading-zero
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.number-max-precision">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>number-max-precision
            <span class="apidocSignatureSpan">(precision)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.number-no-trailing-zeros">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>number-no-trailing-zeros
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.property-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>property-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.root-no-standard-properties">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>root-no-standard-properties
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.rule-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.rule-nested-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-nested-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.rule-non-nested-empty-line-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-non-nested-empty-line-before
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-brackets-space-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-brackets-space-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-operator-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-blacklist
            <span class="apidocSignatureSpan">(blacklistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-operator-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-operator-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-operator-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-whitelist
            <span class="apidocSignatureSpan">(whitelistInput)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-attribute-quotes">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-quotes
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-class-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-class-pattern
            <span class="apidocSignatureSpan">(pattern, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-combinator-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-combinator-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-combinator-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-combinator-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-descendant-combinator-no-non-space">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-descendant-combinator-no-non-space
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-id-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-id-pattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-list-comma-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-list-comma-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-list-comma-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-list-comma-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-max-compound-selectors">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-compound-selectors
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-max-empty-lines">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-empty-lines
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-max-specificity">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-specificity
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-nested-pattern">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-nested-pattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-attribute">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-attribute
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-combinator">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-combinator
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-empty">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-empty
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-id">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-id
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-qualifying-type">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-qualifying-type
            <span class="apidocSignatureSpan">(enabled, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-type">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-type
            <span class="apidocSignatureSpan">(on, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-universal">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-universal
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-blacklist
            <span class="apidocSignatureSpan">(blacklist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-parentheses-space-inside">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-parentheses-space-inside
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-class-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-whitelist
            <span class="apidocSignatureSpan">(whitelist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-element-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-element-colon-notation">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-colon-notation
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-pseudo-element-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-root-no-composition">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-root-no-composition
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-type-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-type-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.selector-type-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-type-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.shorthand-property-no-redundant-values">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>shorthand-property-no-redundant-values
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.string-no-newline">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>string-no-newline
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.string-quotes">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>string-quotes
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.stylelint-disable-reason">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>stylelint-disable-reason
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.time-min-milliseconds">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>time-min-milliseconds
            <span class="apidocSignatureSpan">(minimum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.time-no-imperceptible">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>time-no-imperceptible
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.unit-blacklist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-blacklist
            <span class="apidocSignatureSpan">(blacklistInput, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.unit-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-case
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.unit-no-unknown">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-no-unknown
            <span class="apidocSignatureSpan">(actual, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.unit-whitelist">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-whitelist
            <span class="apidocSignatureSpan">(whitelistInput, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-keyword-case">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-keyword-case
            <span class="apidocSignatureSpan">(expectation, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-comma-newline-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-newline-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-comma-newline-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-newline-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-comma-space-after">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-space-after
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-comma-space-before">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-space-before
            <span class="apidocSignatureSpan">(expectation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-list-max-empty-lines">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-max-empty-lines
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.rules.value-no-vendor-prefix">
            function <span class="apidocSignatureSpan">stylelint.rules.</span>value-no-vendor-prefix
            <span class="apidocSignatureSpan">(actual)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.stylelint.utils">module stylelint.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.utils.checkAgainstRule">
            function <span class="apidocSignatureSpan">stylelint.utils.</span>checkAgainstRule
            <span class="apidocSignatureSpan">( options, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.utils.report">
            function <span class="apidocSignatureSpan">stylelint.utils.</span>report
            <span class="apidocSignatureSpan">(violation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.utils.ruleMessages">
            function <span class="apidocSignatureSpan">stylelint.utils.</span>ruleMessages
            <span class="apidocSignatureSpan">( ruleName, messages )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.stylelint.utils.validateOptions">
            function <span class="apidocSignatureSpan">stylelint.utils.</span>validateOptions
            <span class="apidocSignatureSpan">( result, ruleName )</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint" id="apidoc.module.stylelint">module stylelint</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.createLinter" id="apidoc.element.stylelint.createLinter">
        function <span class="apidocSignatureSpan">stylelint.</span>createLinter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createLinter = function (options)/*: stylelint$internalApi*/ {
  options = options || {}
  const stylelint/*: Object*/ = { _options: options }

  // Two separate explorers so they can each have their own transform
  // function whose results are cached by cosmiconfig
  stylelint._fullExplorer = cosmiconfig(&#x22;stylelint&#x22;, {
    argv: false,
    rcExtensions: true,
    transform: _.partial(augmentConfig.augmentConfigFull, stylelint),
  })
  stylelint._extendExplorer = cosmiconfig(null, {
    argv: false,
    transform: _.partial(augmentConfig.augmentConfigExtended, stylelint),
  })

  stylelint._specifiedConfigCache = new Map()
  stylelint._postcssResultCache = new Map()
  stylelint._createStylelintResult = _.partial(createStylelintResult, stylelint)
  stylelint._getPostcssResult = _.partial(getPostcssResult, stylelint)
  stylelint._lintSource = _.partial(lintSource, stylelint)

  stylelint.getConfigForFile = _.partial(getConfigForFile, stylelint)
  stylelint.isPathIgnored = _.partial(isPathIgnored, stylelint)

  return stylelint
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.createPlugin" id="apidoc.element.stylelint.createPlugin">
        function <span class="apidocSignatureSpan">stylelint.</span>createPlugin
        <span class="apidocSignatureSpan">(ruleName, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPlugin = function (ruleName, rule) {
  return {
    ruleName,
    rule,
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.createRuleTester" id="apidoc.element.stylelint.createRuleTester">
        function <span class="apidocSignatureSpan">stylelint.</span>createRuleTester
        <span class="apidocSignatureSpan">(equalityCheck)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createRuleTester = function (equalityCheck) {
  return function (rule, schema) {
    const alreadyHadOnlyTest = !!onlyTest
    if (schema.accept) {
      schema.accept.forEach(_.partial(checkCaseForOnly, &#x22;accept&#x22;))
    }

    if (schema.reject) {
      schema.reject.forEach(_.partial(checkCaseForOnly, &#x22;reject&#x22;))
    }

    if (onlyTest) {
      schema = _.assign(_.omit(schema, [ &#x22;accept&#x22;, &#x22;reject&#x22; ]), {
        skipBasicChecks: true,
        [onlyTest.type]: [onlyTest.case],
      })
    }

    if (!alreadyHadOnlyTest) {
      process.nextTick(() =&#x3e; {
        processGroup(rule, schema, equalityCheck)
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.lint" id="apidoc.element.stylelint.lint">
        function <span class="apidocSignatureSpan">stylelint.</span>lint
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lint = function (options)/*: Promise&#x3c;stylelint$standaloneReturnValue&#x3e;*/ {
  const files = options.files
  const code = options.code
  const codeFilename = options.codeFilename
  const config = options.config
  const configFile = options.configFile
  const configBasedir = options.configBasedir
  const configOverrides = options.configOverrides
  const ignoreDisables = options.ignoreDisables
  const ignorePath = options.ignorePath
  const reportNeedlessDisables = options.reportNeedlessDisables
  const formatter = options.formatter
  const syntax = options.syntax
  const customSyntax = options.customSyntax
  const allowEmptyInput = options.allowEmptyInput
  const cacheLocation = options.cacheLocation
  const useCache = options.cache || false
  let fileCache

  const startTime = Date.now()

  const isValidCode = typeof code === &#x22;string&#x22;
  if (!files &#x26;&#x26; !isValidCode || files &#x26;&#x26; (code || isValidCode)) {
    throw new Error(&#x22;You must pass stylelint a `files` glob or a `code` string, though not both&#x22;)
  }

  let formatterFunction
  if (typeof formatter === &#x22;string&#x22;) {
    formatterFunction = formatters[formatter]
    if (formatterFunction === undefined) {
      return Promise.reject(new Error(&#x22;You must use a valid formatter option: &#x27;json&#x27;, &#x27;string&#x27;, &#x27;verbose&#x27;, or a function&#x22;))
    }
  } else if (typeof formatter === &#x22;function&#x22;) {
    formatterFunction = formatter
  } else {
    formatterFunction = formatters.json
  }

  const stylelint = createStylelint({
    config,
    configFile,
    configBasedir,
    configOverrides,
    ignoreDisables,
    ignorePath,
    reportNeedlessDisables,
    syntax,
    customSyntax,
  })

  if (!files) {
    const absoluteCodeFilename = (codeFilename !== undefined &#x26;&#x26; !path.isAbsolute(codeFilename))
      ? path.join(process.cwd(), codeFilename)
      : codeFilename
    return stylelint._lintSource({
      code,
      codeFilename: absoluteCodeFilename,
    }).then(postcssResult =&#x3e; {
      return stylelint._createStylelintResult(postcssResult)
    }).catch(handleError).then(stylelintResult =&#x3e; {
      return prepareReturnValue([stylelintResult])
    })
  }

  let fileList = files
  if (typeof fileList === &#x22;string&#x22;) {
    fileList = [fileList]
  }
  fileList = fileList.concat(
    alwaysIgnoredGlobs.map(file =&#x3e; &#x22;!&#x22; + file)
  )

  if (useCache) {
    const stylelintVersion = pkg.version
    const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config)}`)
    fileCache = new FileCache(cacheLocation, hashOfConfig)
  } else {
    // No need to calculate hash here, we just want to delete cache file.
    fileCache = new FileCache(cacheLocation)
    // Remove cache file if cache option is disabled
    fileCache.destroy()
  }

  return globby(fileList).then(filePaths =&#x3e; {
    if (!filePaths.length) {
      if (allowEmptyInput === undefined || !allowEmptyInput) {
        const message = (files =&#x3e; {
          if (typeof files === &#x22;string&#x22;) {
            return `${files} does`
          }
          // seperate files into last (last file) and initial) all the others
          const initial = files.slice(0)
          const last = initial.pop()
          // join into a comma seperated string of file names
          const ending = (files.length &#x3e; 1 ? `and ${last} do` : `${last} does`)
          return `${initial.join(&#x22;, &#x22;)} ${ending}`.trim()
        })(files) + &#x22; not match any files&#x22;

        const err/*: Object*/ = new Error(message)
        err.code = 80
        throw err
      } else {
        return Promise.all([])
      }
    }

    let absoluteFilePaths = filePaths.map(filePath =&#x3e; {
      const absoluteFilepath = (!path.isAbsolute(filePath))
        ? path.join(process.cwd(), filePath)
        : path.normalize(filePath)
      return absoluteFilepath
    })

    if (useCache) {
      absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache))
    }

    const getStylelintResults = absoluteFilePaths.map(absoluteFilepath =&#x3e; {
      debug(`Processing ${absoluteFilepath}`)
      return stylelint._lintSource({
        filePath: absoluteFilepath,
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.process" id="apidoc.element.stylelint.process">
        function <span class="apidocSignatureSpan">stylelint.</span>process
        <span class="apidocSignatureSpan">(root, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (root, opts) {
  return postcss([creator(opts)]).process(root, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    let preProcessedCode = code
    if (options.codeProcessors) {
      options.codeProcessors.forEach(codeProcessor =&#x3e; {
        preProcessedCode = codeProcessor(preProcessedCode, source)
      })
    }

    return postcssProcessor.<span class="apidocCodeKeywordSpan">process</span>(preProcessedCode, postcssOptions)
  }).then(postcssResult =&#x3e; {
    stylelint._postcssResultCache.set(options.filePath, postcssResult)
    return postcssResult
  })
}

function readFile(filePath/*: string*/)/*: Promise&#x3c;string&#x3e;*/ {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.augmentConfig" id="apidoc.module.stylelint.augmentConfig">module stylelint.augmentConfig</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.augmentConfig.augmentConfigExtended" id="apidoc.element.stylelint.augmentConfig.augmentConfigExtended">
        function <span class="apidocSignatureSpan">stylelint.augmentConfig.</span>augmentConfigExtended
        <span class="apidocSignatureSpan">( stylelint, cosmiconfigResultArg )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function augmentConfigExtended( stylelint, cosmiconfigResultArg )/*: Promise&#x3c;?{ config: stylelint$config, filepath: string }&#x3e;*/ {
  const cosmiconfigResult = cosmiconfigResultArg // Lock in for Flow
  if (!cosmiconfigResult) return Promise.resolve(null)

  const configDir = path.dirname(cosmiconfigResult.filepath || &#x22;&#x22;)
  const cleanedConfig = _.omit(cosmiconfigResult.config, &#x22;ignoreFiles&#x22;)
  return augmentConfigBasic(stylelint, cleanedConfig, configDir).then(augmentedConfig =&#x3e; {
    return {
      config: augmentedConfig,
      filepath: cosmiconfigResult.filepath,
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.augmentConfig.augmentConfigFull" id="apidoc.element.stylelint.augmentConfig.augmentConfigFull">
        function <span class="apidocSignatureSpan">stylelint.augmentConfig.</span>augmentConfigFull
        <span class="apidocSignatureSpan">( stylelint, cosmiconfigResultArg )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function augmentConfigFull( stylelint, cosmiconfigResultArg )/*: Promise&#x3c;?{ config: stylelint$config, filepath: string }&#x3e;*/ {
  const cosmiconfigResult = cosmiconfigResultArg // Lock in for Flow
  if (!cosmiconfigResult) return Promise.resolve(null)

  const config = cosmiconfigResult.config,
    filepath = cosmiconfigResult.filepath

  const configDir = stylelint._options.configBasedir || path.dirname(filepath || &#x22;&#x22;)

  return augmentConfigBasic(stylelint, config, configDir, true).then(augmentedConfig =&#x3e; {
    return addIgnorePatterns(stylelint, augmentedConfig)
  }).then(augmentedConfig =&#x3e; {
    return addPluginFunctions(augmentedConfig)
  }).then(augmentedConfig =&#x3e; {
    return addProcessorFunctions(augmentedConfig)
  }).then(augmentedConfig =&#x3e; {
    if (!augmentedConfig.rules) {
      throw configurationError(&#x22;No rules found within configuration. Have you provided a \&#x22;rules\&#x22; property?&#x22;)
    }

    return normalizeAllRuleSettings(augmentedConfig)
  }).then(augmentedConfig =&#x3e; {
    return {
      config: augmentedConfig,
      filepath: cosmiconfigResult.filepath,
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.formatters" id="apidoc.module.stylelint.formatters">module stylelint.formatters</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.formatters.json" id="apidoc.element.stylelint.formatters.json">
        function <span class="apidocSignatureSpan">stylelint.formatters.</span>json
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (results) {
  const cleanedResults = results.map(result =&#x3e; {
    return _.omitBy(result, (value, key) =&#x3e; key[0] === &#x22;_&#x22;)
  })
  return JSON.stringify(cleanedResults)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.formatters.string" id="apidoc.element.stylelint.formatters.string">
        function <span class="apidocSignatureSpan">stylelint.formatters.</span>string
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function (results) {
  let output = invalidOptionsFormatter(results)
  output += deprecationsFormatter(results)

  output = results.reduce((output, result) =&#x3e; {
    output += formatter(result.warnings, result.source)
    return output
  }, output)

  // Ensure consistent padding
  output = output.trim()

  if (output !== &#x22;&#x22;) {
    output = &#x22;\n&#x22; + output + &#x22;\n\n&#x22;
  }

  return output
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.formatters.verbose" id="apidoc.element.stylelint.formatters.verbose">
        function <span class="apidocSignatureSpan">stylelint.formatters.</span>verbose
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verbose = function (results) {
  let output = stringFormatter(results)

  if (output === &#x22;&#x22;) {
    output = &#x22;\n&#x22;
  }

  const sourceWord = results.length &#x3e; 1 ? &#x22;sources&#x22; : &#x22;source&#x22;
  const ignoredCount = results.filter(result =&#x3e; result.ignored).length
  const checkedDisplay = ignoredCount ? `${results.length - ignoredCount} of ${results.length}` : results.length
  output += chalk.underline(`${checkedDisplay} ${sourceWord} checked\n`)
  results.forEach(result =&#x3e; {
    let formatting = &#x22;green&#x22;
    if (result.errored) {
      formatting = &#x22;red&#x22;
    } else if (result.warnings.length) {
      formatting = &#x22;yellow&#x22;
    } else if (result.ignored) {
      formatting = &#x22;dim&#x22;
    }
    let sourceText = `${result.source}`
    if (result.ignored) {
      sourceText += &#x22; (ignored)&#x22;
    }
    output += _.get(chalk, formatting)(` ${sourceText}\n`)
  })

  const warnings = _.flatten(results.map(r =&#x3e; r.warnings))
  const warningsBySeverity = _.groupBy(warnings, &#x22;severity&#x22;)
  const problemWord = warnings.length === 1 ? &#x22;problem&#x22; : &#x22;problems&#x22;

  output += chalk.underline(`\n${warnings.length} ${problemWord} found\n`)

  _.forOwn(warningsBySeverity, (warningList, severityLevel) =&#x3e; {
    const warningsByRule = _.groupBy(warningList, &#x22;rule&#x22;)
    output += ` severity level &#x22;${severityLevel}&#x22;: ${warningList.length}\n`
    _.forOwn(warningsByRule, (list, rule) =&#x3e; {
      output += chalk.dim(`  ${rule}: ${list.length}\n`)
    })
  })

  return output + &#x22;\n&#x22;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.rules" id="apidoc.module.stylelint.rules">module stylelint.rules</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-blacklist" id="apidoc.element.stylelint.rules.at-rule-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-blacklist
        <span class="apidocSignatureSpan">(blacklistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-blacklist = function (blacklistInput) {
  // To allow for just a string as a parameter (not only arrays of strings)
  const blacklist = [].concat(blacklistInput)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      const name = atRule.name

      if (blacklist.indexOf(postcss.vendor.unprefixed(name).toLowerCase()) === -1) {
        return
      }

      report({
        message: messages.rejected(name),
        node: atRule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-empty-line-before" id="apidoc.element.stylelint.rules.at-rule-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-empty-line-before = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        except: [
          &#x22;after-same-name&#x22;,
          &#x22;all-nested&#x22;,
          &#x22;inside-block&#x22;,
          &#x22;blockless-after-same-name-blockless&#x22;,
          &#x22;blockless-group&#x22;,
          &#x22;blockless-after-blockless&#x22;,
          &#x22;first-nested&#x22;,
        ],
        ignore: [
          &#x22;after-comment&#x22;,
          &#x22;all-nested&#x22;,
          &#x22;inside-block&#x22;,
          &#x22;blockless-after-same-name-blockless&#x22;,
          &#x22;blockless-group&#x22;,
          &#x22;blockless-after-blockless&#x22;,
        ],
        ignoreAtRules: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    if (
      optionsMatches(options, &#x22;ignore&#x22;, &#x22;all-nested&#x22;)
      || optionsMatches(options, &#x22;except&#x22;, &#x22;all-nested&#x22;)
    ) {
      result.warn((
        &#x22;&#x27;at-rule-empty-line-before\&#x27;s&#x27; \&#x22;all-nested\&#x22; option has been deprecated and in 8.0 will be removed. &#x22; +
        &#x22;Instead use the \&#x22;inside-block\&#x22; option.&#x22;
      ), {
        stylelintType: &#x22;deprecation&#x22;,
        stylelintReference: &#x22;https://stylelint.io/user-guide/rules/at-rule-empty-line-before/&#x22;,
      })
    }

    if (
      optionsMatches(options, &#x22;ignore&#x22;, &#x22;blockless-group&#x22;)
      || optionsMatches(options, &#x22;except&#x22;, &#x22;blockless-group&#x22;)
    ) {
      result.warn((
        &#x22;&#x27;at-rule-empty-line-before\&#x27;s&#x27; \&#x22;blockless-group\&#x22; option has been deprecated and in 8.0 will be removed. &#x22; +
        &#x22;Instead use the \&#x22;blockless-after-blockless\&#x22; option.&#x22;
      ), {
        stylelintType: &#x22;deprecation&#x22;,
        stylelintReference: &#x22;https://stylelint.io/user-guide/rules/at-rule-empty-line-before/&#x22;,
      })
    }

    root.walkAtRules(atRule =&#x3e; {
      // Ignore the first node
      if (atRule === root.first) {
        return
      }

      // Return early if at-rule is to be ignored
      if (optionsMatches(options, &#x22;ignoreAtRules&#x22;, atRule.name)) {
        return
      }

      // Optionally ignore the expectation if the node is blockless
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;blockless-group&#x22;)
        &#x26;&#x26; !hasBlock(atRule)
        || optionsMatches(options, &#x22;ignore&#x22;, &#x22;blockless-after-blockless&#x22;)
        &#x26;&#x26; !hasBlock(atRule)
      ) {
        return
      }

      const isNested = atRule.parent !== root
      const previousNode = atRule.prev()

      // Optionally ignore the expection if the node is blockless
      // and following another blockless at-rule with the same name
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;blockless-after-same-name-blockless&#x22;)
        &#x26;&#x26; isBlocklessAfterSameNameBlockless()
      ) {
        return
      }

      // Optionally ignore the expectation if the node is inside a block
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;all-nested&#x22;)
        &#x26;&#x26; isNested
        || optionsMatches(options, &#x22;ignore&#x22;, &#x22;inside-block&#x22;)
        &#x26;&#x26; isNested
      ) {
        return
      }

      // Optionally ignore the expectation if a comment precedes this node
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;after-comment&#x22;)
        &#x26;&#x26; isAfterComment()
      ) {
        return
      }

      const hasEmptyLineBefore = hasEmptyLine(atRule.raws.before)
      let expectEmptyLineBefore = expectation === &#x22;always&#x22;
        ? true
        : false

      // Optionally reverse the expectation if any exceptions apply
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;after-same-name&#x22;)
        &#x26;&#x26; isAfterSameName()
        || optionsMatches(options, &#x22;except&#x22;, &#x22;all-nested&#x22;)
        &#x26;&#x26; isNested
        || optionsMatches(options, &#x22;except&#x22;, &#x22;inside-block&#x22;)
        &#x26;&#x26; isNested
        || optionsMatches(options, &#x22;except&#x22;, &#x22;first-nested&#x22;)
        &#x26;&#x26; isFirstNested()
        || optionsMatches(options, &#x22;except&#x22;, &#x22;blockless-group&#x22;)
        &#x26;&#x26; isBlocklessAfterBlockless()
        || optionsMatches(options, &#x22;except&#x22;, &#x22;blockless-after-blockless&#x22;)
        &#x26;&#x26; isBlocklessAfterBlockless()
        || optionsMatches( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-name-case" id="apidoc.element.stylelint.rules.at-rule-name-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-name-case = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      const name = atRule.name

      const expectedName = expectation === &#x22;lower&#x22;
        ? name.toLowerCase()
        : name.toUpperCase()

      if (name === expectedName) {
        return
      }

      report({
        message: messages.expected(name, expectedName),
        node: atRule,
        ruleName,
        result,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-name-newline-after" id="apidoc.element.stylelint.rules.at-rule-name-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-name-newline-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    atRuleNameSpaceChecker({
      root,
      result,
      locationChecker: checker.afterOneOnly,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-name-space-after" id="apidoc.element.stylelint.rules.at-rule-name-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-name-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-name-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    atRuleNameSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-no-unknown" id="apidoc.element.stylelint.rules.at-rule-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-no-unknown = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreAtRules: [_.isString],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      const name = atRule.name

      // Return early if at-rule is to be ignored
      if (optionsMatches(options, &#x22;ignoreAtRules&#x22;, atRule.name)) {
        return
      }

      if (
        postcss.vendor.prefix(name)
        || keywordSets.atRules.has(name.toLowerCase())
      ) {
        return
      }

      report({
        message: messages.rejected(`@${name}`),
        node: atRule,
        ruleName,
        result,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-no-vendor-prefix" id="apidoc.element.stylelint.rules.at-rule-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-no-vendor-prefix = function (actual) {
  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      if (!isStandardSyntaxAtRule(atRule)) {
        return
      }

      const name = atRule.name

      if (name[0] !== &#x22;-&#x22;) {
        return
      }

      if (!isAutoprefixable.atRuleName(name)) {
        return
      }

      report({
        message: messages.rejected(name),
        node: atRule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-semicolon-newline-after" id="apidoc.element.stylelint.rules.at-rule-semicolon-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-semicolon-newline-after
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-semicolon-newline-after = function (actual) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, actual, messages)

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual,
      possible: [&#x22;always&#x22;],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      const nextNode = atRule.next()
      if (!nextNode) {
        return
      }
      if (hasBlock(atRule)) {
        return
      }

      // Allow an end-of-line comment
      const nodeToCheck = nextNonCommentNode(nextNode)
      if (!nodeToCheck) {
        return
      }

      checker.afterOneOnly({
        source: rawNodeString(nodeToCheck),
        index: -1,
        err: msg =&#x3e; {
          report({
            message: msg,
            node: atRule,
            index: atRule.toString().length + 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-semicolon-space-before" id="apidoc.element.stylelint.rules.at-rule-semicolon-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-semicolon-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-semicolon-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      if (hasBlock(atRule)) {
        return
      }
      const nodeString = rawNodeString(atRule)

      checker.before({
        source: nodeString,
        index: nodeString.length,
        err: m =&#x3e; {
          report({
            message: m,
            node: atRule,
            index: nodeString.length - 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.at-rule-whitelist" id="apidoc.element.stylelint.rules.at-rule-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>at-rule-whitelist
        <span class="apidocSignatureSpan">(whitelistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at-rule-whitelist = function (whitelistInput) {
  // To allow for just a string as a parameter (not only arrays of strings)
  const whitelist = [].concat(whitelistInput)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      const name = atRule.name

      if (whitelist.indexOf(postcss.vendor.unprefixed(name).toLowerCase()) !== -1) {
        return
      }

      report({
        message: messages.rejected(name),
        node: atRule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-empty-line-before" id="apidoc.element.stylelint.rules.block-closing-brace-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-empty-line-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-empty-line-before = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always-multi-line&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      // Get whitespace after &#x22;&#x22;}&#x22;, ignoring extra semicolon
      const before = (statement.raws.after || &#x22;&#x22;).replace(/;+/, &#x22;&#x22;)
      if (before === undefined) {
        return
      }

      // Calculate index
      const statementString = statement.toString()
      let index = statementString.length - 1
      if (statementString[index - 1] === &#x22;\r&#x22;) {
        index -= 1
      }

      // Set expectation
      const expectEmptyLineBefore = expectation === &#x22;always-multi-line&#x22;
        &#x26;&#x26; !isSingleLineString(blockString(statement))
          ? true
          : false

      // Check for at least one empty line
      const hasEmptyLineBefore = hasEmptyLine(before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore
        ? messages.expected
        : messages.rejected

      report({
        message,
        result,
        ruleName,
        node: statement,
        index,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-newline-after" id="apidoc.element.stylelint.rules.block-closing-brace-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-newline-after
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-newline-after = function (expectation, options) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignoreAtRules: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      if (!hasBlock(statement)) {
        return
      }
      if (optionsMatches(options, &#x22;ignoreAtRules&#x22;, statement.name)) {
        return
      }

      const nextNode = statement.next()
      if (!nextNode) {
        return
      }

      // Allow an end-of-line comment x spaces after the brace
      const nextNodeIsSingleLineComment = nextNode.type === &#x22;comment&#x22;
        &#x26;&#x26; !/[^ ]/.test((nextNode.raws.before || &#x22;&#x22;))
        &#x26;&#x26; nextNode.toString().indexOf(&#x22;\n&#x22;) === -1

      const nodeToCheck = nextNodeIsSingleLineComment
        ? nextNode.next()
        : nextNode

      if (!nodeToCheck) {
        return
      }

      let reportIndex = statement.toString().length
      let source = rawNodeString(nodeToCheck)

      // Skip a semicolon at the beginning, if any
      if (
        source
        &#x26;&#x26; source[0] === &#x22;;&#x22;
      ) {
        source = source.slice(1)
        reportIndex++
      }

      // Only check one after, because there might be other
      // spaces handled by the indentation rule
      checker.afterOneOnly({
        source,
        index: -1,
        lineCheckStr: blockString(statement),
        err: msg =&#x3e; {
          report({
            message: msg,
            node: statement,
            index: reportIndex,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-newline-before" id="apidoc.element.stylelint.rules.block-closing-brace-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-newline-before = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      // Ignore extra semicolon
      const after = (statement.raws.after || &#x22;&#x22;).replace(/;+/, &#x22;&#x22;)
      if (after === undefined) {
        return
      }

      const blockIsMultiLine = !isSingleLineString(blockString(statement))
      const statementString = statement.toString()

      let index = statementString.length - 2
      if (statementString[index - 1] === &#x22;\r&#x22;) {
        index -= 1
      }

      // We&#x27;re really just checking whether a
      // newline *starts* the block&#x27;s final space -- between
      // the last declaration and the closing brace. We can
      // ignore any other whitespace between them, because that
      // will be checked by the indentation rule.
      if (
        !_.startsWith(after, &#x22;\n&#x22;)
        &#x26;&#x26; !_.startsWith(after, &#x22;\r\n&#x22;)
      ) {
        if (expectation === &#x22;always&#x22;) {
          complain(messages.expectedBefore)
        } else if (
          blockIsMultiLine
          &#x26;&#x26; expectation === &#x22;always-multi-line&#x22;
        ) {
          complain(messages.expectedBeforeMultiLine)
        }
      }

      if (
        after !== &#x22;&#x22;
        &#x26;&#x26; blockIsMultiLine
        &#x26;&#x26; expectation === &#x22;never-multi-line&#x22;
      ) {
        complain(messages.rejectedBeforeMultiLine)
      }

      function complain(message) {
        report({
          message,
          result,
          ruleName,
          node: statement,
          index,
        })
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-space-after" id="apidoc.element.stylelint.rules.block-closing-brace-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)

  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      const nextNode = statement.next()
      if (!nextNode) {
        return
      }
      if (!hasBlock(statement)) {
        return
      }

      let reportIndex = statement.toString().length
      let source = rawNodeString(nextNode)

      // Skip a semicolon at the beginning, if any
      if (
        source
        &#x26;&#x26; source[0] === &#x22;;&#x22;
      ) {
        source = source.slice(1)
        reportIndex++
      }

      checker.after({
        source,
        index: -1,
        lineCheckStr: blockString(statement),
        err: msg =&#x3e; {
          report({
            message: msg,
            node: statement,
            index: reportIndex,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-closing-brace-space-before" id="apidoc.element.stylelint.rules.block-closing-brace-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-closing-brace-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-closing-brace-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual : expectation,
      possible : [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statement: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      const source = blockString(statement)
      const statementString = statement.toString()

      let index = statementString.length - 2
      if (statementString[index - 1] === &#x22;\r&#x22;) {
        index -= 1
      }

      checker.before({
        source,
        index: source.length - 1,
        err: msg =&#x3e; {
          report({
            message: msg,
            node: statement,
            index,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-no-empty" id="apidoc.element.stylelint.rules.block-no-empty">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-no-empty
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-no-empty = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      if (!hasEmptyBlock(statement)) {
        return
      }

      let index = beforeBlockString(statement, { noRawBefore: true }).length

      // For empty blocks when using SugarSS parser
      if (statement.raws.between === undefined) {
        index--
      }

      report({
        message: messages.rejected,
        node: statement,
        index,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-no-single-line" id="apidoc.element.stylelint.rules.block-no-single-line">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-no-single-line
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-no-single-line = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      &#x22;&#x27;block-no-single-line&#x27; has been deprecated and in 8.0 will be removed. &#x22; +
      &#x22;Instead use &#x27;block-opening-brace-newline-after&#x27; and &#x27;block-closing-brace-newline-before&#x27; with the \&#x22;always\&#x22; option.&#x22;
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: &#x22;https://stylelint.io/user-guide/rules/block-no-single-line/&#x22;,
    })

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }
      if (!isSingleLineString(blockString(statement))) {
        return
      }

      report({
        message: messages.rejected,
        node: statement,
        index: beforeBlockString(statement, { noRawBefore: true }).length,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-opening-brace-newline-after" id="apidoc.element.stylelint.rules.block-opening-brace-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-opening-brace-newline-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statement: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has an empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      // Allow an end-of-line comment
      const nodeToCheck = nextNonCommentNode(statement.first)
      if (!nodeToCheck) {
        return
      }

      checker.afterOneOnly({
        source: rawNodeString(nodeToCheck),
        index: -1,
        lineCheckStr: blockString(statement),
        err: m =&#x3e; {
          report({
            message: m,
            node: statement,
            index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-opening-brace-newline-before" id="apidoc.element.stylelint.rules.block-opening-brace-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-opening-brace-newline-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual : expectation,
      possible : [
        &#x22;always&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statement: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has an empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      const source = beforeBlockString(statement)
      const beforeBraceNoRaw = beforeBlockString(statement, { noRawBefore: true })

      let index = beforeBraceNoRaw.length - 1
      if (beforeBraceNoRaw[index - 1] === &#x22;\r&#x22;) {
        index -= 1
      }

      checker.beforeAllowingIndentation({
        lineCheckStr: blockString(statement),
        source,
        index: source.length,
        err: m =&#x3e; {
          report({
            message: m,
            node: statement,
            index,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-opening-brace-space-after" id="apidoc.element.stylelint.rules.block-opening-brace-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-opening-brace-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has an empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      checker.after({
        source: blockString(statement),
        index: 0,
        err: m =&#x3e; {
          report({
            message: m,
            node: statement,
            index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.block-opening-brace-space-before" id="apidoc.element.stylelint.rules.block-opening-brace-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>block-opening-brace-space-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block-opening-brace-space-before = function (expectation, options) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignoreAtRules: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    // Check both kinds of statements: rules and at-rules
    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      // Return early if blockless or has an empty block
      if (
        !hasBlock(statement)
        || hasEmptyBlock(statement)
      ) {
        return
      }

      // Return early if at-rule is to be ignored
      if (optionsMatches(options, &#x22;ignoreAtRules&#x22;, statement.name)) {
        return
      }

      const source = beforeBlockString(statement)
      const beforeBraceNoRaw = beforeBlockString(statement, { noRawBefore: true })

      let index = beforeBraceNoRaw.length - 1
      if (beforeBraceNoRaw[index - 1] === &#x22;\r&#x22;) {
        index -= 1
      }

      checker.before({
        source,
        index: source.length,
        lineCheckStr: blockString(statement),
        err: m =&#x3e; {
          report({
            message: m,
            node: statement,
            index,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-hex-case" id="apidoc.element.stylelint.rules.color-hex-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-hex-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-hex-case = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const declString = blurFunctionArguments(decl.toString(), &#x22;url&#x22;)
      styleSearch({ source: declString, target: &#x22;#&#x22; }, match =&#x3e; {
        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))
        if (!hexMatch) {
          return
        }

        const hexValue = hexMatch[0]
        const hexValueLower = hexValue.toLowerCase()
        const hexValueUpper = hexValue.toUpperCase()
        const expectedHex = expectation === &#x22;lower&#x22;
          ? hexValueLower
          : hexValueUpper

        if (hexValue === expectedHex) {
          return
        }

        report({
          message: messages.expected(hexValue, expectedHex),
          node: decl,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-hex-length" id="apidoc.element.stylelint.rules.color-hex-length">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-hex-length
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-hex-length = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;short&#x22;,
        &#x22;long&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const declString = decl.toString()

      styleSearch({ source: declString, target: &#x22;#&#x22; }, match =&#x3e; {
        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))
        if (!hexMatch) {
          return
        }

        const hexValue = hexMatch[0]

        if (
          expectation === &#x22;long&#x22;
          &#x26;&#x26; hexValue.length !== 4
          &#x26;&#x26; hexValue.length !== 5
        ) {
          return
        }

        if (
          expectation === &#x22;short&#x22;
          &#x26;&#x26; (
            hexValue.length &#x3c; 6
            || !canShrink(hexValue)
          )
        ) {
          return
        }

        const variant = expectation === &#x22;long&#x22;
          ? longer
          : shorter

        report({
          message: messages.expected(hexValue, variant(hexValue)),
          node: decl,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-named" id="apidoc.element.stylelint.rules.color-named">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-named
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-named = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;never&#x22;,
        &#x22;always-where-possible&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignoreProperties: [_.isString],
        ignore: [&#x22;inside-function&#x22;],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    const namedColors = Object.keys(namedColorData)

    root.walkDecls(decl =&#x3e; {
      if (propertySets.acceptCustomIdents.has(decl.prop)) {
        return
      }

      // Return early if the property is to be ignored
      if (optionsMatches(options, &#x22;ignoreProperties&#x22;, decl.prop)) {
        return
      }

      valueParser(decl.value).walk(node =&#x3e; {
        const value = node.value,
          type = node.type,
          sourceIndex = node.sourceIndex

        if (
          optionsMatches(options, &#x22;ignore&#x22;, &#x22;inside-function&#x22;)
          &#x26;&#x26; type === &#x22;function&#x22;
        ) {
          return false
        }

        if (!isStandardSyntaxFunction(node)) {
          return false
        }

        if (!isStandardSyntaxValue(value)) {
          return
        }
        // Return early if neither a word nor a function
        if (NODE_TYPES.indexOf(type) === -1) {
          return
        }

        // Check for named colors for &#x22;never&#x22; option
        if (
          expectation === &#x22;never&#x22;
          &#x26;&#x26; type === &#x22;word&#x22;
          &#x26;&#x26; namedColors.indexOf(value.toLowerCase()) !== -1
        ) {
          complain(messages.rejected(value), decl, declarationValueIndex(decl) + sourceIndex)
          return
        }

        // Check &#x22;always-where-possible&#x22; option ...
        if (expectation !== &#x22;always-where-possible&#x22;) {
          return
        }

        // First by checking for alternative color function representations ...
        if (
          type === &#x22;function&#x22;
          &#x26;&#x26; keywordSets.colorFunctionNames.has(value.toLowerCase())
        ) {
          // Remove all spaces to match what&#x27;s in `representations`
          const normalizedFunctionString = valueParser.stringify(node).replace(/\s+/g, &#x22;&#x22;)
          let namedColor
          for (let i = 0, l = namedColors.length; i &#x3c; l; i++) {
            namedColor = namedColors[i]
            if (namedColorData[namedColor].func.indexOf(normalizedFunctionString.toLowerCase()) !== -1) {
              complain(messages.expected(namedColor, normalizedFunctionString), decl, declarationValueIndex(decl) + sourceIndex)
              return // Exit as soon as a problem is found
            }
          }
          return
        }

        // Then by checking for alternative hex representations
        let namedColor
        for (let i = 0, l = namedColors.length; i &#x3c; l; i++) {
          namedColor = namedColors[i]
          if (namedColorData[namedColor].hex.indexOf(value.toLowerCase()) !== -1) {
            complain(messages.expected(namedColor, value), decl, declarationValueIndex(decl) + sourceIndex)
            return // Exit as soon as a problem is found
          }
        }
      })
    })

    function complain(message, node, index) {
      report({
        result,
        ruleName,
        message,
        node,
        index,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-no-hex" id="apidoc.element.stylelint.rules.color-no-hex">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-no-hex
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-no-hex = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const declString = decl.toString()

      styleSearch({ source: declString, target: &#x22;#&#x22; }, match =&#x3e; {
        // If there&#x27;s not a colon, comma, or whitespace character before, we&#x27;ll assume this is
        // not intended to be a hex color, but is instead something like the
        // hash in a url() argument
        if (!/[:,\s]/.test(declString[match.startIndex - 1])) {
          return
        }

        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))
        if (!hexMatch) {
          return
        }
        const hexValue = hexMatch[0]

        report({
          message: messages.rejected(hexValue),
          node: decl,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.color-no-invalid-hex" id="apidoc.element.stylelint.rules.color-no-invalid-hex">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>color-no-invalid-hex
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color-no-invalid-hex = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const declString = decl.toString()

      styleSearch({ source: declString, target: &#x22;#&#x22; }, match =&#x3e; {
        // If there&#x27;s not a colon, comma, or whitespace character before, we&#x27;ll assume this is
        // not intended to be a hex color, but is instead something like the
        // hash in a url() argument
        if (!/[:,\s]/.test(declString[match.startIndex - 1])) {
          return
        }

        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))
        if (!hexMatch) {
          return
        }

        const hexValue = hexMatch[0]
        if (isValidHex(hexValue)) {
          return
        }

        report({
          message: messages.rejected(hexValue),
          node: decl,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.comment-empty-line-before" id="apidoc.element.stylelint.rules.comment-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment-empty-line-before = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        except: [&#x22;first-nested&#x22;],
        ignore: [
          &#x22;stylelint-commands&#x22;,
          &#x22;stylelint-command&#x22;,
          &#x22;between-comments&#x22;,
          &#x22;after-comment&#x22;,
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    if (
      optionsMatches(options, &#x22;ignore&#x22;, &#x22;between-comments&#x22;)
    ) {
      result.warn((
        &#x22;&#x27;comment-empty-line-before\&#x27;s&#x27; \&#x22;between-comments\&#x22; option has been deprecated and in 8.0 will be removed. &#x22; +
        &#x22;Instead use the \&#x22;after-comment\&#x22; option.&#x22;
      ), {
        stylelintType: &#x22;deprecation&#x22;,
        stylelintReference: &#x22;https://stylelint.io/user-guide/rules/comment-empty-line-before/&#x22;,
      })
    }

    root.walkComments(comment =&#x3e; {
      // Ignore the first node
      if (comment === root.first) {
        return
      }

      // Optionally ignore stylelint commands
      if (
        comment.text.indexOf(stylelintCommandPrefix) === 0
        &#x26;&#x26; optionsMatches(options, &#x22;ignore&#x22;, &#x22;stylelint-commands&#x22;)
      ) {
        return
      }

      // Optionally ignore newlines between comments
      const prev = comment.prev()
      if (
        prev
        &#x26;&#x26; prev.type === &#x22;comment&#x22;
        &#x26;&#x26; optionsMatches(options, &#x22;ignore&#x22;, &#x22;between-comments&#x22;)
      ) {
        return
      }

      if (
        prev
        &#x26;&#x26; prev.type === &#x22;comment&#x22;
        &#x26;&#x26; optionsMatches(options, &#x22;ignore&#x22;, &#x22;after-comment&#x22;)
      ) {
        return
      }

      if (
        comment.raws.inline
        || comment.inline
      ) {
        return
      }

      const before = (comment.raws.before || &#x22;&#x22;)

      // Ignore shared-line comments
      if (before.indexOf(&#x22;\n&#x22;) === -1) {
        return
      }

      const expectEmptyLineBefore = (() =&#x3e; {
        if (
          optionsMatches(options, &#x22;except&#x22;, &#x22;first-nested&#x22;)
          &#x26;&#x26; comment.parent !== root
          &#x26;&#x26; comment === comment.parent.first
        ) {
          return false
        }
        return expectation === &#x22;always&#x22;
      })()

      const hasEmptyLineBefore = hasEmptyLine(before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore
        ? messages.expected
        : messages.rejected

      report({
        message,
        node: comment,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.comment-no-empty" id="apidoc.element.stylelint.rules.comment-no-empty">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-no-empty
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment-no-empty = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkComments(comment =&#x3e; {
      // To ignore inline SCSS comments
      if (
        comment.raws.inline
        || comment.inline
      ) {
        return
      }

      // To ignore comments that are not empty
      if (
        comment.text
        &#x26;&#x26; comment.text.length !== 0
      ) {
        return
      }

      report({
        message: messages.rejected,
        node: comment,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.comment-whitespace-inside" id="apidoc.element.stylelint.rules.comment-whitespace-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-whitespace-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment-whitespace-inside = function (expectation) {
  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkComments(function (comment) {
      if (
        comment.raws.inline
        || comment.inline
      ) {
        return
      }

      const rawComment = comment.toString()
      const firstFourChars = rawComment.substr(0, 4)

      // Return early if sourcemap or copyright comment
      if (/^\/\*[#!]\s/.test(firstFourChars)) {
        return
      }

      const leftMatches = rawComment.match(/(^\/\*+)(\s)?/)
      const rightMatches = rawComment.match(/(\s)?(\*+\/)$/)
      const opener = leftMatches[1]
      const leftSpace = leftMatches[2] || &#x22;&#x22;
      const rightSpace = rightMatches[1] || &#x22;&#x22;
      const closer = rightMatches[2]

      if (
        expectation === &#x22;never&#x22;
        &#x26;&#x26; leftSpace !== &#x22;&#x22;
      ) {
        complain(messages.rejectedOpening, opener.length)
      }

      if (
        expectation === &#x22;always&#x22;
        &#x26;&#x26; !isWhitespace(leftSpace)
      ) {
        complain(messages.expectedOpening, opener.length)
      }

      if (
        expectation === &#x22;never&#x22;
        &#x26;&#x26; rightSpace !== &#x22;&#x22;
      ) {
        complain(messages.rejectedClosing, comment.toString().length - closer.length - 1)
      }

      if (
        expectation === &#x22;always&#x22;
        &#x26;&#x26; !isWhitespace(rightSpace)
      ) {
        complain(messages.expectedClosing, comment.toString().length - closer.length - 1)
      }

      function complain(message, index) {
        report({
          message,
          index,
          result,
          ruleName,
          node: comment,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.comment-word-blacklist" id="apidoc.element.stylelint.rules.comment-word-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>comment-word-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment-word-blacklist = function (blacklist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkComments(comment =&#x3e; {
      const text = comment.text
      const rawComment = comment.toString()
      const firstFourChars = rawComment.substr(0, 4)

      // Return early if sourcemap
      if (firstFourChars === &#x22;/*# &#x22;) {
        return
      }

      const matchesWord = matchesStringOrRegExp(text, blacklist) || containsString(text, blacklist)

      if (!matchesWord) {
        return
      }

      report({
        message: messages.rejected(matchesWord.pattern),
        node: comment,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.custom-media-pattern" id="apidoc.element.stylelint.rules.custom-media-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-media-pattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom-media-pattern = function (pattern) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    })
    if (!validOptions) {
      return
    }

    const regexpPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkAtRules(atRule =&#x3e; {
      if (atRule.name.toLowerCase() !== &#x22;custom-media&#x22;) {
        return
      }

      const customMediaName = atRule.params.match(/^--(\S+)\b/)[1]

      if (regexpPattern.test(customMediaName)) {
        return
      }

      report({
        message: messages.expected,
        node: atRule,
        index: atRuleParamIndex(atRule),
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.custom-property-empty-line-before" id="apidoc.element.stylelint.rules.custom-property-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom-property-empty-line-before = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        except: [
          &#x22;first-nested&#x22;,
          &#x22;after-comment&#x22;,
          &#x22;after-custom-property&#x22;,
        ],
        ignore: [
          &#x22;after-comment&#x22;,
          &#x22;inside-single-line-block&#x22;,
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop,
        parent = decl.parent

      if (!isStandardSyntaxDeclaration(decl)) {
        return
      }
      if (!isCustomProperty(prop)) {
        return
      }

      // Optionally ignore the node if a comment precedes it
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;after-comment&#x22;)
        &#x26;&#x26; decl.prev()
        &#x26;&#x26; decl.prev().type === &#x22;comment&#x22;
      ) {
        return
      }

      // Optionally ignore nodes inside single-line blocks
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;inside-single-line-block&#x22;)
        &#x26;&#x26; isSingleLineString(blockString(parent))
      ) {
        return
      }

      let expectEmptyLineBefore = expectation === &#x22;always&#x22; ? true : false

      // Optionally reverse the expectation for the first nested node
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;first-nested&#x22;)
        &#x26;&#x26; decl === parent.first
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a comment precedes this node
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;after-comment&#x22;)
        &#x26;&#x26; decl.prev()
        &#x26;&#x26; decl.prev().type === &#x22;comment&#x22;
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a custom property precedes this node
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;after-custom-property&#x22;)
        &#x26;&#x26; decl.prev()
        &#x26;&#x26; decl.prev().prop
        &#x26;&#x26; isCustomProperty(decl.prev().prop)
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      const hasEmptyLineBefore = hasEmptyLine(decl.raws.before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore ? messages.expected : messages.rejected
      report({
        message,
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.custom-property-no-outside-root" id="apidoc.element.stylelint.rules.custom-property-no-outside-root">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-no-outside-root
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom-property-no-outside-root = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed. Instead use the community &#x27;stylelint-suitcss&#x27; plugin pack.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&#x3e; {
      // Ignore rules whose selector is just `:root`
      if (rule.selector.toLowerCase().trim() === &#x22;:root&#x22;) {
        return
      }

      rule.walkDecls(decl =&#x3e; {
        if (!isCustomProperty(decl.prop)) {
          return
        }
        report({
          message: messages.rejected,
          node: decl,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.custom-property-pattern" id="apidoc.element.stylelint.rules.custom-property-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>custom-property-pattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">custom-property-pattern = function (pattern) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    })
    if (!validOptions) {
      return
    }

    const regexpPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop

      if (!isCustomProperty(prop)) {
        return
      }
      if (regexpPattern.test(prop.slice(2))) {
        return
      }

      report({
        message: messages.expected,
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-bang-space-after" id="apidoc.element.stylelint.rules.declaration-bang-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-bang-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-bang-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    declarationBangSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-bang-space-before" id="apidoc.element.stylelint.rules.declaration-bang-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-bang-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-bang-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    declarationBangSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-no-duplicate-properties" id="apidoc.element.stylelint.rules.declaration-block-no-duplicate-properties">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-duplicate-properties
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-no-duplicate-properties = function (on, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      actual: options,
      possible: {
        ignore: [
          &#x22;consecutive-duplicates&#x22;,
          &#x22;consecutive-duplicates-with-different-values&#x22;,
        ],
        ignoreProperties: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    // In order to accommodate nested blocks (postcss-nested),
    // we need to run a shallow loop (instead of eachDecl() or eachRule(),
    // which loop recursively) and allow each nested block to accumulate
    // its own list of properties -- so that a property in a nested rule
    // does not conflict with the same property in the parent rule
    root.each(node =&#x3e; {
      if (
        node.type === &#x22;rule&#x22;
        || node.type === &#x22;atrule&#x22;
      ) {
        checkRulesInNode(node)
      }
    })

    function checkRulesInNode(node) {
      const decls = []
      const values = []

      node.each(child =&#x3e; {
        if (
          child.nodes
          &#x26;&#x26; child.nodes.length
        ) {
          checkRulesInNode(child)
        }

        if (child.type !== &#x22;decl&#x22;) {
          return
        }

        const prop = child.prop
        const value = child.value

        if (!isStandardSyntaxProperty(prop)) {
          return
        }
        if (isCustomProperty(prop)) {
          return
        }

        // Return early if the property is to be ignored
        if (optionsMatches(options, &#x22;ignoreProperties&#x22;, prop)) {
          return
        }

        // Ignore the src property as commonly duplicated in at-fontface
        if (prop.toLowerCase() === &#x22;src&#x22;) {
          return
        }

        const indexDuplicate = decls.indexOf(prop.toLowerCase())

        if (indexDuplicate !== -1) {
          if (optionsMatches(options, &#x22;ignore&#x22;, &#x22;consecutive-duplicates-with-different-values&#x22;)) {
            // if duplicates are not consecutive
            if (indexDuplicate !== decls.length - 1) {
              report({
                message: messages.rejected(prop),
                node: child,
                result,
                ruleName,
              })
              return
            }
            // if values of consecutive duplicates are equal
            if (value === values[indexDuplicate]) {
              report({
                message: messages.rejected(value),
                node: child,
                result,
                ruleName,
              })
              return
            }
            return
          }

          if (
            optionsMatches(options, &#x22;ignore&#x22;, &#x22;consecutive-duplicates&#x22;)
            &#x26;&#x26; indexDuplicate === decls.length - 1
          ) {
            return
          }

          report({
            message: messages.rejected(prop),
            node: child,
            result,
            ruleName,
          })
        }

        decls.push(prop.toLowerCase())
        values.push(value.toLowerCase())
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-no-ignored-properties" id="apidoc.element.stylelint.rules.declaration-block-no-ignored-properties">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-ignored-properties
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-no-ignored-properties = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })

    if (!validOptions) {
      return
    }

    result.warn((
      &#x22;&#x27;declaration-block-no-ignored-properties&#x27; has been deprecated and in 8.0 will be removed.&#x22;
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: &#x22;https://stylelint.io/user-guide/rules/declaration-block-no-ignored-properties/&#x22;,
    })

    const uniqueDecls = {}
    root.walkDecls(decl =&#x3e; {
      uniqueDecls[decl.prop] = decl
    })

    Object.keys(uniqueDecls).forEach((prop, index) =&#x3e; {
      const decl = uniqueDecls[prop]
      const unprefixedProp = postcss.vendor.unprefixed(prop)
      const unprefixedValue = postcss.vendor.unprefixed(decl.value)

      ignored.forEach(ignore =&#x3e; {
        const matchProperty = matchesStringOrRegExp(unprefixedProp.toLowerCase(), ignore.property)
        const matchValue = matchesStringOrRegExp(unprefixedValue.toLowerCase(), ignore.value)

        if (!matchProperty || !matchValue) {
          return
        }

        const ignoredProperties = ignore.ignoredProperties

        decl.parent.nodes.forEach((node, nodeIndex) =&#x3e; {
          if (!node.prop || ignoredProperties.indexOf(node.prop.toLowerCase()) === -1 || index === nodeIndex) {
            return
          }

          report({
            message: messages.rejected(node.prop, decl.toString()),
            node,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-no-redundant-longhand-properties" id="apidoc.element.stylelint.rules.declaration-block-no-redundant-longhand-properties">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-redundant-longhand-properties
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-no-redundant-longhand-properties = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreShorthands: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const longhandProperties = _.transform(shorthandData, (result, values, key) =&#x3e; {
      if (optionsMatches(options, &#x22;ignoreShorthands&#x22;, key)) {
        return
      }

      values.forEach(value =&#x3e; {
        (result[value] || (result[value] = [])).push(key)
      })
    })

    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      const longhandDeclarations = {}
      // Shallow iteration so nesting doesn&#x27;t produce
      // false positives
      statement.each(node =&#x3e; {
        if (node.type !== &#x22;decl&#x22;) {
          return
        }

        const prop = node.prop.toLowerCase()

        const shorthandProperties = longhandProperties[prop]

        if (!shorthandProperties) {
          return
        }

        shorthandProperties.forEach(shorthandProperty =&#x3e; {
          (longhandDeclarations[shorthandProperty] || (longhandDeclarations[shorthandProperty] = [])).push(prop)

          if (!_.isEqual(shorthandData[shorthandProperty].sort(), longhandDeclarations[shorthandProperty].sort())) {
            return
          }

          report({
            ruleName,
            result,
            node,
            message: messages.expected(shorthandProperty),
          })
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-no-shorthand-property-overrides" id="apidoc.element.stylelint.rules.declaration-block-no-shorthand-property-overrides">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-no-shorthand-property-overrides
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-no-shorthand-property-overrides = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(check)
    root.walkAtRules(check)

    function check(statement) {
      const declarations = {}
      // Shallow iteration so nesting doesn&#x27;t produce
      // false positives
      statement.each(node =&#x3e; {
        if (node.type !== &#x22;decl&#x22;) {
          return
        }
        const prop = node.prop

        const overrideables = shorthandData[prop.toLowerCase()]
        if (!overrideables) {
          declarations[prop.toLowerCase()] = prop
          return
        }
        overrideables.forEach(longhandProp =&#x3e; {
          if (!declarations.hasOwnProperty(longhandProp)) {
            return
          }
          report({
            ruleName,
            result,
            node,
            message: messages.rejected(prop, declarations[longhandProp]),
          })
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-properties-order" id="apidoc.element.stylelint.rules.declaration-block-properties-order">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-properties-order
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-properties-order = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: validatePrimaryOption,
    }, {
      actual: options,
      possible: {
        unspecified: [
          &#x22;top&#x22;,
          &#x22;bottom&#x22;,
          &#x22;ignore&#x22;,
          &#x22;bottomAlphabetical&#x22;,
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    result.warn((
      &#x22;&#x27;declaration-block-properties-order&#x27;has been deprecated and in 8.0 will be removed. &#x22; +
      &#x22;Instead use the community &#x27;stylelint-order&#x27; plugin pack.&#x22;
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: &#x22;https://stylelint.io/user-guide/rules/declaration-block-properties-order/&#x22;,
    })

    const alphabetical = expectation === &#x22;alphabetical&#x22;
    const expectedOrder = alphabetical ? null : createExpectedOrder(expectation)
    // By default, ignore unspecified properties
    const unspecified = _.get(options, [&#x22;unspecified&#x22;], &#x22;ignore&#x22;)

    // Shallow loop
    root.each(node =&#x3e; {
      if (node.type === &#x22;rule&#x22; || node.type === &#x22;atrule&#x22;) {
        checkNode(node)
      }
    })

    function checkNode(node) {
      const allPropData = []

      node.each(child =&#x3e; {
        // If the child has nested nodes with child
        // (e.g. a rule nested within a rule), make
        // sure to check the children
        if (child.nodes &#x26;&#x26; child.nodes.length) {
          checkNode(child)
        }

        if (child.type !== &#x22;decl&#x22;) {
          return
        }

        const prop = child.prop

        if (!isStandardSyntaxProperty(prop)) {
          return
        }
        if (isCustomProperty(prop)) {
          return
        }

        let unprefixedPropName = postcss.vendor.unprefixed(prop)

        // Hack to allow -moz-osx-font-smoothing to be understood
        // just like -webkit-font-smoothing
        if (unprefixedPropName.indexOf(&#x22;osx-&#x22;) === 0) {
          unprefixedPropName = unprefixedPropName.slice(4)
        }

        const propData = {
          name: prop,
          unprefixedName: unprefixedPropName,
          orderData: alphabetical ? null : getOrderData(expectedOrder, unprefixedPropName),
          before: child.raws.before,
          index: allPropData.length,
          node: child,
        }

        const previousPropData = _.last(allPropData)
        allPropData.push(propData)

        // Skip first decl
        if (!previousPropData) {
          return
        }

        const isCorrectOrder = alphabetical ? checkAlpabeticalOrder(previousPropData, propData) : checkOrder(previousPropData, propData
)

        if (isCorrectOrder) {
          return
        }

        complain({
          message: messages.expected(propData.name, previousPropData.name),
          node: child,
        })
      })

      function checkOrder(firstPropData, secondPropData) {
        // If the unprefixed property names are the same, resort to alphabetical ordering
        if (firstPropData.unprefixedName === secondPropData.unprefixedName) {
          return firstPropData.name &#x3c;= secondPropData.name
        }

        const firstPropIsUnspecified = !firstPropData.orderData
        const secondPropIsUnspecified = !secondPropData.orderData

        // Now check actual known properties ...
        if (!firstPropIsUnspecified &#x26;&#x26; !secondPropIsUnspecified) {
          return firstPropData.orderData.expectedPosition &#x3c;= secondPropData.orderData.expectedPosition
        }

        if (firstPropIsUnspecified &#x26;&#x26; !secondPropIsUnspecified) {
          // If first prop is unspecified, look for a specified prop before it to
          // compare to the current prop
          const priorSpecifiedPropData = _.findLast(allPropData.slice(0, -1), d =&#x3e; !!d.orderData)
          if (priorSpecifiedPropData &#x26;&#x26; priorSpecifiedPropData.orderData &#x26;&#x26; priorSpecifiedPropData.orderData.expectedPosition &#x3e;
secondPropData.orderData.expectedPosition) {
            complain({
              message: messages.expected(secondPropData.name, priorSpecifiedPropData.name),
              node: ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-semicolon-newline-after" id="apidoc.element.stylelint.rules.declaration-block-semicolon-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-semicolon-newline-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      // Ignore last declaration if there&#x27;s no trailing semicolon
      const parentRule = decl.parent
      if (
        !parentRule.raws.semicolon
        &#x26;&#x26; parentRule.last === decl
      ) {
        return
      }

      const nextNode = decl.next()
      if (!nextNode) {
        return
      }

      // Allow end-of-line comment
      const nodeToCheck = nextNonCommentNode(nextNode)
      if (!nodeToCheck) {
        return
      }

      checker.afterOneOnly({
        source: rawNodeString(nodeToCheck),
        index: -1,
        lineCheckStr: blockString(parentRule),
        err: m =&#x3e; {
          report({
            message: m,
            node: decl,
            index: decl.toString().length + 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-semicolon-newline-before" id="apidoc.element.stylelint.rules.declaration-block-semicolon-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-semicolon-newline-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)

  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      const parentRule = decl.parent
      if (
        !parentRule.raws.semicolon
        &#x26;&#x26; parentRule.last === decl
      ) {
        return
      }

      const declString = decl.toString()

      checker.beforeAllowingIndentation({
        source: declString,
        index: declString.length,
        lineCheckStr: blockString(parentRule),
        err: m =&#x3e; {
          report({
            message: m,
            node: decl,
            index: decl.toString().length - 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-semicolon-space-after" id="apidoc.element.stylelint.rules.declaration-block-semicolon-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-semicolon-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)

  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      // Ignore last declaration if there&#x27;s no trailing semicolon
      const parentRule = decl.parent
      if (!parentRule.raws.semicolon &#x26;&#x26; parentRule.last === decl) {
        return
      }

      const nextDecl = decl.next()
      if (!nextDecl) {
        return
      }

      checker.after({
        source: rawNodeString(nextDecl),
        index: -1,
        lineCheckStr: blockString(parentRule),
        err: m =&#x3e; {
          report({
            message: m,
            node: decl,
            index: decl.toString().length + 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-semicolon-space-before" id="apidoc.element.stylelint.rules.declaration-block-semicolon-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-semicolon-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-semicolon-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      // Ignore last declaration if there&#x27;s no trailing semicolon
      const parentRule = decl.parent
      if (!parentRule.raws.semicolon &#x26;&#x26; parentRule.last === decl) {
        return
      }

      const declString = decl.toString()

      checker.before({
        source: declString,
        index: declString.length,
        lineCheckStr: blockString(parentRule),
        err: m =&#x3e; {
          report({
            message: m,
            node: decl,
            index: decl.toString().length - 1,
            result,
            ruleName,
          })
        },
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-single-line-max-declarations" id="apidoc.element.stylelint.rules.declaration-block-single-line-max-declarations">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-single-line-max-declarations
        <span class="apidocSignatureSpan">(quantity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-single-line-max-declarations = function (quantity) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: quantity,
      possible: [_.isNumber],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isSingleLineString(blockString(rule))) {
        return
      }
      if (!rule.nodes) {
        return
      }

      const decls = rule.nodes.filter(node =&#x3e; node.type === &#x22;decl&#x22;)

      if (decls.length &#x3c;= quantity) {
        return
      }

      report({
        message: messages.expected(quantity),
        node: rule,
        index: beforeBlockString(rule, { noRawBefore: true }).length,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-block-trailing-semicolon" id="apidoc.element.stylelint.rules.declaration-block-trailing-semicolon">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-block-trailing-semicolon
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-block-trailing-semicolon = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      if (atRule.parent === root) {
        return
      }
      if (atRule !== atRule.parent.last) {
        return
      }
      if (hasBlock(atRule)) {
        return
      }
      checkLastNode(atRule)
    })

    root.walkDecls(decl =&#x3e; {
      if (decl !== decl.parent.last) {
        return
      }
      checkLastNode(decl)
    })

    function checkLastNode(node) {
      let message

      if (expectation === &#x22;always&#x22;) {
        if (node.parent.raws.semicolon) {
          return
        }
        message = messages.expected
      }
      if (expectation === &#x22;never&#x22;) {
        if (!node.parent.raws.semicolon) {
          return
        }
        message = messages.rejected
      }

      report({
        message,
        node,
        index: node.toString().trim().length - 1,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-colon-newline-after" id="apidoc.element.stylelint.rules.declaration-colon-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-colon-newline-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (!isStandardSyntaxDeclaration(decl)) {
        return
      }

      // Get the raw prop, and only the prop
      const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || &#x22;&#x22;).length - 1

      // The extra characters tacked onto the end ensure that there is a character to check
      // after the colon. Otherwise, with `background:pink` the character after the
      const propPlusColon = decl.toString().slice(0, endOfPropIndex) + &#x22;xxx&#x22;

      for (let i = 0, l = propPlusColon.length; i &#x3c; l; i++) {
        if (propPlusColon[i] !== &#x22;:&#x22;) {
          continue
        }
        const indexToCheck = propPlusColon.substr(propPlusColon[i], 3) === &#x22;/*&#x22; ? propPlusColon.indexOf(&#x22;*/&#x22;, i) + 1 : i

        checker.afterOneOnly({
          source: propPlusColon,
          index: indexToCheck,
          lineCheckStr: decl.value,
          err: m =&#x3e; {
            report({
              message: m,
              node: decl,
              index: indexToCheck,
              result,
              ruleName,
            })
          },
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-colon-space-after" id="apidoc.element.stylelint.rules.declaration-colon-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-colon-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    declarationColonSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-colon-space-before" id="apidoc.element.stylelint.rules.declaration-colon-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-colon-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-colon-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    declarationColonSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-empty-line-before" id="apidoc.element.stylelint.rules.declaration-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-empty-line-before = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        except: [
          &#x22;first-nested&#x22;,
          &#x22;after-comment&#x22;,
          &#x22;after-declaration&#x22;,
        ],
        ignore: [
          &#x22;after-comment&#x22;,
          &#x22;after-declaration&#x22;,
          &#x22;inside-single-line-block&#x22;,
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop,
        parent = decl.parent

      if (!isStandardSyntaxDeclaration(decl)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }

      // Optionally ignore the node if a comment precedes it
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;after-comment&#x22;)
        &#x26;&#x26; decl.prev()
        &#x26;&#x26; decl.prev().type === &#x22;comment&#x22;
      ) {
        return
      }

      // Optionally ignore the node if a declaration precedes it
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;after-declaration&#x22;)
        &#x26;&#x26; decl.prev()
        &#x26;&#x26; decl.prev().type === &#x22;decl&#x22;
      ) {
        return
      }

      // Optionally ignore nodes inside single-line blocks
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;inside-single-line-block&#x22;)
        &#x26;&#x26; isSingleLineString(blockString(parent))
      ) {
        return
      }

      let expectEmptyLineBefore = expectation === &#x22;always&#x22;
        ? true
        : false

      // Optionally reverse the expectation for the first nested node
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;first-nested&#x22;)
        &#x26;&#x26; decl === parent.first
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a comment precedes this node
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;after-comment&#x22;)
        &#x26;&#x26; decl.prev()
        &#x26;&#x26; decl.prev().type === &#x22;comment&#x22;
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a declaration precedes this node
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;after-declaration&#x22;)
        &#x26;&#x26; decl.prev()
        &#x26;&#x26; decl.prev().prop
        &#x26;&#x26; isStandardSyntaxDeclaration(decl.prev())
        &#x26;&#x26; !isCustomProperty(decl.prev().prop)
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Check for at least one empty line
      const hasEmptyLineBefore = hasEmptyLine(decl.raws.before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore
        ? messages.expected
        : messages.rejected
      report({ message, node: decl, result, ruleName })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-no-important" id="apidoc.element.stylelint.rules.declaration-no-important">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-no-important
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-no-important = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (!decl.important) {
        return
      }

      report({
        message: messages.rejected,
        node: decl,
        word: &#x22;important&#x22;,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-property-unit-blacklist" id="apidoc.element.stylelint.rules.declaration-property-unit-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-unit-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-property-unit-blacklist = function (blacklist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isObject],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop,
        value = decl.value

      const unprefixedProp = postcss.vendor.unprefixed(prop)

      const propBlacklist = _.find(blacklist, (list, propIdentifier) =&#x3e; matchesStringOrRegExp(unprefixedProp, propIdentifier))

      if (!propBlacklist) {
        return
      }

      valueParser(value).walk(function (node) {
        // Ignore wrong units within `url` function
        if (
          node.type === &#x22;function&#x22;
          &#x26;&#x26; node.value.toLowerCase() === &#x22;url&#x22;
        ) {
          return false
        }
        if (node.type === &#x22;string&#x22;) {
          return
        }

        const unit = getUnitFromValueNode(node)

        if (
          !unit
          || unit
          &#x26;&#x26; propBlacklist.indexOf(unit.toLowerCase()) === -1
        ) {
          return
        }

        report({
          message: messages.rejected(prop, unit),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-property-unit-whitelist" id="apidoc.element.stylelint.rules.declaration-property-unit-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-unit-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-property-unit-whitelist = function (whitelist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isObject],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop,
        value = decl.value

      const unprefixedProp = postcss.vendor.unprefixed(prop)

      const propWhitelist = _.find(whitelist, (list, propIdentifier) =&#x3e; matchesStringOrRegExp(unprefixedProp, propIdentifier))

      if (!propWhitelist) {
        return
      }

      valueParser(value).walk(function (node) {
        // Ignore wrong units within `url` function
        if (node.type === &#x22;function&#x22; &#x26;&#x26; node.value.toLowerCase() === &#x22;url&#x22;) {
          return false
        }
        if (node.type === &#x22;string&#x22;) {
          return
        }

        const unit = getUnitFromValueNode(node)

        if (!unit || (unit &#x26;&#x26; propWhitelist.indexOf(unit.toLowerCase())) !== -1) {
          return
        }

        report({
          message: messages.rejected(prop, unit),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-property-value-blacklist" id="apidoc.element.stylelint.rules.declaration-property-value-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-value-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-property-value-blacklist = function (blacklist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isObject],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop,
        value = decl.value

      const unprefixedProp = postcss.vendor.unprefixed(prop)
      const propBlacklist = _.find(blacklist, (list, propIdentifier) =&#x3e; matchesStringOrRegExp(unprefixedProp, propIdentifier))

      if (_.isEmpty(propBlacklist)) {
        return
      }

      if (!matchesStringOrRegExp(value, propBlacklist)) {
        return
      }

      report({
        message: messages.rejected(prop, value),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.declaration-property-value-whitelist" id="apidoc.element.stylelint.rules.declaration-property-value-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>declaration-property-value-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declaration-property-value-whitelist = function (whitelist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isObject],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop,
        value = decl.value

      const unprefixedProp = postcss.vendor.unprefixed(prop)
      const propWhitelist = _.find(whitelist, (list, propIdentifier) =&#x3e; matchesStringOrRegExp(unprefixedProp, propIdentifier))

      if (_.isEmpty(propWhitelist)) {
        return
      }

      if (matchesStringOrRegExp(value, propWhitelist)) {
        return
      }

      report({
        message: messages.rejected(prop, value),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.font-family-name-quotes" id="apidoc.element.stylelint.rules.font-family-name-quotes">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>font-family-name-quotes
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">font-family-name-quotes = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always-where-required&#x22;,
        &#x22;always-where-recommended&#x22;,
        &#x22;always-unless-keyword&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(/^font(-family)?$/i, decl =&#x3e; {
      const fontFamilies = findFontFamily(decl.value)

      if (fontFamilies.length === 0) {
        return
      }

      fontFamilies.forEach(fontFamilyNode =&#x3e; {
        let rawFamily = fontFamilyNode.value

        if (fontFamilyNode.quote) {
          rawFamily = fontFamilyNode.quote + rawFamily + fontFamilyNode.quote
        }

        checkFamilyName(rawFamily, decl)
      })
    })

    function checkFamilyName(rawFamily, decl) {
      if (!isStandardSyntaxValue(rawFamily)) {
        return
      }
      if (isVariable(rawFamily)) {
        return
      }

      const hasQuotes = rawFamily[0] === &#x22;&#x27;&#x22; || rawFamily[0] === &#x22;\&#x22;&#x22;

      // Clean the family of its quotes
      const family = rawFamily.replace(/^[&#x27;&#x22;]|[&#x27;&#x22;]$/g, &#x22;&#x22;)

      // Disallow quotes around (case-insensitive) keywords
      // and system font keywords in all cases
      if (keywordSets.fontFamilyKeywords.has(family.toLowerCase()) || isSystemFontKeyword(family)) {
        if (hasQuotes) {
          return complain(messages.rejected(family), family, decl)
        }
        return
      }

      const required = quotesRequired(family)
      const recommended = quotesRecommended(family)

      switch (expectation) {
        case &#x22;always-unless-keyword&#x22;:
          if (!hasQuotes) {
            return complain(messages.expected(family), family, decl)
          }
          return

        case &#x22;always-where-recommended&#x22;:
          if (!recommended &#x26;&#x26; hasQuotes) {
            return complain(messages.rejected(family), family, decl)
          }
          if (recommended &#x26;&#x26; !hasQuotes) {
            return complain(messages.expected(family), family, decl)
          }
          return

        case &#x22;always-where-required&#x22;:
          if (!required &#x26;&#x26; hasQuotes) {
            return complain(messages.rejected(family), family, decl)
          }
          if (required &#x26;&#x26; !hasQuotes) {
            return complain(messages.expected(family), family, decl)
          }
          return
      }
    }

    function complain(message, family, decl) {
      report({
        result,
        ruleName,
        message,
        node: decl,
        word: family,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.font-family-no-duplicate-names" id="apidoc.element.stylelint.rules.font-family-no-duplicate-names">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>font-family-no-duplicate-names
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">font-family-no-duplicate-names = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreFontFamilyNames: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(/^font(-family)?$/i, decl =&#x3e; {
      const keywords = new Set()
      const familyNames = new Set()

      const fontFamilies = findFontFamily(decl.value)

      if (fontFamilies.length === 0) {
        return
      }

      fontFamilies.forEach(fontFamilyNode =&#x3e; {
        const family = fontFamilyNode.value.trim()

        if (optionsMatches(options, &#x22;ignoreFontFamilyNames&#x22;, fontFamilyNode.value.trim())) {
          return
        }

        if (isFamilyNameKeyword(fontFamilyNode)) {
          if (keywords.has(family.toLowerCase())) {
            complain(messages.rejected(family), declarationValueIndex(decl) + fontFamilyNode.sourceIndex, decl)
            return
          }

          keywords.add(family)
          return
        }

        if (familyNames.has(family)) {
          complain(messages.rejected(family), declarationValueIndex(decl) + fontFamilyNode.sourceIndex, decl)
          return
        }

        familyNames.add(family)
      })
    })

    function complain(message, index, decl) {
      report({
        result,
        ruleName,
        message,
        node: decl,
        index,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.font-weight-notation" id="apidoc.element.stylelint.rules.font-weight-notation">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>font-weight-notation
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">font-weight-notation = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;numeric&#x22;,
        &#x22;named-where-possible&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignore: [&#x22;relative&#x22;],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (decl.prop.toLowerCase() === &#x22;font-weight&#x22;) {
        checkWeight(decl.value, decl)
      }

      if (decl.prop.toLowerCase() === &#x22;font&#x22;) {
        checkFont(decl)
      }
    })

    function checkFont(decl) {
      const valueList = postcss.list.space(decl.value)
      // We do not need to more carefully distinguish font-weight
      // numbers from unitless line-heights because line-heights in
      // `font` values need to be part of a font-size/line-height pair
      const hasNumericFontWeight = valueList.some(isNumbery)

      for (const value of postcss.list.space(decl.value)) {
        if (value.toLowerCase() === NORMAL_KEYWORD &#x26;&#x26; !hasNumericFontWeight || isNumbery(value) || value.toLowerCase() !== NORMAL_KEYWORD
 &#x26;&#x26; keywordSets.fontWeightKeywords.has(value.toLowerCase())) {
          checkWeight(value, decl)
          return
        }
      }
    }

    function checkWeight(weightValue, decl) {
      if (!isStandardSyntaxValue(weightValue)) {
        return
      }
      if (isVariable(weightValue)) {
        return
      }
      if (weightValue.toLowerCase() === INHERIT_KEYWORD || weightValue.toLowerCase() === INITIAL_KEYWORD) {
        return
      }

      if (optionsMatches(options, &#x22;ignore&#x22;, &#x22;relative&#x22;) &#x26;&#x26; keywordSets.fontWeightRelativeKeywords.has(weightValue.toLowerCase())) {
        return
      }

      const weightValueOffset = decl.value.indexOf(weightValue)

      if (expectation === &#x22;numeric&#x22;) {
        if (!isNumbery(weightValue)) {
          return complain(messages.expected(&#x22;numeric&#x22;))
        }
      }

      if (expectation === &#x22;named-where-possible&#x22;) {
        if (isNumbery(weightValue)) {
          if (_.includes(WEIGHTS_WITH_KEYWORD_EQUIVALENTS, weightValue)) {
            complain(messages.expected(&#x22;named&#x22;))
          }
          return
        }
        if (!keywordSets.fontWeightKeywords.has(weightValue.toLowerCase()) &#x26;&#x26; weightValue.toLowerCase() !== NORMAL_KEYWORD) {
          return complain(messages.invalidNamed(weightValue))
        }
        return
      }

      function complain(message) {
        report({
          ruleName,
          result,
          message,
          node: decl,
          index: declarationValueIndex(decl) + weightValueOffset,
        })
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-blacklist" id="apidoc.element.stylelint.rules.function-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-blacklist = function (blacklist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }
    root.walkDecls(decl =&#x3e; {
      const value = decl.value

      valueParser(value).walk(function (node) {
        if (node.type !== &#x22;function&#x22;) {
          return
        }
        if (!isStandardSyntaxFunction(node)) {
          return
        }
        if (!matchesStringOrRegExp(postcss.vendor.unprefixed(node.value).toLowerCase(), blacklist)) {
          return
        }

        report({
          message: messages.rejected(node.value),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-calc-no-unspaced-operator" id="apidoc.element.stylelint.rules.function-calc-no-unspaced-operator">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-calc-no-unspaced-operator
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-calc-no-unspaced-operator = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    function complain(message, node, index) {
      report({ message, node, index, result, ruleName })
    }

    root.walkDecls(decl =&#x3e; {
      valueParser(decl.value).walk(node =&#x3e; {
        if (node.type !== &#x22;function&#x22; || node.value.toLowerCase() !== &#x22;calc&#x22;) {
          return
        }

        const parensMatch = balancedMatch(&#x22;(&#x22;, &#x22;)&#x22;, valueParser.stringify(node))
        const rawExpression = parensMatch.body
        const expressionIndex = decl.source.start.column + decl.prop.length + (decl.raws.between || &#x22;&#x22;).length + node.sourceIndex
        const expression = blurVariables(rawExpression)

        checkSymbol(&#x22;+&#x22;)
        checkSymbol(&#x22;-&#x22;)
        checkSymbol(&#x22;*&#x22;)
        checkSymbol(&#x22;/&#x22;)

        function checkSymbol(symbol) {
          const styleSearchOptions = {
            source: expression,
            target: symbol,
            functionArguments: &#x22;skip&#x22;,
          }

          styleSearch(styleSearchOptions, match =&#x3e; {
            const index = match.startIndex

            // Deal with signs.
            // (@ and $ are considered &#x22;digits&#x22; here to allow for variable syntaxes
            // that permit signs in front of variables, e.g. `-$number`)
            // As is &#x22;.&#x22; to deal with fractional numbers without a leading zero
            if ((symbol === &#x22;+&#x22; || symbol === &#x22;-&#x22;) &#x26;&#x26; /[\d@\$.]/.test(expression[index + 1])) {
              const expressionBeforeSign = expression.substr(0, index)

              // Ignore signs that directly follow a opening bracket
              if (expressionBeforeSign[expressionBeforeSign.length - 1] === &#x22;(&#x22;) {
                return
              }

              // Ignore signs at the beginning of the expression
              if (/^\s*$/.test(expressionBeforeSign)) {
                return
              }

              // Otherwise, ensure that there is a real operator preceeding them
              if (/[\*/+-]\s*$/.test(expressionBeforeSign)) {
                return
              }

              // And if not, complain
              complain(messages.expectedOperatorBeforeSign(symbol), decl, expressionIndex + index)
              return
            }

            const beforeOk = expression[index - 1] === &#x22; &#x22; &#x26;&#x26; !isWhitespace(expression[index - 2]) || newlineBefore(expression,
index - 1)
            if (!beforeOk) {
              complain(messages.expectedBefore(symbol), decl, expressionIndex + index)
            }

            const afterOk = expression[index + 1] === &#x22; &#x22; &#x26;&#x26; !isWhitespace(expression[index + 2]) || expression[index + 1] === &#x22;\n&#x22; || expression.substr(index + 1, 2) === &#x22;\r\n&#x22;

            if (!afterOk) {
              complain(messages.expectedAfter(symbol), decl, expressionIndex + index)
            }
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-comma-newline-after" id="apidoc.element.stylelint.rules.function-comma-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-comma-newline-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    functionCommaSpaceChecker({
      root,
      result,
      locationChecker: checker.afterOneOnly,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-comma-newline-before" id="apidoc.element.stylelint.rules.function-comma-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-comma-newline-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    functionCommaSpaceChecker({
      root,
      result,
      locationChecker: checker.beforeAllowingIndentation,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-comma-space-after" id="apidoc.element.stylelint.rules.function-comma-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-comma-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    functionCommaSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-comma-space-before" id="apidoc.element.stylelint.rules.function-comma-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-comma-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-comma-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    functionCommaSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-linear-gradient-no-nonstandard-direction" id="apidoc.element.stylelint.rules.function-linear-gradient-no-nonstandard-direction">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-linear-gradient-no-nonstandard-direction
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-linear-gradient-no-nonstandard-direction = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      functionArgumentsSearch(decl.toString().toLowerCase(), &#x22;linear-gradient&#x22;, (expression, expressionIndex) =&#x3e; {
        const firstArg = expression.split(&#x22;,&#x22;)[0].trim()

        // If the first character is a number, we can assume the user intends an angle
        if (/[\d\.]/.test(firstArg[0])) {
          if (/^[\d\.]+(?:deg|grad|rad|turn)$/.test(firstArg)) {
            return
          }
          complain()
          return
        }

        // The first argument may not be a direction: it may be an angle,
        // or a color stop (in which case user gets default direction, &#x22;to bottom&#x22;)
        // cf. https://drafts.csswg.org/css-images-3/#linear-gradient-syntax
        if (!/left|right|top|bottom/.test(firstArg)) {
          return
        }

        const withToPrefix = !postcss.vendor.prefix(decl.value)
        if (!isStandardDirection(firstArg, withToPrefix)) {
          complain()
          return
        }

        function complain() {
          report({
            message: messages.rejected,
            node: decl,
            index: expressionIndex,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-max-empty-lines" id="apidoc.element.stylelint.rules.function-max-empty-lines">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-max-empty-lines
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-max-empty-lines = function (max) {
  const maxAdjacentNewlines = max + 1

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: _.isNumber,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (decl.value.indexOf(&#x22;(&#x22;) === -1) {
        return
      }

      const declString = decl.toString()
      const repeatLFNewLines = _.repeat(&#x22;\n&#x22;, maxAdjacentNewlines)
      const repeatCRLFNewLines = _.repeat(&#x22;\r\n&#x22;, maxAdjacentNewlines)

      styleSearch({
        source: declString,
        target: &#x22;\n&#x22;,
        functionArguments: &#x22;only&#x22;,
      }, match =&#x3e; {
        if (declString.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || declString.substr(match.startIndex
 + 1, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {
          // Put index at `\r` if it&#x27;s CRLF, otherwise leave it at `\n`
          let index = match.startIndex
          if (declString[index - 1] === &#x22;\r&#x22;) {
            index -= 1
          }

          report({
            message: messages.expected(max),
            node: decl,
            index,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-name-case" id="apidoc.element.stylelint.rules.function-name-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-name-case
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-name-case = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignoreFunctions: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const value = decl.value

      valueParser(value).walk(function (node) {
        if (node.type !== &#x22;function&#x22; || !isStandardSyntaxFunction(node)) {
          return
        }

        const functionName = node.value
        const functionNameLowerCase = functionName.toLowerCase()

        const ignoreFunctions = options &#x26;&#x26; options.ignoreFunctions || []

        if (ignoreFunctions.length &#x3e; 0 &#x26;&#x26; matchesStringOrRegExp(functionName, ignoreFunctions)) {
          return
        }

        let expectedFunctionName = null

        if (expectation === &#x22;lower&#x22; &#x26;&#x26; mapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase)) {
          expectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase)
        } else if (expectation === &#x22;lower&#x22;) {
          expectedFunctionName = functionNameLowerCase
        } else {
          expectedFunctionName = functionName.toUpperCase()
        }

        if (functionName === expectedFunctionName) {
          return
        }

        report({
          message: messages.expected(functionName, expectedFunctionName),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-parentheses-newline-inside" id="apidoc.element.stylelint.rules.function-parentheses-newline-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-parentheses-newline-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-parentheses-newline-inside = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (decl.value.indexOf(&#x22;(&#x22;) === -1) {
        return
      }

      valueParser(decl.value).walk(valueNode =&#x3e; {
        if (valueNode.type !== &#x22;function&#x22;) {
          return
        }

        if (!isStandardSyntaxFunction(valueNode)) {
          return
        }

        const functionString = valueParser.stringify(valueNode)
        const isMultiLine = !isSingleLineString(functionString)
        function containsNewline(str) {
          return str.indexOf(&#x22;\n&#x22;) !== -1
        }

        // Check opening ...

        const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1

        if (expectation === &#x22;always&#x22; &#x26;&#x26; !containsNewline(valueNode.before)) {
          complain(messages.expectedOpening, openingIndex)
        }

        if (isMultiLine &#x26;&#x26; expectation === &#x22;always-multi-line&#x22; &#x26;&#x26; !containsNewline(valueNode.before)) {
          complain(messages.expectedOpeningMultiLine, openingIndex)
        }

        if (isMultiLine &#x26;&#x26; expectation === &#x22;never-multi-line&#x22; &#x26;&#x26; valueNode.before !== &#x22;&#x22;) {
          complain(messages.rejectedOpeningMultiLine, openingIndex)
        }

        // Check closing ...

        const closingIndex = valueNode.sourceIndex + functionString.length - 2

        if (expectation === &#x22;always&#x22; &#x26;&#x26; !containsNewline(valueNode.after)) {
          complain(messages.expectedClosing, closingIndex)
        }

        if (isMultiLine &#x26;&#x26; expectation === &#x22;always-multi-line&#x22; &#x26;&#x26; !containsNewline(valueNode.after)) {
          complain(messages.expectedClosingMultiLine, closingIndex)
        }

        if (isMultiLine &#x26;&#x26; expectation === &#x22;never-multi-line&#x22; &#x26;&#x26; valueNode.after !== &#x22;&#x22;) {
          complain(messages.rejectedClosingMultiLine, closingIndex)
        }
      })

      function complain(message, offset) {
        report({
          ruleName,
          result,
          message,
          node: decl,
          index: declarationValueIndex(decl) + offset,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-parentheses-space-inside" id="apidoc.element.stylelint.rules.function-parentheses-space-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-parentheses-space-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-parentheses-space-inside = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (decl.value.indexOf(&#x22;(&#x22;) === -1) {
        return
      }

      valueParser(decl.value).walk(valueNode =&#x3e; {
        if (valueNode.type !== &#x22;function&#x22;) {
          return
        }

        if (!isStandardSyntaxFunction(valueNode)) {
          return
        }

        const functionString = valueParser.stringify(valueNode)
        const isSingleLine = isSingleLineString(functionString)

        // Check opening ...

        const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1

        if (expectation === &#x22;always&#x22; &#x26;&#x26; valueNode.before !== &#x22; &#x22;) {
          complain(messages.expectedOpening, openingIndex)
        }

        if (expectation === &#x22;never&#x22; &#x26;&#x26; valueNode.before !== &#x22;&#x22;) {
          complain(messages.rejectedOpening, openingIndex)
        }

        if (isSingleLine &#x26;&#x26; expectation === &#x22;always-single-line&#x22; &#x26;&#x26; valueNode.before !== &#x22; &#x22;) {
          complain(messages.expectedOpeningSingleLine, openingIndex)
        }

        if (isSingleLine &#x26;&#x26; expectation === &#x22;never-single-line&#x22; &#x26;&#x26; valueNode.before !== &#x22;&#x22;) {
          complain(messages.rejectedOpeningSingleLine, openingIndex)
        }

        // Check closing ...

        const closingIndex = valueNode.sourceIndex + functionString.length - 2

        if (expectation === &#x22;always&#x22; &#x26;&#x26; valueNode.after !== &#x22; &#x22;) {
          complain(messages.expectedClosing, closingIndex)
        }

        if (expectation === &#x22;never&#x22; &#x26;&#x26; valueNode.after !== &#x22;&#x22;) {
          complain(messages.rejectedClosing, closingIndex)
        }

        if (isSingleLine &#x26;&#x26; expectation === &#x22;always-single-line&#x22; &#x26;&#x26; valueNode.after !== &#x22; &#x22;) {
          complain(messages.expectedClosingSingleLine, closingIndex)
        }

        if (isSingleLine &#x26;&#x26; expectation === &#x22;never-single-line&#x22; &#x26;&#x26; valueNode.after !== &#x22;&#x22;) {
          complain(messages.rejectedClosingSingleLine, closingIndex)
        }
      })

      function complain(message, offset) {
        report({
          ruleName,
          result,
          message,
          node: decl,
          index: declarationValueIndex(decl) + offset,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-url-data-uris" id="apidoc.element.stylelint.rules.function-url-data-uris">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-data-uris
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-url-data-uris = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      valueParser(decl.value).walk(valueNode =&#x3e; {
        if (valueNode.type !== &#x22;function&#x22; || valueNode.value.toLowerCase() !== &#x22;url&#x22; || !valueNode.nodes.length &#x3e; 0) {
          return
        }

        const urlValueNode = valueNode.nodes[0]

        if (!urlValueNode.value || !isStandardSyntaxValue(urlValueNode.value) || isVariable(urlValueNode.value)) {
          return
        }

        const valueContainDataUris = urlValueNode.value.toLowerCase().indexOf(&#x22;data:&#x22;) === 0
        const needUrlDataUris = expectation === &#x22;always&#x22;

        if (valueContainDataUris &#x26;&#x26; needUrlDataUris || !valueContainDataUris &#x26;&#x26; !needUrlDataUris) {
          return
        }

        const message = needUrlDataUris ? messages.expected : messages.rejected

        report({
          message,
          node: decl,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-url-no-scheme-relative" id="apidoc.element.stylelint.rules.function-url-no-scheme-relative">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-no-scheme-relative
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-url-no-scheme-relative = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      functionArgumentsSearch(decl.toString().toLowerCase(), &#x22;url&#x22;, (args, index) =&#x3e; {
        const url = _.trim(args, &#x22; &#x27;\&#x22;&#x22;)

        if (!isStandardSyntaxUrl(url) || url.indexOf(&#x22;//&#x22;) !== 0) {
          return
        }

        report({
          message: messages.rejected,
          node: decl,
          index,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-url-quotes" id="apidoc.element.stylelint.rules.function-url-quotes">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-quotes
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-url-quotes = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        except: [&#x22;empty&#x22;],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(checkStatement)
    root.walkRules(checkStatement)

    function checkStatement(statement) {
      if (statement.type === &#x22;atrule&#x22;) {
        checkAtRuleParams(statement)
      }

      statement.walkDecls(function (decl) {
        functionArgumentsSearch(decl.toString().toLowerCase(), &#x22;url&#x22;, (args, index) =&#x3e; {
          checkArgs(args, decl, index, &#x22;url&#x22;)
        })
      })
    }

    function checkAtRuleParams(atRule) {
      const atRuleParamsLowerCase = atRule.params.toLowerCase()
      functionArgumentsSearch(atRuleParamsLowerCase, &#x22;url&#x22;, (args, index) =&#x3e; {
        checkArgs(args, atRule, index + atRuleParamIndex(atRule), &#x22;url&#x22;)
      })
      functionArgumentsSearch(atRuleParamsLowerCase, &#x22;url-prefix&#x22;, (args, index) =&#x3e; {
        checkArgs(args, atRule, index + atRuleParamIndex(atRule), &#x22;url-prefix&#x22;)
      })
      functionArgumentsSearch(atRuleParamsLowerCase, &#x22;domain&#x22;, (args, index) =&#x3e; {
        checkArgs(args, atRule, index + atRuleParamIndex(atRule), &#x22;domain&#x22;)
      })
    }

    function checkArgs(args, node, index, functionName) {
      let shouldHasQuotes = expectation === &#x22;always&#x22;

      const leftTrimmedArgs = args.trimLeft()
      if (!isStandardSyntaxUrl(leftTrimmedArgs)) {
        return
      }
      const complaintIndex = index + args.length - leftTrimmedArgs.length
      const hasQuotes = leftTrimmedArgs[0] === &#x22;&#x27;&#x22; || leftTrimmedArgs[0] === &#x22;\&#x22;&#x22;

      const trimmedArg = args.trim()
      const isEmptyArgument = _.includes([
        &#x22;&#x22;,
        &#x22;&#x27;&#x27;&#x22;,
        &#x22;\&#x22;\&#x22;&#x22;,
      ], trimmedArg)
      if (optionsMatches(options, &#x22;except&#x22;, &#x22;empty&#x22;) &#x26;&#x26; isEmptyArgument) {
        shouldHasQuotes = !shouldHasQuotes
      }

      if (shouldHasQuotes) {
        if (hasQuotes) {
          return
        }
        complain(messages.expected(functionName), node, complaintIndex)
      } else {
        if (!hasQuotes) {
          return
        }
        complain(messages.rejected(functionName), node, complaintIndex)
      }
    }

    function complain(message, node, index) {
      report({
        message,
        node,
        index,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-url-scheme-whitelist" id="apidoc.element.stylelint.rules.function-url-scheme-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-url-scheme-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-url-scheme-whitelist = function (whitelist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(function (decl) {
      functionArgumentsSearch(decl.toString().toLowerCase(), &#x22;url&#x22;, (args, index) =&#x3e; {
        const unspacedUrlString = _.trim(args, &#x22; &#x22;)
        if (!isStandardSyntaxUrl(unspacedUrlString)) {
          return
        }
        const urlString = _.trim(unspacedUrlString, &#x22;&#x27;\&#x22;&#x22;)

        const url = parse(urlString)
        if (url.protocol === null) {
          return
        }

        const scheme = url.protocol.toLowerCase().slice(0, -1) // strip trailing `:`

        // The URL spec does not require a scheme to be followed by `//`, but checking
        // for it allows this rule to differentiate &#x3c;scheme&#x3e;:&#x3c;hostname&#x3e; urls from
        // &#x3c;hostname&#x3e;:&#x3c;port&#x3e; urls. `data:` scheme urls are an exception to this rule.
        const slashIndex = url.protocol.length
        const expectedSlashes = urlString.slice(slashIndex, slashIndex + 2)
        const isSchemeLessUrl = expectedSlashes !== &#x22;//&#x22; &#x26;&#x26; scheme !== &#x22;data&#x22;
        if (isSchemeLessUrl) {
          return
        }

        const whitelistLowerCase = typeof whitelist === &#x22;string&#x22; ? whitelist.toLowerCase() : whitelist.join(&#x22;|&#x22;).toLowerCase().split
(&#x22;|&#x22;)

        if (containsString(scheme, whitelistLowerCase)) {
          return
        }

        report({
          message: messages.rejected(scheme),
          node: decl,
          index,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-whitelist" id="apidoc.element.stylelint.rules.function-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-whitelist
        <span class="apidocSignatureSpan">(whitelistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-whitelist = function (whitelistInput) {
  const whitelist = [].concat(whitelistInput)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }
    root.walkDecls(decl =&#x3e; {
      const value = decl.value

      valueParser(value).walk(function (node) {
        if (node.type !== &#x22;function&#x22;) {
          return
        }
        if (!isStandardSyntaxFunction(node)) {
          return
        }
        if (matchesStringOrRegExp(postcss.vendor.unprefixed(node.value).toLowerCase(), whitelist)) {
          return
        }
        report({
          message: messages.rejected(node.value),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.function-whitespace-after" id="apidoc.element.stylelint.rules.function-whitespace-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>function-whitespace-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function-whitespace-after = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const declString = decl.toString()

      styleSearch({
        source: declString,
        target: &#x22;)&#x22;,
        functionArguments: &#x22;only&#x22;,
      }, match =&#x3e; {
        checkClosingParen(declString, match.startIndex, decl)
      })
    })

    function checkClosingParen(source, index, node) {
      const nextChar = source[index + 1]
      if (expectation === &#x22;always&#x22;) {
        // Allow for the next character to be a single empty space,
        // another closing parenthesis, a comma, or the end of the value
        if (nextChar === &#x22; &#x22;) {
          return
        }
        if (nextChar === &#x22;\n&#x22;) {
          return
        }
        if (source.substr(index + 1, 2) === &#x22;\r\n&#x22;) {
          return
        }
        if (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {
          return
        }
        report({
          message: messages.expected,
          node,
          index: index + 1,
          result,
          ruleName,
        })
      } else if (expectation === &#x22;never&#x22;) {
        if (isWhitespace(nextChar)) {
          report({
            message: messages.rejected,
            node,
            index: index + 1,
            result,
            ruleName,
          })
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.indentation" id="apidoc.element.stylelint.rules.indentation">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>indentation
        <span class="apidocSignatureSpan">(space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indentation = function (space) {
  const options = arguments.length &#x3e; 1 &#x26;&#x26; arguments[1] !== undefined ? arguments[1] : {}

  const isTab = space === &#x22;tab&#x22;
  const indentChar = isTab ? &#x22;\t&#x22; : _.repeat(&#x22; &#x22;, space)
  const warningWord = isTab ? &#x22;tab&#x22; : &#x22;space&#x22;

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: space,
      possible: [
        _.isNumber,
        &#x22;tab&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        except: [
          &#x22;block&#x22;,
          &#x22;value&#x22;,
          &#x22;param&#x22;,
        ],
        ignore: [
          &#x22;value&#x22;,
          &#x22;param&#x22;,
          &#x22;inside-parens&#x22;,
        ],
        indentInsideParens: [
          &#x22;twice&#x22;,
          &#x22;once-at-root-twice-in-block&#x22;,
        ],
        indentClosingBrace: [_.isBoolean],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    // Cycle through all nodes using walk.
    root.walk(node =&#x3e; {
      const nodeLevel = indentationLevel(node)
      const expectedWhitespace = _.repeat(indentChar, nodeLevel)

      let before = (node.raws.before || &#x22;&#x22;)
      const after = (node.raws.after || &#x22;&#x22;)

      // Only inspect the spaces before the node
      // if this is the first node in root
      // or there is a newline in the `before` string.
      // (If there is no newline before a node,
      // there is no &#x22;indentation&#x22; to check.)
      const inspectBefore = root.first === node || before.indexOf(&#x22;\n&#x22;) !== -1

      // Cut out any * hacks from `before`
      before = before[before.length - 1] === &#x22;*&#x22; || before[before.length - 1] === &#x22;_&#x22; ? before.slice(0, before.length - 1) : before

      // Inspect whitespace in the `before` string that is
      // *after* the *last* newline character,
      // because anything besides that is not indentation for this node:
      // it is some other kind of separation, checked by some separate rule
      if (inspectBefore &#x26;&#x26; before.slice(before.lastIndexOf(&#x22;\n&#x22;) + 1) !== expectedWhitespace) {
        report({
          message: messages.expected(legibleExpectation(nodeLevel)),
          node,
          result,
          ruleName,
        })
      }

      // Only blocks have the `after` string to check.
      // Only inspect `after` strings that start with a newline;
      // otherwise there&#x27;s no indentation involved.
      // And check `indentClosingBrace` to see if it should be indented an extra level.
      const closingBraceLevel = options.indentClosingBrace ? nodeLevel + 1 : nodeLevel
      if (hasBlock(node) &#x26;&#x26; after &#x26;&#x26; after.indexOf(&#x22;\n&#x22;) !== -1 &#x26;&#x26; after.slice(after.lastIndexOf(&#x22;\n&#x22;) + 1) !== _.repeat(indentChar
, closingBraceLevel)) {
        report({
          message: messages.expected(legibleExpectation(closingBraceLevel)),
          node,
          index: node.toString().length - 1,
          result,
          ruleName,
        })
      }

      // If this is a declaration, check the value
      if (node.value) {
        checkValue(node, nodeLevel)
      }

      // If this is a rule, check the selector
      if (node.selector) {
        checkSelector(node, nodeLevel)
      }

      // If this is an at rule, check the params
      if (node.type === &#x22;atrule&#x22;) {
        checkAtRuleParams(node, nodeLevel)
      }
    })

    function indentationLevel(node) {
      const level = arguments.length &#x3e; 1 &#x26;&#x26; arguments[1] !== undefined ? arguments[1] : 0

      if (node.parent.type === &#x22;root&#x22;) {
        return level
      }

      let calculatedLevel

      // Indentation level equals the ancestor nodes
      // separating this node from root; so recursively
      // run this operation
      calculatedLevel = indentationLevel(node.parent, level + 1)

      // If options.except includes &#x22;block&#x22;,
      // blocks are taken down one from their calculated level
      // (all blocks are the same level as their parents)
      if (optionsMatches(options, &#x22;except&#x22;, &#x22;block&#x22;) &#x26;&#x26; (node.type === &#x22;rule&#x22; || node.type === &#x22;atrule&#x22;) &#x26;&#x26; hasBlock(node)) {
        calculatedLevel--
      }

      return calculatedLevel
    }

    function checkValue(decl, declLevel) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.keyframe-declaration-no-important" id="apidoc.element.stylelint.rules.keyframe-declaration-no-important">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>keyframe-declaration-no-important
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keyframe-declaration-no-important = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes =&#x3e; {
      atRuleKeyframes.walkDecls(decl =&#x3e; {
        if (!decl.important) {
          return
        }
        report({
          message: messages.rejected,
          node: decl,
          word: &#x22;important&#x22;,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.length-zero-no-unit" id="apidoc.element.stylelint.rules.length-zero-no-unit">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>length-zero-no-unit
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">length-zero-no-unit = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      check(blurComments(decl.toString()), decl)
    })

    root.walkAtRules(atRule =&#x3e; {
      const source = hasBlock(atRule) ? beforeBlockString(atRule, { noRawBefore: true }) : atRule.toString()
      check(source, atRule)
    })

    function check(value, node) {
      const ignorableIndexes = new Set()

      styleSearch({ source: value, target: &#x22;0&#x22; }, match =&#x3e; {
        const index = match.startIndex

        // Given a 0 somewhere in the full property value (not in a string, thanks
        // to styleSearch) we need to isolate the value that contains the zero.
        // To do so, we&#x27;ll find the last index before the 0 of a character that would
        // divide one value in a list from another, and the next index of such a
        // character; then we build a substring from those indexes, which we can
        // assess.

        // If a single value includes multiple 0&#x27;s (e.g. 100.01px), we don&#x27;t want
        // each 0 to be treated as a separate value, possibly resulting in multiple
        // warnings for the same value (e.g. 0.00px).
        //
        // This check prevents that from happening: we build and check against a
        // Set containing all the indexes that are part of a value already validated.
        if (ignorableIndexes.has(index)) {
          return
        }

        const prevValueBreakIndex = _.findLastIndex(value.substr(0, index), char =&#x3e; {
          return [
            &#x22; &#x22;,
            &#x22;,&#x22;,
            &#x22;)&#x22;,
            &#x22;(&#x22;,
            &#x22;#&#x22;,
          ].indexOf(char) !== -1
        })

        // Ignore hex colors
        if (value[prevValueBreakIndex] === &#x22;#&#x22;) {
          return
        }

        // If no prev break was found, this value starts at 0
        const valueWithZeroStart = prevValueBreakIndex === -1 ? 0 : prevValueBreakIndex + 1

        const nextValueBreakIndex = _.findIndex(value.substr(valueWithZeroStart), char =&#x3e; {
          return [
            &#x22; &#x22;,
            &#x22;,&#x22;,
            &#x22;)&#x22;,
          ].indexOf(char) !== -1
        })

        // If no next break was found, this value ends at the end of the string
        const valueWithZeroEnd = nextValueBreakIndex === -1 ? value.length : nextValueBreakIndex + valueWithZeroStart

        const valueWithZero = value.slice(valueWithZeroStart, valueWithZeroEnd)
        const parsedValue = valueParser.unit(valueWithZero)

        if (!parsedValue || parsedValue &#x26;&#x26; !parsedValue.unit) {
          return
        }

        // Add the indexes to ignorableIndexes so the same value will not
        // be checked multiple times.
        _.range(valueWithZeroStart, valueWithZeroEnd).forEach(i =&#x3e; ignorableIndexes.add(i))

        // Only pay attention if the value parses to 0
        // and units with lengths
        if (parseFloat(valueWithZero, 10) !== 0 || !keywordSets.lengthUnits.has(parsedValue.unit.toLowerCase())) {
          return
        }

        report({
          message: messages.rejected,
          node,
          index: valueWithZeroEnd - parsedValue.unit.length,
          result,
          ruleName,
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.max-empty-lines" id="apidoc.element.stylelint.rules.max-empty-lines">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>max-empty-lines
        <span class="apidocSignatureSpan">(max, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max-empty-lines = function (max, options) {
  const maxAdjacentNewlines = max + 1

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: _.isNumber,
    }, {
      actual: options,
      possible: {
        ignore: [
          &#x22;comments&#x22;,
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const rootString = root.toString()
    const repeatLFNewLines = _.repeat(&#x22;\n&#x22;, maxAdjacentNewlines)
    const repeatCRLFNewLines = _.repeat(&#x22;\r\n&#x22;, maxAdjacentNewlines)
    const ignoreComments = optionsMatches(options, &#x22;ignore&#x22;, &#x22;comments&#x22;)

    styleSearch({ source: rootString, target: &#x22;\n&#x22; }, match =&#x3e; {
      checkMatch(rootString, match.endIndex, root)
    })

    // We must check comments separately in order to accommodate stupid
    // `//`-comments from SCSS, which postcss-scss converts to `/* ... */`,
    // which adds to extra characters at the end, which messes up our
    // warning position
    if (!ignoreComments) {
      root.walkComments(comment =&#x3e; {
        const source = (comment.raws.left || &#x22;&#x22;) + comment.text + (comment.raws.right || &#x22;&#x22;)
        styleSearch({ source, target: &#x22;\n&#x22; }, match =&#x3e; {
          checkMatch(source, match.endIndex, comment, 2)
        })
      })
    }

    function checkMatch(source, matchEndIndex, node) {
      const offset = arguments.length &#x3e; 3 &#x26;&#x26; arguments[3] !== undefined ? arguments[3] : 0

      let violationIndex = false
      if (source.substr(matchEndIndex, maxAdjacentNewlines) === repeatLFNewLines) {
        violationIndex = matchEndIndex + maxAdjacentNewlines
      } else if (source.substr(matchEndIndex, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {
        violationIndex = matchEndIndex + maxAdjacentNewlines * 2
      }

      if (!violationIndex) {
        return
      }

      report({
        message: messages.expected(max),
        node,
        index: violationIndex + offset,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.max-line-length" id="apidoc.element.stylelint.rules.max-line-length">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>max-line-length
        <span class="apidocSignatureSpan">(maxLength, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max-line-length = function (maxLength, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: maxLength,
      possible: _.isNumber,
    }, {
      actual: options,
      possible: {
        ignore: [
          &#x22;non-comments&#x22;,
          &#x22;comments&#x22;,
        ],
        ignorePattern: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const rootString = root.source.input.css

    const ignoreNonComments = optionsMatches(options, &#x22;ignore&#x22;, &#x22;non-comments&#x22;)
    const ignoreComments = optionsMatches(options, &#x22;ignore&#x22;, &#x22;comments&#x22;)

    // Check first line
    checkNewline({ endIndex: 0 })

    // Check subsequent lines
    styleSearch({ source: rootString, target: [&#x22;\n&#x22;], comments: &#x22;check&#x22; }, checkNewline)

    function complain(index) {
      report({
        index,
        result,
        ruleName,
        message: messages.expected(maxLength),
        node: root,
      })
    }

    function checkNewline(match) {
      let nextNewlineIndex = rootString.indexOf(&#x22;\n&#x22;, match.endIndex)
      if (rootString[nextNewlineIndex - 1] === &#x22;\r&#x22;) {
        nextNewlineIndex -= 1
      }

      // Accommodate last line
      if (nextNewlineIndex === -1) {
        nextNewlineIndex = rootString.length
      }

      const rawLineLength = nextNewlineIndex - match.endIndex
      const lineText = rootString.slice(match.endIndex, nextNewlineIndex)

      if (optionsMatches(options, &#x22;ignorePattern&#x22;, lineText)) {
        return
      }

      const urlArgumentsLength = execall(/url\((.*)\)/ig, lineText).reduce((result, match) =&#x3e; {
        return result + _.get(match, &#x22;sub[0].length&#x22;, 0)
      }, 0)

      const importUrlsLength = execall(/\@import\s+([&#x27;&#x22;].*[&#x27;&#x22;])/ig, lineText).reduce((result, match) =&#x3e; {
        return result + _.get(match, &#x22;sub[0].length&#x22;, 0)
      }, 0)

      // If the line&#x27;s length is less than or equal to the specified
      // max, ignore it ... So anything below is liable to be complained about.
      // **Note that the length of any url arguments or import urls
      // are excluded from the calculation.**
      if (rawLineLength - urlArgumentsLength - importUrlsLength &#x3c;= maxLength) {
        return
      }

      const complaintIndex = nextNewlineIndex - 1

      if (ignoreComments) {
        if (match.insideComment) {
          return
        }

        // This trimming business is to notice when the line starts a
        // comment but that comment is indented, e.g.
        //<span class="apidocCodeCommentSpan">       /* something here */
</span>        const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2)
        if (nextTwoChars === &#x22;/*&#x22; || nextTwoChars === &#x22;//&#x22;) {
          return
        }
      }

      if (ignoreNonComments) {
        if (match.insideComment) {
          return complain(complaintIndex)
        }

        // This trimming business is to notice when the line starts a
        // comment but that comment is indented, e.g.
        //       /* something here */
        const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2)
        if (nextTwoChars !== &#x22;/*&#x22; &#x26;&#x26; nextTwoChars !== &#x22;//&#x22;) {
          return
        }
        return complain(complaintIndex)
      }

      // If there are no spaces besides initial (indent) spaces, ignore it
      const lineString = rootString.slice(match.endIndex, nextNewlineIndex)
      if (lineString.replace(/^\s+/, &#x22;&#x22;).indexOf(&#x22; &#x22;) === -1) {
        return
      }

      return complain(complaintIndex)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.max-nesting-depth" id="apidoc.element.stylelint.rules.max-nesting-depth">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>max-nesting-depth
        <span class="apidocSignatureSpan">(max, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max-nesting-depth = function (max, options) {
  const ignoreAtRulesWithoutDeclarationBlocks = optionsMatches(options, &#x22;ignore&#x22;, &#x22;at-rules-without-declaration-blocks&#x22;) || optionsMatches
(options, &#x22;ignore&#x22;, &#x22;blockless-at-rules&#x22;)
  const isIgnoreAtRule = node =&#x3e; node.type === &#x22;atrule&#x22; &#x26;&#x26; optionsMatches(options, &#x22;ignoreAtRules&#x22;, node.name)

  return (root, result) =&#x3e; {
    validateOptions(result, ruleName, {
      actual: max,
      possible: [_.isNumber],
    }, {
      optional: true,
      actual: options,
      possible: {
        ignore: [
          &#x22;at-rules-without-declaration-blocks&#x22;,
          &#x22;blockless-at-rules&#x22;,
        ],
        ignoreAtRules: [_.isString],
      },
    })

    if (optionsMatches(options, &#x22;ignore&#x22;, &#x22;at-rules-without-declaration-blocks&#x22;)) {
      result.warn((
        &#x22;&#x27;max-nesting-depth\&#x27;s&#x27; \&#x22;at-rules-without-declaration-blocks\&#x22; option has been deprecated and in 8.0 will be removed. Instead
 use the\&#x22;blockless-at-rules\&#x22; option.&#x22;
      ), {
        stylelintType: &#x22;deprecation&#x22;,
        stylelintReference: &#x22;https://stylelint.io/user-guide/rules/max-nesting-depth/&#x22;,
      })
    }

    root.walkRules(checkStatement)
    root.walkAtRules(checkStatement)

    function checkStatement(statement) {
      if (isIgnoreAtRule(statement)) {
        return
      }
      if (!hasBlock(statement)) {
        return
      }
      const depth = nestingDepth(statement)
      if (depth &#x3e; max) {
        report({
          ruleName,
          result,
          node: statement,
          message: messages.expected(max),
        })
      }
    }
  }

  function nestingDepth(node, level) {
    level = level || 0
    const parent = node.parent

    if (isIgnoreAtRule(parent)) {
      return 0
    }

    // The nesting depth level&#x27;s computation has finished
    // when this function, recursively called, receives
    // a node that is not nested -- a direct child of the
    // root node
    if (parent.type === &#x22;root&#x22; || parent.type === &#x22;atrule&#x22; &#x26;&#x26; parent.parent.type === &#x22;root&#x22;) {
      return level
    }

    if (ignoreAtRulesWithoutDeclarationBlocks &#x26;&#x26; node.type === &#x22;atrule&#x22; &#x26;&#x26; node.every(child =&#x3e; child.type !== &#x22;decl&#x22;)) {
      return nestingDepth(parent, level)
    }

    // Unless any of the conditions above apply, we want to
    // add 1 to the nesting depth level and then check the parent,
    // continuing to add and move up the hierarchy
    // until we hit the root node
    return nestingDepth(parent, level + 1)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-colon-space-after" id="apidoc.element.stylelint.rules.media-feature-colon-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-colon-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-colon-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    mediaFeatureColonSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-colon-space-before" id="apidoc.element.stylelint.rules.media-feature-colon-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-colon-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-colon-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    mediaFeatureColonSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-blacklist" id="apidoc.element.stylelint.rules.media-feature-name-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-blacklist = function (blacklist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode =&#x3e; {
        const parent = mediaFeatureNode.parent,
          sourceIndex = mediaFeatureNode.sourceIndex,
          value = mediaFeatureNode.value

        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
          return
        }

        if (!matchesStringOrRegExp(value.toLowerCase(), blacklist)) {
          return
        }

        report({
          index: atRuleParamIndex(atRule) + sourceIndex,
          message: messages.rejected(value),
          node: atRule,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-case" id="apidoc.element.stylelint.rules.media-feature-name-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-case = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode =&#x3e; {
        const parent = mediaFeatureNode.parent,
          sourceIndex = mediaFeatureNode.sourceIndex,
          value = mediaFeatureNode.value

        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
          return
        }

        const expectedFeatureName = expectation === &#x22;lower&#x22; ? value.toLowerCase() : value.toUpperCase()

        if (value === expectedFeatureName) {
          return
        }

        report({
          index: atRuleParamIndex(atRule) + sourceIndex,
          message: messages.expected(value, expectedFeatureName),
          node: atRule,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-no-unknown" id="apidoc.element.stylelint.rules.media-feature-name-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-no-unknown = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreMediaFeatureNames: [_.isString],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode =&#x3e; {
        const parent = mediaFeatureNode.parent,
          sourceIndex = mediaFeatureNode.sourceIndex,
          value = mediaFeatureNode.value

        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
          return
        }

        if (optionsMatches(options, &#x22;ignoreMediaFeatureNames&#x22;, value)) {
          return
        }

        if (postcss.vendor.prefix(value) || keywordSets.mediaFeatureNames.has(value.toLowerCase())) {
          return
        }

        report({
          index: atRuleParamIndex(atRule) + sourceIndex,
          message: messages.rejected(value),
          node: atRule,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-no-vendor-prefix" id="apidoc.element.stylelint.rules.media-feature-name-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-no-vendor-prefix = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      const params = atRule.params

      if (!isAutoprefixable.mediaFeatureName(params)) {
        return
      }
      const matches = atRule.toString().match(/[a-z-]+device-pixel-ratio/ig)

      if (!matches) { return }

      matches.forEach(match =&#x3e; {
        report({
          message: messages.rejected,
          node: atRule,
          word: match,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-name-whitelist" id="apidoc.element.stylelint.rules.media-feature-name-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-name-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-name-whitelist = function (whitelist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode =&#x3e; {
        const parent = mediaFeatureNode.parent,
          sourceIndex = mediaFeatureNode.sourceIndex,
          value = mediaFeatureNode.value

        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
          return
        }

        if (matchesStringOrRegExp(value.toLowerCase(), whitelist)) {
          return
        }

        report({
          index: atRuleParamIndex(atRule) + sourceIndex,
          message: messages.rejected(value),
          node: atRule,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-no-missing-punctuation" id="apidoc.element.stylelint.rules.media-feature-no-missing-punctuation">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-no-missing-punctuation
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-no-missing-punctuation = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      &#x22;&#x27;media-feature-no-missing-punctuation&#x27; has been deprecated and in 8.0 will be removed.&#x22;
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: &#x22;https://stylelint.io/user-guide/rules/media-feature-no-missing-punctuation/&#x22;,
    })

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      execall(/\((.*?)\)/g, atRule.params).forEach(mediaFeatureMatch =&#x3e; {
        if (!isStandardSyntaxMediaFeature(mediaFeatureMatch.match)) {
          return
        }

        const splitMediaFeature = mediaFeatureMatch.sub[0].trim().split(/\s+/)
        if (splitMediaFeature.length === 1) {
          return
        }

        // Ignore the last one
        for (let i = 0, l = splitMediaFeature.length - 1; i &#x3c; l; i++) {
          const mediaFeaturePart = splitMediaFeature[i]

          // This part is valid if it is punctuation,
          // it ends with punctuation,
          // the next part is punctuation,
          // or the next part begins with punctuation
          if (isPunctuation(mediaFeaturePart)) {
            continue
          }
          if (endsWithPunctuation(mediaFeaturePart)) {
            continue
          }
          const nextPart = splitMediaFeature[i + 1]
          if (isPunctuation(nextPart)) {
            continue
          }
          if (startsWithPunctuation(nextPart)) {
            continue
          }

          return report({
            result,
            ruleName,
            message: messages.rejected,
            node: atRule,
            index: atRuleParamIndex(atRule) + mediaFeatureMatch.index,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-parentheses-space-inside" id="apidoc.element.stylelint.rules.media-feature-parentheses-space-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-parentheses-space-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-parentheses-space-inside = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      // If there are comments in the params, the complete string
      // will be at atRule.raws.params.raw
      const params = _.get(atRule, &#x22;raws.params.raw&#x22;, atRule.params)
      const indexBoost = atRuleParamIndex(atRule)

      styleSearch({ source: params, target: &#x22;(&#x22; }, match =&#x3e; {
        const nextCharIsSpace = params[match.startIndex + 1] === &#x22; &#x22;
        if (nextCharIsSpace &#x26;&#x26; expectation === &#x22;never&#x22;) {
          report({
            message: messages.rejectedOpening,
            node: atRule,
            index: match.startIndex + 1 + indexBoost,
            result,
            ruleName,
          })
        }
        if (!nextCharIsSpace &#x26;&#x26; expectation === &#x22;always&#x22;) {
          report({
            message: messages.expectedOpening,
            node: atRule,
            index: match.startIndex + 1 + indexBoost,
            result,
            ruleName,
          })
        }
      })

      styleSearch({ source: params, target: &#x22;)&#x22; }, match =&#x3e; {
        const prevCharIsSpace = params[match.startIndex - 1] === &#x22; &#x22;
        if (prevCharIsSpace &#x26;&#x26; expectation === &#x22;never&#x22;) {
          report({
            message: messages.rejectedClosing,
            node: atRule,
            index: match.startIndex - 1 + indexBoost,
            result,
            ruleName,
          })
        }
        if (!prevCharIsSpace &#x26;&#x26; expectation === &#x22;always&#x22;) {
          report({
            message: messages.expectedClosing,
            node: atRule,
            index: match.startIndex - 1 + indexBoost,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-range-operator-space-after" id="apidoc.element.stylelint.rules.media-feature-range-operator-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-range-operator-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-range-operator-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      findMediaOperator(atRule, checkAfterOperator)
    })

    function checkAfterOperator(match, params, node) {
      const endIndex = match.index + match[1].length

      checker.after({
        source: params,
        index: endIndex,
        err: m =&#x3e; {
          report({
            message: m,
            node,
            index: endIndex + atRuleParamIndex(node) + 1,
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-feature-range-operator-space-before" id="apidoc.element.stylelint.rules.media-feature-range-operator-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-feature-range-operator-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-feature-range-operator-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; {
      findMediaOperator(atRule, checkBeforeOperator)
    })

    function checkBeforeOperator(match, params, node) {
      // The extra `+ 1` is because the match itself contains
      // the character before the operator
      checker.before({
        source: params,
        index: match.index + 1,
        err: m =&#x3e; {
          report({
            message: m,
            node,
            index: match.index + atRuleParamIndex(node),
            result,
            ruleName,
          })
        },
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-query-list-comma-newline-after" id="apidoc.element.stylelint.rules.media-query-list-comma-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-query-list-comma-newline-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    // Only check for the newline after the comma, while allowing
    // arbitrary indentation after the newline
    mediaQueryListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.afterOneOnly,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-query-list-comma-newline-before" id="apidoc.element.stylelint.rules.media-query-list-comma-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-query-list-comma-newline-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }
    mediaQueryListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.beforeAllowingIndentation,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-query-list-comma-space-after" id="apidoc.element.stylelint.rules.media-query-list-comma-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-query-list-comma-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }
    mediaQueryListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.media-query-list-comma-space-before" id="apidoc.element.stylelint.rules.media-query-list-comma-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>media-query-list-comma-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">media-query-list-comma-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    mediaQueryListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-browser-hacks" id="apidoc.element.stylelint.rules.no-browser-hacks">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-browser-hacks
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-browser-hacks = function (on, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      optional: true,
      actual: options,
      possible: {
        browsers: [_.isString],
      },
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed. Use &#x27;stylelint-no-browser-hacks&#x27; plugin instead.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    const stylehacksOptions = { lint: true }
    if (options &#x26;&#x26; options.browsers) {
      stylehacksOptions.browsers = options.browsers
    }

    const stylehacksResult = new Result()
    stylehacks(stylehacksOptions)(root, stylehacksResult)
    stylehacksResult.warnings().forEach(stylehacksWarning =&#x3e; {
      const message = messages.rejected(stylehacksWarning.identifier, stylehacksWarning.hack)
      report({
        ruleName,
        result,
        message,
        node: stylehacksWarning.node,
        line: stylehacksWarning.line,
        column: stylehacksWarning.column,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-descending-specificity" id="apidoc.element.stylelint.rules.no-descending-specificity">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-descending-specificity
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-descending-specificity = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const selectorContextLookup = nodeContextLookup()

    root.walkRules(rule =&#x3e; {
      // Ignore custom property set `--foo: {};`
      if (isCustomPropertySet(rule)) {
        return
      }

      const comparisonContext = selectorContextLookup.getContext(rule, findAtRuleContext(rule))

      rule.selectors.forEach(selector =&#x3e; {
        const trimSelector = selector.trim()
        // Ignore `.selector, { }`
        if (trimSelector === &#x22;&#x22;) {
          return
        }

        // The edge-case of duplicate selectors will act acceptably
        const index = rule.selector.indexOf(trimSelector)
        // Resolve any nested selectors before checking
        resolvedNestedSelector(selector, rule).forEach(resolvedSelector =&#x3e; {
          parseSelector(resolvedSelector, result, rule, s =&#x3e; checkSelector(s, rule, index, comparisonContext))
        })
      })
    })

    function checkSelector(selectorNode, rule, sourceIndex, comparisonContext) {
      const selector = selectorNode.toString()
      const referenceSelectorNode = lastCompoundSelectorWithoutPseudoClasses(selectorNode)
      const selectorSpecificity = specificity.calculate(selector)[0].specificityArray
      const entry = { selector, specificity: selectorSpecificity }

      if (!comparisonContext.has(referenceSelectorNode)) {
        comparisonContext.set(referenceSelectorNode, [entry])
        return
      }

      const priorComparableSelectors = comparisonContext.get(referenceSelectorNode)

      priorComparableSelectors.forEach(priorEntry =&#x3e; {
        if (specificity.compare(selectorSpecificity, priorEntry.specificity) === -1) {
          report({
            ruleName,
            result,
            node: rule,
            message: messages.rejected(selector, priorEntry.selector),
            index: sourceIndex,
          })
        }
      })

      priorComparableSelectors.push(entry)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-duplicate-selectors" id="apidoc.element.stylelint.rules.no-duplicate-selectors">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-duplicate-selectors
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-duplicate-selectors = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    // The top level of this map will be rule sources.
    // Each source maps to another map, which maps rule parents to a set of selectors.
    // This ensures that selectors are only checked against selectors
    // from other rules that share the same parent and the same source.
    const selectorContextLookup = nodeContextLookup()

    root.walkRules(rule =&#x3e; {
      if (isKeyframeRule(rule)) {
        return
      }

      const contextSelectorSet = selectorContextLookup.getContext(rule, findAtRuleContext(rule))
      const resolvedSelectors = rule.selectors.reduce((result, selector) =&#x3e; {
        return _.union(result, resolvedNestedSelector(selector, rule))
      }, [])
      const normalizedSelectorList = resolvedSelectors.map(normalizeSelector)
      const selectorLine = rule.source.start.line

      // Complain if the same selector list occurs twice

      // Sort the selectors list so that the order of the constituents
      // doesn&#x27;t matter
      const sortedSelectorList = normalizedSelectorList.slice().sort().join(&#x22;,&#x22;)
      if (contextSelectorSet.has(sortedSelectorList)) {
        // If the selector isn&#x27;t nested we can use its raw value; otherwise,
        // we have to approximate something for the message -- which is close enough
        const isNestedSelector = resolvedSelectors.join(&#x22;,&#x22;) !== rule.selectors.join(&#x22;,&#x22;)
        const selectorForMessage = isNestedSelector ? resolvedSelectors.join(&#x22;, &#x22;) : rule.selector
        const previousDuplicatePosition = contextSelectorSet.get(sortedSelectorList)

        return report({
          result,
          ruleName,
          node: rule,
          message: messages.rejected(selectorForMessage, previousDuplicatePosition),
        })
      }

      contextSelectorSet.set(sortedSelectorList, selectorLine)

      // Or complain if one selector list contains the same selector more than one
      rule.selectors.forEach((selector, i) =&#x3e; {
        if (_.includes(normalizedSelectorList.slice(0, i), normalizeSelector(selector))) {
          report({
            result,
            ruleName,
            node: rule,
            message: messages.rejected(selector, selectorLine),
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-empty-source" id="apidoc.element.stylelint.rules.no-empty-source">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-empty-source
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-empty-source = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    if (!/^\s*$/.test(root.toString())) {
      return
    }

    report({
      message: messages.rejected,
      node: root,
      result,
      ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-eol-whitespace" id="apidoc.element.stylelint.rules.no-eol-whitespace">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-eol-whitespace
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-eol-whitespace = function (on, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: on,
    }, {
      optional: true,
      actual: options,
      possible: {
        ignore: [&#x22;empty-lines&#x22;],
      },
    })
    if (!validOptions) {
      return
    }

    const rootString = root.toString()
    styleSearch({
      source: rootString,
      target: [
        &#x22;\n&#x22;,
        &#x22;\r&#x22;,
      ],
      comments: &#x22;check&#x22;,
    }, match =&#x3e; {
      // If the character before newline is not whitespace, ignore
      if (!whitespacesToReject.has(rootString[match.startIndex - 1])) {
        return
      }

      if (optionsMatches(options, &#x22;ignore&#x22;, &#x22;empty-lines&#x22;)) {
        // If there is only whitespace between the previous newline and
        // this newline, ignore
        const lineBefore = rootString.substring(match.startIndex + 1, rootString.lastIndexOf(&#x22;\n&#x22;, match.startIndex - 1))
        if (isOnlyWhitespace(lineBefore)) {
          return
        }
      }

      report({
        message: messages.rejected,
        node: root,
        index: match.startIndex - 1,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-extra-semicolons" id="apidoc.element.stylelint.rules.no-extra-semicolons">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-extra-semicolons
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-extra-semicolons = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const rawAfterRoot = root.raws.after

    if (rawAfterRoot &#x26;&#x26; rawAfterRoot.trim().length !== 0) {
      styleSearch({ source: rawAfterRoot, target: &#x22;;&#x22; }, match =&#x3e; {
        complain(root.toString().length - rawAfterRoot.length + match.startIndex)
      })
    }

    root.walk(node =&#x3e; {
      let rawBeforeNode = node.raws.before

      if (rawBeforeNode &#x26;&#x26; rawBeforeNode.trim().length !== 0) {
        let allowedSemi = 0

        // Forbid semicolon before first custom properties sets
        if (isCustomPropertySet(node) &#x26;&#x26; node.parent.index(node) &#x3e; 0) {
          allowedSemi = 1
        }

        const next = node.next()

        // Ignore semicolon before comment if next node is custom properties sets or comment
        if (node.type === &#x22;comment&#x22; &#x26;&#x26; next
          &#x26;&#x26; (isCustomPropertySet(next) &#x26;&#x26; node.parent.index(next) &#x3e; 0 || next.type === &#x22;comment&#x22;)
        ) {
          allowedSemi = 1
        }

        const prev = node.prev()

        // Adding previous node string to custom properties set if previous node is comment
        if (isCustomPropertySet(node) &#x26;&#x26; node.parent.index(node) &#x3e; 0 &#x26;&#x26; prev &#x26;&#x26; prev.type === &#x22;comment&#x22;) {
          rawBeforeNode = prev.toString() + rawBeforeNode
          allowedSemi = 0
        }

        styleSearch({ source: rawBeforeNode, target: &#x22;;&#x22; }, (match, count) =&#x3e; {
          if (count === allowedSemi) {
            return
          }

          complain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex)
        })
      }

      const rawAfterNode = node.raws.after

      if (rawAfterNode &#x26;&#x26; rawAfterNode.trim().length !== 0) {
        let allowedSemi = 0

        if (!hasEmptyBlock(node) &#x26;&#x26; isCustomPropertySet(node.nodes[node.nodes.length - 1])) {
          allowedSemi = 1
        }

        styleSearch({ source: rawAfterNode, target: &#x22;;&#x22; }, (match, count) =&#x3e; {
          if (count === allowedSemi) {
            return
          }

          const index = getOffsetByNode(node) + node.toString().length - 1 - rawAfterNode.length + match.startIndex
          complain(index)
        })
      }
    })

    function complain(index) {
      report({
        message: messages.rejected,
        node: root,
        index,
        result,
        ruleName,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-indistinguishable-colors" id="apidoc.element.stylelint.rules.no-indistinguishable-colors">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-indistinguishable-colors
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-indistinguishable-colors = function (on, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      optional: true,
      actual: options,
      possible: {
        ignore: isValidHex,
        threshold: x =&#x3e; _.isNumber(x) &#x26;&#x26; x &#x3e;= 0 &#x26;&#x26; x &#x3c;= 100,
        whitelist: x =&#x3e; _.isArray(x) &#x26;&#x26; x.every(isValidHex),
      },
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    const colorguardResult = new Result()
    colorguard(options)(root, colorguardResult)
    colorguardResult.warnings().forEach(colorguardWarning =&#x3e; {
      const message = messages.rejected(colorguardWarning.secondColor, colorguardWarning.firstColor)
      report({
        ruleName,
        result,
        message,
        node: colorguardWarning.node,
        index: colorguardWarning.node.toString().indexOf(colorguardWarning.secondColor),
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-invalid-double-slash-comments" id="apidoc.element.stylelint.rules.no-invalid-double-slash-comments">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-invalid-double-slash-comments
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-invalid-double-slash-comments = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (decl.prop.indexOf(&#x22;//&#x22;) === 0) {
        report({
          message: messages.rejected,
          node: decl,
          result,
          ruleName,
        })
      }
    })
    root.walkRules(rule =&#x3e; {
      rule.selectors.forEach(selector =&#x3e; {
        if (selector.indexOf(&#x22;//&#x22;) === 0) {
          report({
            message: messages.rejected,
            node: rule,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-missing-end-of-source-newline" id="apidoc.element.stylelint.rules.no-missing-end-of-source-newline">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-missing-end-of-source-newline
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-missing-end-of-source-newline = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const sourceCss = root.source.input.css
    if (sourceCss === &#x22;&#x22; || sourceCss.slice(-1) === &#x22;\n&#x22;) {
      return
    }

    report({
      message: messages.rejected,
      node: root,
      index: sourceCss.length - 1,
      result,
      ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-unknown-animations" id="apidoc.element.stylelint.rules.no-unknown-animations">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-unknown-animations
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-unknown-animations = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const declaredAnimations = new Set()
    root.walkAtRules(/(-(moz|webkit)-)?keyframes/i, atRule =&#x3e; {
      declaredAnimations.add(atRule.params)
    })

    root.walkDecls(decl =&#x3e; {
      if (decl.prop.toLowerCase() === &#x22;animation&#x22; || decl.prop.toLowerCase() === &#x22;animation-name&#x22;) {
        const animationNames = findAnimationName(decl.value)

        if (animationNames.length === 0) {
          return
        }

        animationNames.forEach(animationNameNode =&#x3e; {
          if (keywordSets.animationNameKeywords.has(animationNameNode.value.toLowerCase())) {
            return
          }
          if (declaredAnimations.has(animationNameNode.value)) {
            return
          }

          report({
            result,
            ruleName,
            message: messages.rejected(animationNameNode.value),
            node: decl,
            index: declarationValueIndex(decl) + animationNameNode.sourceIndex,
          })
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.no-unsupported-browser-features" id="apidoc.element.stylelint.rules.no-unsupported-browser-features">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>no-unsupported-browser-features
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">no-unsupported-browser-features = function (on, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      optional: true,
      actual: options,
      possible: {
        browsers: [_.isString],
        ignore: [_.isString],
      },
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    const doiuseOptions = {}

    if (options &#x26;&#x26; options.browsers) {
      doiuseOptions.browsers = options.browsers
    }

    if (options &#x26;&#x26; options.ignore) {
      doiuseOptions.ignore = options.ignore
    }

    const doiuseResult = new Result()
    doiuse(doiuseOptions).postcss(root, doiuseResult)
    doiuseResult.warnings().forEach(doiuseWarning =&#x3e; {
      report({
        ruleName,
        result,
        message: messages.rejected(cleanDoiuseWarningText(doiuseWarning.text)),
        node: doiuseWarning.node,
        line: doiuseWarning.line,
        column: doiuseWarning.column,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.number-leading-zero" id="apidoc.element.stylelint.rules.number-leading-zero">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>number-leading-zero
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number-leading-zero = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      if (atRule.name.toLowerCase() === &#x22;import&#x22;) {
        return
      }

      check(atRule, atRule.params, atRuleParamIndex)
    })

    root.walkDecls(decl =&#x3e; check(decl, decl.value, declarationValueIndex))

    function check(node, value, getIndex) {
      // Get out quickly if there are no periods
      if (value.indexOf(&#x22;.&#x22;) === -1) {
        return
      }

      valueParser(value).walk(valueNode =&#x3e; {
        // Ignore `url` function
        if (valueNode.type === &#x22;function&#x22; &#x26;&#x26; valueNode.value.toLowerCase() === &#x22;url&#x22;) {
          return false
        }

        // Ignore strings, comments, etc
        if (valueNode.type !== &#x22;word&#x22;) {
          return
        }

        // Check leading zero
        if (expectation === &#x22;always&#x22;) {
          const match = /(?:\D|^)(\.\d+)/.exec(valueNode.value)

          if (match === null) {
            return
          }

          // The regexp above consists of 2 capturing groups (or capturing parentheses).
          // We need the index of the second group. This makes sanse when we have &#x22;-.5&#x22; as an input
          // for regex. And we need the index of &#x22;.5&#x22;.
          const capturingGroupIndex = match[0].length - match[1].length
          complain(messages.expected, node, getIndex(node) + valueNode.sourceIndex + match.index + capturingGroupIndex)
        }

        if (expectation === &#x22;never&#x22;) {
          const match = /(?:\D|^)(0+\.\d+)/.exec(valueNode.value)

          if (match === null) {
            return
          }

          const capturingGroupIndex = match[0].length - match[1].length
          complain(messages.rejected, node, getIndex(node) + valueNode.sourceIndex + match.index + capturingGroupIndex)
        }
      })
    }

    function complain(message, node, index) {
      report({
        result,
        ruleName,
        message,
        node,
        index,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.number-max-precision" id="apidoc.element.stylelint.rules.number-max-precision">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>number-max-precision
        <span class="apidocSignatureSpan">(precision)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number-max-precision = function (precision) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: precision,
      possible: [_.isNumber],
    })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      if (atRule.name.toLowerCase() === &#x22;import&#x22;) {
        return
      }

      check(atRule, atRule.params, atRuleParamIndex)
    })

    root.walkDecls(decl =&#x3e; check(decl, decl.value, declarationValueIndex))

    function check(node, value, getIndex) {
      // Get out quickly if there are no periods
      if (value.indexOf(&#x22;.&#x22;) === -1) {
        return
      }

      valueParser(value).walk(valueNode =&#x3e; {
        // Ignore `url` function
        if (valueNode.type === &#x22;function&#x22; &#x26;&#x26; valueNode.value.toLowerCase() === &#x22;url&#x22;) {
          return false
        }

        // Ignore strings, comments, etc
        if (valueNode.type !== &#x22;word&#x22;) {
          return
        }

        const match = /\d*\.(\d+)/.exec(valueNode.value)

        if (match === null) {
          return
        }

        if (match[1].length &#x3c;= precision) {
          return
        }

        report({
          result,
          ruleName,
          node,
          index: getIndex(node) + valueNode.sourceIndex + match.index,
          message: messages.expected(parseFloat(match[0]), precision),
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.number-no-trailing-zeros" id="apidoc.element.stylelint.rules.number-no-trailing-zeros">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>number-no-trailing-zeros
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number-no-trailing-zeros = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkAtRules(atRule =&#x3e; {
      if (atRule.name.toLowerCase() === &#x22;import&#x22;) {
        return
      }

      check(atRule, atRule.params, atRuleParamIndex)
    })

    root.walkDecls(decl =&#x3e; check(decl, decl.value, declarationValueIndex))

    function check(node, value, getIndex) {
      // Get out quickly if there are no periods
      if (value.indexOf(&#x22;.&#x22;) === -1) {
        return
      }

      valueParser(value).walk(valueNode =&#x3e; {
        // Ignore `url` function
        if (valueNode.type === &#x22;function&#x22; &#x26;&#x26; valueNode.value.toLowerCase() === &#x22;url&#x22;) {
          return false
        }

        // Ignore strings, comments, etc
        if (valueNode.type !== &#x22;word&#x22;) {
          return
        }

        const match = /(\.\d*)0+(?:\D|$)/.exec(valueNode.value)

        if (match === null) {
          return
        }

        report({
          message: messages.rejected,
          node,
          index: getIndex(node) + valueNode.sourceIndex + match.index + match[1].length,
          result,
          ruleName,
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-blacklist" id="apidoc.element.stylelint.rules.property-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-blacklist = function (blacklist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop

      if (!isStandardSyntaxProperty(prop)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }
      if (!matchesStringOrRegExp(postcss.vendor.unprefixed(prop), blacklist)) {
        return
      }

      report({
        message: messages.rejected(prop),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-case" id="apidoc.element.stylelint.rules.property-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-case = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop

      if (!isStandardSyntaxProperty(prop)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }

      const expectedProp = expectation === &#x22;lower&#x22; ? prop.toLowerCase() : prop.toUpperCase()
      if (prop === expectedProp) {
        return
      }

      report({
        message: messages.expected(prop, expectedProp),
        node: decl,
        ruleName,
        result,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-no-unknown" id="apidoc.element.stylelint.rules.property-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-no-unknown = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreProperties: [_.isString],
        checkPrefixed: _.isBoolean,
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    const shouldCheckPrefixed = _.get(options, &#x22;checkPrefixed&#x22;)

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop

      if (!isStandardSyntaxProperty(prop)) {
        return
      }
      if (!isStandardSyntaxDeclaration(decl)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }

      if (!shouldCheckPrefixed &#x26;&#x26; postcss.vendor.prefix(prop)) {
        return
      }

      if (optionsMatches(options, &#x22;ignoreProperties&#x22;, prop)) {
        return
      }

      if (properties.indexOf(prop.toLowerCase()) !== -1) {
        return
      }

      report({
        message: messages.rejected(prop),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-no-vendor-prefix" id="apidoc.element.stylelint.rules.property-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-no-vendor-prefix = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop

      // Make sure there&#x27;s a vendor prefix,
      // but this isn&#x27;t a custom property

      if (prop[0] !== &#x22;-&#x22; || prop[1] === &#x22;-&#x22;) {
        return
      }

      if (!isAutoprefixable.property(prop)) {
        return
      }
      report({
        message: messages.rejected(prop),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.property-whitelist" id="apidoc.element.stylelint.rules.property-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>property-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property-whitelist = function (whitelist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop

      if (!isStandardSyntaxProperty(prop)) {
        return
      }
      if (isCustomProperty(prop)) {
        return
      }
      if (matchesStringOrRegExp(postcss.vendor.unprefixed(prop), whitelist)) {
        return
      }

      report({
        message: messages.rejected(prop),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.root-no-standard-properties" id="apidoc.element.stylelint.rules.root-no-standard-properties">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>root-no-standard-properties
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">root-no-standard-properties = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed. Instead use the community &#x27;stylelint-suitcss&#x27; plugin pack.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&#x3e; {
      if (rule.selector.toLowerCase().indexOf(&#x22;:root&#x22;) === -1) {
        return
      }
      parseSelector(rule.selector, result, rule, checkSelector)

      function checkSelector(selectorAST) {
        if (ignoreRule(selectorAST)) {
          return
        }

        rule.each(function (node) {
          if (node.type !== &#x22;decl&#x22;) {
            return
          }

          const prop = node.prop

          if (!isStandardSyntaxProperty(prop)) {
            return
          }
          if (isCustomProperty(prop)) {
            return
          }

          report({
            message: messages.rejected(prop),
            node,
            result,
            ruleName,
          })
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.rule-empty-line-before" id="apidoc.element.stylelint.rules.rule-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rule-empty-line-before = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignore: [
          &#x22;after-comment&#x22;,
          &#x22;inside-block&#x22;,
        ],
        except: [
          &#x22;after-rule&#x22;,
          &#x22;after-single-line-comment&#x22;,
          &#x22;first-nested&#x22;,
          &#x22;inside-block-and-after-rule&#x22;,
        ],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      // Ignore the first node
      if (rule === root.first) {
        return
      }

      let expectEmptyLineBefore = expectation.indexOf(&#x22;always&#x22;) !== -1 ? true : false

      // Optionally ignore the expectation if a comment precedes this node
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;after-comment&#x22;)
        &#x26;&#x26; rule.prev()
        &#x26;&#x26; rule.prev().type === &#x22;comment&#x22;
      ) {
        return
      }

      // Optionally ignore the expectation if inside a block
      if (
        optionsMatches(options, &#x22;ignore&#x22;, &#x22;inside-block&#x22;)
        &#x26;&#x26; rule.parent !== root
      ) {
        return
      }

      // Ignore if the expectation is for multiple and the rule is single-line
      if (
        expectation.indexOf(&#x22;multi-line&#x22;) !== -1
        &#x26;&#x26; isSingleLineString(rule.toString())
      ) {
        return
      }

      // Optionally reverse the expectation for the first nested node
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;first-nested&#x22;)
        &#x26;&#x26; rule === rule.parent.first
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a rule precedes this node
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;after-rule&#x22;)
        &#x26;&#x26; rule.prev()
        &#x26;&#x26; rule.prev().type === &#x22;rule&#x22;
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation if a rule precedes this node and is inside a block
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;inside-block-and-after-rule&#x22;)
        &#x26;&#x26; rule.prev()
        &#x26;&#x26; rule.prev().type === &#x22;rule&#x22;
        &#x26;&#x26; rule.parent !== root
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      // Optionally reverse the expectation for single line comments
      if (
        optionsMatches(options, &#x22;except&#x22;, &#x22;after-single-line-comment&#x22;)
        &#x26;&#x26; rule.prev()
        &#x26;&#x26; rule.prev().type === &#x22;comment&#x22;
        &#x26;&#x26; isSingleLineString(rule.prev().toString())
      ) {
        expectEmptyLineBefore = !expectEmptyLineBefore
      }

      const hasEmptyLineBefore = hasEmptyLine(rule.raws.before)

      // Return if the expectation is met
      if (expectEmptyLineBefore === hasEmptyLineBefore) {
        return
      }

      const message = expectEmptyLineBefore ? messages.expected : messages.rejected

      report({
        message,
        node: rule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.rule-nested-empty-line-before" id="apidoc.element.stylelint.rules.rule-nested-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-nested-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rule-nested-empty-line-before = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignore: [&#x22;after-comment&#x22;],
        except: [
          &#x22;first-nested&#x22;,
          &#x22;after-comment&#x22;,
          &#x22;after-rule&#x22;,
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed. Instead use &#x27;rule-empty-line-before&#x27;.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      // Only attend to nested rule sets
      if (rule.parent === root) {
        return
      }

      checkRuleEmptyLineBefore({ rule, expectation, options, result, messages, checkedRuleName: ruleName })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.rule-non-nested-empty-line-before" id="apidoc.element.stylelint.rules.rule-non-nested-empty-line-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>rule-non-nested-empty-line-before
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rule-non-nested-empty-line-before = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignore: [&#x22;after-comment&#x22;],
        except: [&#x22;after-single-line-comment&#x22;],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed. Instead use &#x27;rule-empty-line-before&#x27;.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      // Ignore nested rule sets
      if (rule.parent !== root) {
        return
      }

      // Ignore the first node
      if (rule === root.first) {
        return
      }

      checkRuleEmptyLineBefore({ rule, expectation, options, result, messages, checkedRuleName: ruleName })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-brackets-space-inside" id="apidoc.element.stylelint.rules.selector-attribute-brackets-space-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-brackets-space-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-brackets-space-inside = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf(&#x22;[&#x22;) === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkAttributes(attributeNode =&#x3e; {
          const attributeSelectorString = attributeNode.toString()

          styleSearch({ source: attributeSelectorString, target: &#x22;[&#x22; }, match =&#x3e; {
            const nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === &#x22; &#x22;
            const index = attributeNode.sourceIndex + match.startIndex + 1
            if (nextCharIsSpace &#x26;&#x26; expectation === &#x22;never&#x22;) {
              complain(messages.rejectedOpening, index)
            }
            if (!nextCharIsSpace &#x26;&#x26; expectation === &#x22;always&#x22;) {
              complain(messages.expectedOpening, index)
            }
          })

          styleSearch({ source: attributeSelectorString, target: &#x22;]&#x22; }, match =&#x3e; {
            const prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === &#x22; &#x22;
            const index = attributeNode.sourceIndex + match.startIndex - 1
            if (prevCharIsSpace &#x26;&#x26; expectation === &#x22;never&#x22;) {
              complain(messages.rejectedClosing, index)
            }
            if (!prevCharIsSpace &#x26;&#x26; expectation === &#x22;always&#x22;) {
              complain(messages.expectedClosing, index)
            }
          })
        })
      })

      function complain(message, index) {
        report({
          message,
          index,
          result,
          ruleName,
          node: rule,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-operator-blacklist" id="apidoc.element.stylelint.rules.selector-attribute-operator-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-blacklist
        <span class="apidocSignatureSpan">(blacklistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-operator-blacklist = function (blacklistInput) {
  const blacklist = [].concat(blacklistInput)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf(&#x22;[&#x22;) === -1 || rule.selector.indexOf(&#x22;=&#x22;) === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkAttributes(attributeNode =&#x3e; {
          const operator = attributeNode.operator

          if (!operator || operator &#x26;&#x26; blacklist.indexOf(operator) === -1) {
            return
          }

          report({
            message: messages.rejected(operator),
            node: rule,
            index: attributeNode.attribute.length + 1,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-operator-space-after" id="apidoc.element.stylelint.rules.selector-attribute-operator-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-operator-space-after = function (expectation) {
  return (root, result) =&#x3e; {
    const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    selectorAttributeOperatorSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
      checkBeforeOperator: false,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-operator-space-before" id="apidoc.element.stylelint.rules.selector-attribute-operator-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-operator-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    selectorAttributeOperatorSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
      checkBeforeOperator: true,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-operator-whitelist" id="apidoc.element.stylelint.rules.selector-attribute-operator-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-operator-whitelist
        <span class="apidocSignatureSpan">(whitelistInput)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-operator-whitelist = function (whitelistInput) {
  const whitelist = [].concat(whitelistInput)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf(&#x22;[&#x22;) === -1 || rule.selector.indexOf(&#x22;=&#x22;) === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkAttributes(attributeNode =&#x3e; {
          const operator = attributeNode.operator

          if (!operator || operator &#x26;&#x26; whitelist.indexOf(operator) !== -1) {
            return
          }

          report({
            message: messages.rejected(operator),
            node: rule,
            index: attributeNode.attribute.length + 1,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-attribute-quotes" id="apidoc.element.stylelint.rules.selector-attribute-quotes">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-attribute-quotes
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-attribute-quotes = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf(&#x22;[&#x22;) === -1 || rule.selector.indexOf(&#x22;=&#x22;) === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkAttributes(attributeNode =&#x3e; {
          if (!attributeNode.operator) {
            return
          }

          const attributeSelectorString = attributeNode.toString()

          if (!attributeNode.quoted &#x26;&#x26; expectation === &#x22;always&#x22;) {
            complain(messages.expected(attributeNode.raws.unquoted), attributeNode.sourceIndex + attributeSelectorString.indexOf
(attributeNode.value))
          }

          if (attributeNode.quoted &#x26;&#x26; expectation === &#x22;never&#x22;) {
            complain(messages.rejected(attributeNode.raws.unquoted), attributeNode.sourceIndex + attributeSelectorString.indexOf
(attributeNode.value))
          }
        })
      })

      function complain(message, index) {
        report({
          message,
          index,
          result,
          ruleName,
          node: rule,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-class-pattern" id="apidoc.element.stylelint.rules.selector-class-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-class-pattern
        <span class="apidocSignatureSpan">(pattern, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-class-pattern = function (pattern, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    }, {
      actual: options,
      possible: {
        resolveNestedSelectors: _.isBoolean,
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const shouldResolveNestedSelectors = _.get(options, &#x22;resolveNestedSelectors&#x22;)
    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkRules(rule =&#x3e; {
      const selector = rule.selector,
        selectors = rule.selectors

      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selectors.some(s =&#x3e; isKeyframeSelector(s))) {
        return
      }

      // Only bother resolving selectors that have an interpolating &#x26;
      if (shouldResolveNestedSelectors &#x26;&#x26; hasInterpolatingAmpersand(selector)) {
        resolveNestedSelector(selector, rule).forEach(selector =&#x3e; {
          if (!isStandardSyntaxSelector(selector)) {
            return
          }

          parseSelector(selector, result, rule, s =&#x3e; checkSelector(s, rule))
        })
      } else {
        parseSelector(selector, result, rule, s =&#x3e; checkSelector(s, rule))
      }
    })

    function checkSelector(fullSelector, rule) {
      fullSelector.walkClasses(classNode =&#x3e; {
        const value = classNode.value,
          sourceIndex = classNode.sourceIndex

        if (normalizedPattern.test(value)) {
          return
        }
        report({
          result,
          ruleName,
          message: messages.expected(value),
          node: rule,
          index: sourceIndex,
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-combinator-space-after" id="apidoc.element.stylelint.rules.selector-combinator-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-combinator-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-combinator-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    selectorCombinatorSpaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-combinator-space-before" id="apidoc.element.stylelint.rules.selector-combinator-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-combinator-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-combinator-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    selectorCombinatorSpaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-descendant-combinator-no-non-space" id="apidoc.element.stylelint.rules.selector-descendant-combinator-no-non-space">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-descendant-combinator-no-non-space
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-descendant-combinator-no-non-space = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      const selector = rule.selector

      parseSelector(selector, result, rule, fullSelector =&#x3e; {
        fullSelector.walkCombinators(combinatorNode =&#x3e; {
          const value = combinatorNode.value

          if (punctuationSets.nonSpaceCombinators.has(value)) {
            return
          }
          if (value === &#x22; &#x22;) {
            return
          }

          report({
            result,
            ruleName,
            message: messages.rejected(value),
            node: rule,
            index: combinatorNode.sourceIndex,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-id-pattern" id="apidoc.element.stylelint.rules.selector-id-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-id-pattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-id-pattern = function (pattern) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    })
    if (!validOptions) {
      return
    }

    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }

      parseSelector(selector, result, rule, fullSelector =&#x3e; {
        fullSelector.walk(selectorNode =&#x3e; {
          if (selectorNode.type !== &#x22;id&#x22;) {
            return
          }
          const value = selectorNode.value,
            sourceIndex = selectorNode.sourceIndex

          if (normalizedPattern.test(value)) {
            return
          }

          report({
            result,
            ruleName,
            message: messages.expected(value),
            node: rule,
            index: sourceIndex,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-list-comma-newline-after" id="apidoc.element.stylelint.rules.selector-list-comma-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-list-comma-newline-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      // Get raw selector so we can allow end-of-line comments, e.g.
      // a,<span class="apidocCodeCommentSpan"> /* comment */
</span>      // b {}
      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector
      styleSearch({
        source: selector,
        target: &#x22;,&#x22;,
        functionArguments: &#x22;skip&#x22;,
      }, match =&#x3e; {
        const nextThreeChars = selector.substr(match.endIndex, 3)

        // If there&#x27;s a // comment, that means there has to be a newline
        // ending the comment so we&#x27;re fine
        if (nextThreeChars === &#x22; //&#x22;) {
          return
        }

        // If there is a space and then a comment begins, look for the newline
        // after that comment
        const indextoCheckAfter = nextThreeChars === &#x22; /*&#x22; ? selector.indexOf(&#x22;*/&#x22;, match.endIndex) + 1 : match.startIndex
        checker.afterOneOnly({
          source: selector,
          index: indextoCheckAfter,
          err: m =&#x3e; report({
            message: m,
            node: rule,
            index: match.startIndex,
            result,
            ruleName,
          }),
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-list-comma-newline-before" id="apidoc.element.stylelint.rules.selector-list-comma-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-list-comma-newline-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    selectorListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.beforeAllowingIndentation,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-list-comma-space-after" id="apidoc.element.stylelint.rules.selector-list-comma-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-list-comma-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    selectorListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-list-comma-space-before" id="apidoc.element.stylelint.rules.selector-list-comma-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-list-comma-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-list-comma-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    selectorListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-max-compound-selectors" id="apidoc.element.stylelint.rules.selector-max-compound-selectors">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-compound-selectors
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-max-compound-selectors = function (max) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: [
        function (max) {
          return typeof max === &#x22;number&#x22; &#x26;&#x26; max &#x3e; 0
        },
      ],
    })
    if (!validOptions) {
      return
    }

    // Finds actual selectors in selectorNode object and checks them
    function checkSelector(selectorNode, rule) {
      let compoundCount = 1

      selectorNode.each(childNode =&#x3e; {
        // Only traverse inside actual selectors and :not()
        if (childNode.type === &#x22;selector&#x22; || childNode.value === &#x22;:not&#x22;) {
          checkSelector(childNode, rule)
        }

        // Compound selectors are separated by combinators, so increase count when meeting one
        if (childNode.type === &#x22;combinator&#x22;) {
          compoundCount++
        }
      })

      if (selectorNode.type !== &#x22;root&#x22; &#x26;&#x26; selectorNode.type !== &#x22;pseudo&#x22; &#x26;&#x26; compoundCount &#x3e; max) {
        report({
          ruleName,
          result,
          node: rule,
          message: messages.expected(selectorNode, max),
          word: selectorNode,
        })
      }
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(rule.selector)) {
        return
      }

      // Nested selectors are processed in steps, as nesting levels are resolved.
      // Here we skip processing the intermediate parts of selectors (to process only fully resolved selectors)
      if (rule.nodes.some(node =&#x3e; node.type === &#x22;rule&#x22; || node.type === &#x22;atrule&#x22;)) {
        return
      }

      // Using `rule.selectors` gets us each selector if there is a comma separated set
      rule.selectors.forEach(selector =&#x3e; {
        resolvedNestedSelector(selector, rule).forEach(resolvedSelector =&#x3e; {
          // Process each resolved selector with `checkSelector` via postcss-selector-parser
          selectorParser(s =&#x3e; checkSelector(s, rule)).process(resolvedSelector)
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-max-empty-lines" id="apidoc.element.stylelint.rules.selector-max-empty-lines">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-empty-lines
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-max-empty-lines = function (max) {
  const maxAdjacentNewlines = max + 1

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: _.isNumber,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector
      const repeatLFNewLines = _.repeat(&#x22;\n&#x22;, maxAdjacentNewlines)
      const repeatCRLFNewLines = _.repeat(&#x22;\r\n&#x22;, maxAdjacentNewlines)

      styleSearch({ source: selector, target: &#x22;\n&#x22; }, match =&#x3e; {
        if (selector.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || selector.substr(match.startIndex +
1, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {
          // Put index at `\r` if it&#x27;s CRLF, otherwise leave it at `\n`
          let index = match.startIndex
          if (selector[index - 1] === &#x22;\r&#x22;) {
            index -= 1
          }

          report({
            message: messages.expected(max),
            node: rule,
            index,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-max-specificity" id="apidoc.element.stylelint.rules.selector-max-specificity">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-max-specificity
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-max-specificity = function (max) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: [
        function (max) {
        // Check that the max specificity is in the form &#x22;a,b,c&#x22;
          const pattern = new RegExp(&#x22;^\\d+,\\d+,\\d+$&#x22;)
          return pattern.test(max)
        },
      ],
    })
    if (!validOptions) {
      return
    }

    const maxSpecificityArray = (&#x22;0,&#x22; + max).split(&#x22;,&#x22;).map(parseFloat)
    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(rule.selector)) {
        return
      }
      // Using rule.selectors gets us each selector in the eventuality we have a comma separated set
      rule.selectors.forEach(selector =&#x3e; {
        resolvedNestedSelector(selector, rule).forEach(resolvedSelector =&#x3e; {
          // Return early if selector contains a not pseudo-class
          if (selector.indexOf(&#x22;:not(&#x22;) !== -1) {
            return
          }
          // Return early if selector contains a matches
          if (selector.indexOf(&#x22;:matches(&#x22;) !== -1) {
            return
          }
          // Check if the selector specificity exceeds the allowed maximum
          try {
            if (specificity.compare(resolvedSelector, maxSpecificityArray) === 1) {
              report({
                ruleName,
                result,
                node: rule,
                message: messages.expected(resolvedSelector, max),
                word: selector,
              })
            }
          } catch (e) {
            result.warn(&#x22;Cannot parse selector&#x22;, { node: rule })
          }
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-nested-pattern" id="apidoc.element.stylelint.rules.selector-nested-pattern">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-nested-pattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-nested-pattern = function (pattern) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: pattern,
      possible: [
        _.isRegExp,
        _.isString,
      ],
    })
    if (!validOptions) {
      return
    }

    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern

    root.walkRules(rule =&#x3e; {
      if (rule.parent.type !== &#x22;rule&#x22;) {
        return
      }
      if (!isStandardSyntaxRule(rule)) {
        return
      }

      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }

      if (normalizedPattern.test(selector)) {
        return
      }

      report({
        result,
        ruleName,
        message: messages.expected(selector),
        node: rule,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-attribute" id="apidoc.element.stylelint.rules.selector-no-attribute">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-attribute
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-attribute = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorAST =&#x3e; {
        selectorAST.walkAttributes(attribute =&#x3e; {
          report({
            message: messages.rejected,
            node: rule,
            index: attribute.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-combinator" id="apidoc.element.stylelint.rules.selector-no-combinator">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-combinator
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-combinator = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorAST =&#x3e; {
        selectorAST.walkCombinators(combinator =&#x3e; {
          report({
            message: messages.rejected,
            node: rule,
            index: combinator.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-empty" id="apidoc.element.stylelint.rules.selector-no-empty">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-empty
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-empty = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      &#x22;&#x27;selector-no-empty&#x27; has been deprecated and in 8.0 will be removed.&#x22;
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: &#x22;https://stylelint.io/user-guide/rules/selector-no-empty/&#x22;,
    })

    root.walkRules(rule =&#x3e; {
      let index = 0

      rule.selector.split(&#x22;,&#x22;).forEach(item =&#x3e; {
        index += item.length + 1

        if (item.trim() !== &#x22;&#x22;) {
          return
        }

        report({
          message: messages.rejected,
          node: rule,
          index: index - 1,
          ruleName,
          result,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-id" id="apidoc.element.stylelint.rules.selector-no-id">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-id
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-id = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (isKeyframeRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorAST =&#x3e; {
        selectorAST.walkIds(idNode =&#x3e; {
          if (idNode.parent.parent.type === &#x22;pseudo&#x22;) {
            return
          }

          report({
            message: messages.rejected,
            node: rule,
            index: idNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-qualifying-type" id="apidoc.element.stylelint.rules.selector-no-qualifying-type">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-qualifying-type
        <span class="apidocSignatureSpan">(enabled, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-qualifying-type = function (enabled, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: enabled,
      possible: [
        true,
        false,
      ],
    }, {
      actual: options,
      possible: {
        ignore: [
          &#x22;attribute&#x22;,
          &#x22;class&#x22;,
          &#x22;id&#x22;,
        ],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (isKeyframeRule(rule)) {
        return
      }
      // Increasing performance
      if (!isStandardSyntaxSelector(rule.selector)) {
        return
      }
      if (!isSelectorCharacters(rule.selector)) {
        return
      }

      function checkSelector(selectorAST) {
        selectorAST.walkTags(selector =&#x3e; {
          const selectorParent = selector.parent

          if (selectorParent.nodes.length === 1) {
            return
          }

          const selectorNodes = getRightNodes(selector)
          const index = selector.sourceIndex

          selectorNodes.forEach(selectorNode =&#x3e; {
            if (selectorNode.type === &#x22;id&#x22; &#x26;&#x26; !optionsMatches(options, &#x22;ignore&#x22;, &#x22;id&#x22;)) {
              complain(index)
            }

            if (selectorNode.type === &#x22;class&#x22; &#x26;&#x26; !optionsMatches(options, &#x22;ignore&#x22;, &#x22;class&#x22;)) {
              complain(index)
            }

            if (selectorNode.type === &#x22;attribute&#x22; &#x26;&#x26; !optionsMatches(options, &#x22;ignore&#x22;, &#x22;attribute&#x22;)) {
              complain(index)
            }
          })
        })
      }

      resolvedNestedSelector(rule.selector, rule).forEach(resolvedSelector =&#x3e; {
        if (!isStandardSyntaxSelector(resolvedSelector)) {
          return
        }

        parseSelector(resolvedSelector, result, rule, checkSelector)
      })

      function complain(index) {
        report({
          ruleName,
          result,
          node: rule,
          message: messages.rejected,
          index,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-type" id="apidoc.element.stylelint.rules.selector-no-type">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-type
        <span class="apidocSignatureSpan">(on, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-type = function (on, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual: on }, {
      actual: options,
      possible: {
        ignore: [
          &#x22;descendant&#x22;,
          &#x22;compounded&#x22;,
        ],
        ignoreTypes: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    const ignoreDescendant = optionsMatches(options, &#x22;ignore&#x22;, &#x22;descendant&#x22;)
    const ignoreCompounded = optionsMatches(options, &#x22;ignore&#x22;, &#x22;compounded&#x22;)

    root.walkRules(rule =&#x3e; {
      const selector = rule.selector,
        selectors = rule.selectors

      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selectors.some(s =&#x3e; isKeyframeSelector(s))) {
        return
      }

      if (ignoreDescendant) {
        // Resolve each selector within the list before checking
        selectors.forEach(selector =&#x3e; {
          resolveNestedSelector(selector, rule).forEach(selector =&#x3e; {
            checkSelector(selector, rule)
          })
        })
      } else {
        checkSelector(selector, rule)
      }
    })

    function checkSelector(selector, rule) {
      parseSelector(selector, result, rule, selectorAST =&#x3e; {
        selectorAST.walkTags(tag =&#x3e; {
          if (!isStandardSyntaxTypeSelector(tag)) {
            return
          }

          if (optionsMatches(options, &#x22;ignoreTypes&#x22;, tag.value)) {
            return
          }

          if (ignoreDescendant &#x26;&#x26; hasCombinatorBefore(tag)) {
            return
          }

          if (ignoreCompounded &#x26;&#x26; isCompounded(tag)) {
            return
          }

          report({
            message: messages.rejected,
            node: rule,
            index: tag.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-universal" id="apidoc.element.stylelint.rules.selector-no-universal">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-universal
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-universal = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorAST =&#x3e; {
        selectorAST.walkUniversals(universal =&#x3e; {
          report({
            message: messages.rejected,
            node: rule,
            index: universal.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-no-vendor-prefix" id="apidoc.element.stylelint.rules.selector-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-no-vendor-prefix = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      parseSelector(selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkPseudos(pseudoNode =&#x3e; {
          if (isAutoprefixable.selector(pseudoNode.value)) {
            report({
              result,
              ruleName,
              message: messages.rejected(pseudoNode.value),
              node: rule,
              index: (rule.raws.before || &#x22;&#x22;).length + pseudoNode.sourceIndex,
            })
          }
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-blacklist" id="apidoc.element.stylelint.rules.selector-pseudo-class-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-blacklist
        <span class="apidocSignatureSpan">(blacklist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-blacklist = function (blacklist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selector.indexOf(&#x22;:&#x22;) === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkPseudos(pseudoNode =&#x3e; {
          const value = pseudoNode.value

          // Ignore pseudo-elements

          if (value.slice(0, 2) === &#x22;::&#x22;) {
            return
          }

          const name = value.slice(1)

          if (!matchesStringOrRegExp(postcss.vendor.unprefixed(name).toLowerCase(), blacklist)) {
            return
          }

          report({
            index: pseudoNode.sourceIndex,
            message: messages.rejected(name),
            node: rule,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-case" id="apidoc.element.stylelint.rules.selector-pseudo-class-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-case = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector
      const startIndexPseudo = selector.indexOf(&#x22;:&#x22;)

      if (startIndexPseudo === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkPseudos(pseudoNode =&#x3e; {
          const pseudo = pseudoNode.value

          if (!isStandardSyntaxSelector(pseudo)) {
            return
          }

          if (pseudo.indexOf(&#x22;::&#x22;) !== -1 || keywordSets.levelOneAndTwoPseudoElements.has(pseudo.toLowerCase().slice(1))) {
            return
          }

          const expectedPseudo = expectation === &#x22;lower&#x22; ? pseudo.toLowerCase() : pseudo.toUpperCase()

          if (pseudo === expectedPseudo) {
            return
          }

          report({
            message: messages.expected(pseudo, expectedPseudo),
            node: rule,
            index: pseudoNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-no-unknown" id="apidoc.element.stylelint.rules.selector-pseudo-class-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-no-unknown = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignorePseudoClasses: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      // Return early before parse if no pseudos for performance

      if (selector.indexOf(&#x22;:&#x22;) === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkPseudos(pseudoNode =&#x3e; {
          const value = pseudoNode.value

          if (!isStandardSyntaxSelector(value)) {
            return
          }

          if (isCustomSelector(value)) {
            return
          }

          // Ignore pseudo-elements
          if (value.slice(0, 2) === &#x22;::&#x22;) {
            return
          }

          if (optionsMatches(options, &#x22;ignorePseudoClasses&#x22;, pseudoNode.value.slice(1))) {
            return
          }

          const name = value.slice(1)

          if (postcss.vendor.prefix(name)
            || keywordSets.pseudoClasses.has(name.toLowerCase())
            || keywordSets.pseudoElements.has(name.toLowerCase())
          ) {
            return
          }

          if (pseudoNode.prev()) {
            const prevPseudoNodeValue = postcss.vendor.unprefixed(pseudoNode.prev().value.toLowerCase().slice(2))

            if (keywordSets.webkitProprietaryPseudoElements.has(prevPseudoNodeValue)
              &#x26;&#x26; keywordSets.webkitProprietaryPseudoClasses.has(name.toLowerCase())
            ) {
              return
            }
          }

          report({
            message: messages.rejected(value),
            node: rule,
            index: pseudoNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-parentheses-space-inside" id="apidoc.element.stylelint.rules.selector-pseudo-class-parentheses-space-inside">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-parentheses-space-inside
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-parentheses-space-inside = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (rule.selector.indexOf(&#x22;(&#x22;) === -1) {
        return
      }

      parseSelector(rule.selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkPseudos(pseudoNode =&#x3e; {
          if (_.get(pseudoNode, &#x22;parent.parent.type&#x22;) === &#x22;pseudo&#x22;) {
            return
          }

          const pseudoSelectorString = pseudoNode.toString()

          styleSearch({ source: pseudoSelectorString, target: &#x22;(&#x22; }, match =&#x3e; {
            const nextCharIsSpace = pseudoSelectorString[match.startIndex + 1] === &#x22; &#x22;
            const index = pseudoNode.sourceIndex + match.startIndex + 1
            if (nextCharIsSpace &#x26;&#x26; expectation === &#x22;never&#x22;) {
              complain(messages.rejectedOpening, index)
            }
            if (!nextCharIsSpace &#x26;&#x26; expectation === &#x22;always&#x22;) {
              complain(messages.expectedOpening, index)
            }
          })

          styleSearch({ source: pseudoSelectorString, target: &#x22;)&#x22; }, match =&#x3e; {
            const prevCharIsSpace = pseudoSelectorString[match.startIndex - 1] === &#x22; &#x22;
            const index = pseudoNode.sourceIndex + match.startIndex - 1
            if (prevCharIsSpace &#x26;&#x26; expectation === &#x22;never&#x22;) {
              complain(messages.rejectedClosing, index)
            }
            if (!prevCharIsSpace &#x26;&#x26; expectation === &#x22;always&#x22;) {
              complain(messages.expectedClosing, index)
            }
          })
        })
      })

      function complain(message, index) {
        report({
          message,
          index,
          result,
          ruleName,
          node: rule,
        })
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-class-whitelist" id="apidoc.element.stylelint.rules.selector-pseudo-class-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-class-whitelist
        <span class="apidocSignatureSpan">(whitelist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-class-whitelist = function (whitelist) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      const selector = rule.selector

      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selector.indexOf(&#x22;:&#x22;) === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkPseudos(pseudoNode =&#x3e; {
          const value = pseudoNode.value

          // Ignore pseudo-elements

          if (value.slice(0, 2) === &#x22;::&#x22;) {
            return
          }

          const name = value.slice(1)

          if (matchesStringOrRegExp(postcss.vendor.unprefixed(name).toLowerCase(), whitelist)) {
            return
          }

          report({
            index: pseudoNode.sourceIndex,
            message: messages.rejected(name),
            node: rule,
            result,
            ruleName,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-element-case" id="apidoc.element.stylelint.rules.selector-pseudo-element-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-element-case = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector
      const startIndexPseudoElement = selector.indexOf(&#x22;:&#x22;)

      if (startIndexPseudoElement === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkPseudos(pseudoNode =&#x3e; {
          const pseudoElement = pseudoNode.value

          if (!isStandardSyntaxSelector(pseudoElement)) {
            return
          }

          if (pseudoElement.indexOf(&#x22;::&#x22;) === -1 &#x26;&#x26; !keywordSets.levelOneAndTwoPseudoElements.has(pseudoElement.toLowerCase().slice
(1))) {
            return
          }

          const expectedPseudoElement = expectation === &#x22;lower&#x22; ? pseudoElement.toLowerCase() : pseudoElement.toUpperCase()

          if (pseudoElement === expectedPseudoElement) {
            return
          }

          report({
            message: messages.expected(pseudoElement, expectedPseudoElement),
            node: rule,
            index: pseudoNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-element-colon-notation" id="apidoc.element.stylelint.rules.selector-pseudo-element-colon-notation">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-colon-notation
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-element-colon-notation = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;single&#x22;,
        &#x22;double&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      // get out early if no pseudo elements or classes
      if (selector.indexOf(&#x22;:&#x22;) === -1) {
        return
      }

      // match only level 1 and 2 pseudo elements
      const pseudoElementsWithColons = _.toArray(keywordSets.levelOneAndTwoPseudoElements).map(x =&#x3e; `:${x}`)
      styleSearch({ source: selector.toLowerCase(), target: pseudoElementsWithColons }, match =&#x3e; {
        const prevCharIsColon = selector[match.startIndex - 1] === &#x22;:&#x22;

        if (expectation === &#x22;single&#x22; &#x26;&#x26; !prevCharIsColon) {
          return
        }
        if (expectation === &#x22;double&#x22; &#x26;&#x26; prevCharIsColon) {
          return
        }

        report({
          message: messages.expected(expectation),
          node: rule,
          index: match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-pseudo-element-no-unknown" id="apidoc.element.stylelint.rules.selector-pseudo-element-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-pseudo-element-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-pseudo-element-no-unknown = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignorePseudoElements: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      if (!isStandardSyntaxRule(rule)) {
        return
      }
      const selector = rule.selector

      // Return early before parse if no pseudos for performance

      if (selector.indexOf(&#x22;:&#x22;) === -1) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkPseudos(pseudoNode =&#x3e; {
          const value = pseudoNode.value

          if (!isStandardSyntaxSelector(value)) {
            return
          }

          // Ignore pseudo-classes
          if (value.slice(0, 2) !== &#x22;::&#x22;) {
            return
          }

          if (optionsMatches(options, &#x22;ignorePseudoElements&#x22;, pseudoNode.value.slice(2))) {
            return
          }

          const name = value.slice(2)

          if (postcss.vendor.prefix(name) || keywordSets.pseudoElements.has(name.toLowerCase())) {
            return
          }

          report({
            message: messages.rejected(value),
            node: rule,
            index: pseudoNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-root-no-composition" id="apidoc.element.stylelint.rules.selector-root-no-composition">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-root-no-composition
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-root-no-composition = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed. Instead use the community &#x27;stylelint-suitcss&#x27; plugin pack.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkRules(rule =&#x3e; {
      if (rule.selector.toLowerCase().indexOf(&#x22;:root&#x22;) === -1 || rule.selector.toLowerCase().trim() === &#x22;:root&#x22;) {
        return
      }

      report({
        message: messages.rejected,
        node: rule,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-type-case" id="apidoc.element.stylelint.rules.selector-type-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-type-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-type-case = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      const selector = rule.selector,
        selectors = rule.selectors

      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selectors.some(s =&#x3e; isKeyframeSelector(s))) {
        return
      }

      parseSelector(selector, result, rule, selectorAST =&#x3e; {
        selectorAST.walkTags(tag =&#x3e; {
          if (!isStandardSyntaxTypeSelector(tag)) {
            return
          }

          const sourceIndex = tag.sourceIndex,
            value = tag.value

          const expectedValue = expectation === &#x22;lower&#x22; ? value.toLowerCase() : value.toUpperCase()

          if (value === expectedValue) {
            return
          }

          report({
            message: messages.expected(value, expectedValue),
            node: rule,
            index: sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.selector-type-no-unknown" id="apidoc.element.stylelint.rules.selector-type-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>selector-type-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector-type-no-unknown = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignore: [
          &#x22;default-namespace&#x22;,
        ],
        ignoreNamespaces: [_.isString],
        ignoreTypes: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkRules(rule =&#x3e; {
      const selector = rule.selector,
        selectors = rule.selectors

      if (!isStandardSyntaxRule(rule)) {
        return
      }
      if (!isStandardSyntaxSelector(selector)) {
        return
      }
      if (selectors.some(s =&#x3e; isKeyframeSelector(s))) {
        return
      }

      parseSelector(selector, result, rule, selectorTree =&#x3e; {
        selectorTree.walkTags(tagNode =&#x3e; {
          if (!isStandardSyntaxTypeSelector(tagNode)) {
            return
          }

          if (
            optionsMatches(options, &#x22;ignore&#x22;, &#x22;default-namespace&#x22;)
            &#x26;&#x26; !tagNode.hasOwnProperty(&#x22;namespace&#x22;)
          ) {
            return
          }

          if (optionsMatches(options, &#x22;ignoreNamespaces&#x22;, tagNode.namespace)) {
            return
          }

          if (optionsMatches(options, &#x22;ignoreTypes&#x22;, tagNode.value)) {
            return
          }

          const tagName = tagNode.value
          const tagNameLowerCase = tagName.toLowerCase()

          if (htmlTags.indexOf(tagNameLowerCase) !== -1 || svgTags.indexOf(tagNameLowerCase) !== -1 || nonStandardHtmlTags.has(tagNameLowerCase
)) {
            return
          }

          report({
            message: messages.rejected(tagName),
            node: rule,
            index: tagNode.sourceIndex,
            ruleName,
            result,
          })
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.shorthand-property-no-redundant-values" id="apidoc.element.stylelint.rules.shorthand-property-no-redundant-values">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>shorthand-property-no-redundant-values
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shorthand-property-no-redundant-values = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
        return
      }

      const prop = decl.prop,
        value = decl.value

      const normalizedProp = postcss.vendor.unprefixed(prop.toLowerCase())

      // Ignore not shorthandable properties, and math operations
      if (isIgnoredCharacters(value) || !shorthandableProperties.has(normalizedProp) || ignoredShorthandProperties.has(normalizedProp
)) {
        return
      }

      const valuesToShorthand = []

      valueParser(value).walk(valueNode =&#x3e; {
        if (valueNode.type !== &#x22;word&#x22;) {
          return
        }

        valuesToShorthand.push(valueParser.stringify(valueNode))
      })

      if (valuesToShorthand.length &#x3c;= 1 || valuesToShorthand.length &#x3e; 4) {
        return
      }

      const shortestForm = canCondense.apply(undefined, valuesToShorthand)
      const shortestFormString = shortestForm.filter(value =&#x3e; {
        return value
      }).join(&#x22; &#x22;)
      const valuesFormString = valuesToShorthand.join(&#x22; &#x22;)

      if (shortestFormString.toLowerCase() === valuesFormString.toLowerCase()) {
        return
      }

      report({
        message: messages.rejected(value, shortestFormString),
        node: decl,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.string-no-newline" id="apidoc.element.stylelint.rules.string-no-newline">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>string-no-newline
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string-no-newline = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    const cssString = root.toString()
    styleSearch({
      source: cssString,
      target: &#x22;\n&#x22;,
      strings: &#x22;only&#x22;,
    }, match =&#x3e; {
      const charBefore = cssString[match.startIndex - 1]
      let index = match.startIndex
      if (charBefore === &#x22;\\&#x22;) {
        return
      }
      if (charBefore === &#x22;\r&#x22;) index -= 1
      report({
        message: messages.rejected,
        node: root,
        index,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.string-quotes" id="apidoc.element.stylelint.rules.string-quotes">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>string-quotes
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string-quotes = function (expectation) {
  const erroneousQuote = expectation === &#x22;single&#x22; ? &#x22;\&#x22;&#x22; : &#x22;&#x27;&#x22;

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;single&#x22;,
        &#x22;double&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    const cssString = root.toString()
    styleSearch({ source: cssString, target: erroneousQuote }, match =&#x3e; {
      report({
        message: messages.expected(expectation),
        node: root,
        index: match.startIndex,
        result,
        ruleName,
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.stylelint-disable-reason" id="apidoc.element.stylelint.rules.stylelint-disable-reason">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>stylelint-disable-reason
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stylelint-disable-reason = function (expectation) {
  return function (root, result) {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always-before&#x22;,
        &#x22;always-after&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkComments(function (comment) {
      if (comment.text.indexOf(stylelintDisableCommand) !== 0) {
        return
      }

      if (expectation === &#x22;always-before&#x22;) {
        const prev = comment.prev()
        const prevIsCommentAndValid = prev &#x26;&#x26; prev.type === &#x22;comment&#x22; &#x26;&#x26; !isDisableCommand(prev.text)

        let prevDisableLineIsCommentAndValid = false

        if (comment.text.indexOf(stylelintDisableLineCommand) === 0 &#x26;&#x26; !prevIsCommentAndValid &#x26;&#x26; prev) {
          const friendlyPrev = prev.prev()

          prevDisableLineIsCommentAndValid = friendlyPrev &#x26;&#x26; friendlyPrev.type === &#x22;comment&#x22; &#x26;&#x26; !isDisableCommand(friendlyPrev.text
)
        }

        if (!prevIsCommentAndValid &#x26;&#x26; !prevDisableLineIsCommentAndValid) {
          const disabledRanges = result.stylelint.disabledRanges
          result.stylelint.disabledRanges = false

          report({
            message: messages.expectedBefore,
            node: comment,
            result,
            ruleName,
          })
          result.stylelint.disabledRanges = disabledRanges
        }
      } else if (expectation === &#x22;always-after&#x22;) {
        const next = comment.next()
        const nextIsCommentAndValid = next &#x26;&#x26; next.type === &#x22;comment&#x22; &#x26;&#x26; !isDisableCommand(next.text)

        if (!nextIsCommentAndValid) {
          const disabledRanges = result.stylelint.disabledRanges
          result.stylelint.disabledRanges = false

          report({
            message: messages.expectedAfter,
            node: comment,
            result,
            ruleName,
          })
          result.stylelint.disabledRanges = disabledRanges
        }
      }
    })

    function isDisableCommand(text) {
      return text.indexOf(stylelintDisableCommand) === 0
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.time-min-milliseconds" id="apidoc.element.stylelint.rules.time-min-milliseconds">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>time-min-milliseconds
        <span class="apidocSignatureSpan">(minimum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time-min-milliseconds = function (minimum) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: minimum,
      possible: _.isNumber,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const propertyName = postcss.vendor.unprefixed(decl.prop.toLowerCase())

      if (
        keywordSets.longhandTimeProperties.has(propertyName)
        &#x26;&#x26; !isAcceptableTime(decl.value)
      ) {
        complain(decl)
      }

      if (keywordSets.shorthandTimeProperties.has(propertyName)) {
        const valueList = postcss.list.space(decl.value)

        for (const value of valueList) {
          if (!isAcceptableTime(value)) {
            complain(decl, decl.value.indexOf(value))
          }
        }
      }
    })

    function isAcceptableTime(time) {
      const parsedTime = valueParser.unit(time)

      if (!parsedTime) return true

      if (parsedTime.number &#x3c;= 0) {
        return true
      }

      if (parsedTime.unit.toLowerCase() === &#x22;ms&#x22; &#x26;&#x26; parsedTime.number &#x3c; minimum) {
        return false
      }

      if (parsedTime.unit.toLowerCase() === &#x22;s&#x22; &#x26;&#x26; parsedTime.number * 1000 &#x3c; minimum) {
        return false
      }

      return true
    }

    function complain(decl, offset) {
      offset = offset || 0

      report({
        result,
        ruleName,
        message: messages.expected(minimum),
        index: declarationValueIndex(decl) + offset,
        node: decl,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.time-no-imperceptible" id="apidoc.element.stylelint.rules.time-no-imperceptible">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>time-no-imperceptible
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time-no-imperceptible = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    result.warn((
      `&#x27;${ruleName}&#x27; has been deprecated and in 8.0 will be removed. Instead use &#x27;time-min-milliseconds&#x27; with &#x27;100&#x27; as its primary
 option.`
    ), {
      stylelintType: &#x22;deprecation&#x22;,
      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,
    })

    root.walkDecls(decl =&#x3e; {
      if (keywordSets.longhandTimeProperties.has(postcss.vendor.unprefixed(decl.prop.toLowerCase()))) {
        if (isImperceptibleTime(decl.value)) {
          complain(messages.rejected(decl.value), decl)
        }
      }

      if (keywordSets.shorthandTimeProperties.has(postcss.vendor.unprefixed(decl.prop.toLowerCase()))) {
        const valueList = postcss.list.space(decl.value)
        for (const value of valueList) {
          if (isImperceptibleTime(value)) {
            complain(messages.rejected(value), decl, decl.value.indexOf(value))
          }
        }
      }
    })

    function isImperceptibleTime(time) {
      const parsedTime = valueParser.unit(time)
      if (!parsedTime) return false
      const absoluteTime = Math.abs(parsedTime.number)
      if (parsedTime.unit.toLowerCase() === &#x22;ms&#x22; &#x26;&#x26; absoluteTime &#x3c;= MINIMUM_MILLISECONDS) {
        return true
      }
      if (parsedTime.unit.toLowerCase() === &#x22;s&#x22; &#x26;&#x26; absoluteTime * 1000 &#x3c;= MINIMUM_MILLISECONDS) {
        return true
      }
      return false
    }

    function complain(message, decl) {
      const offset = arguments.length &#x3e; 2 &#x26;&#x26; arguments[2] !== undefined ? arguments[2] : 0

      report({
        result,
        ruleName,
        message,
        index: declarationValueIndex(decl) + offset,
        node: decl,
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.unit-blacklist" id="apidoc.element.stylelint.rules.unit-blacklist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-blacklist
        <span class="apidocSignatureSpan">(blacklistInput, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit-blacklist = function (blacklistInput, options) {
  const blacklist = [].concat(blacklistInput)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: blacklist,
      possible: [_.isString],
    }, {
      optional: true,
      actual: options,
      possible: {
        ignoreProperties: validateObjectWithStringArrayProps,
      },
    })
    if (!validOptions) {
      return
    }

    function check(node, value, getIndex) {
      valueParser(value).walk(function (valueNode) {
        // Ignore wrong units within `url` function
        if (valueNode.type === &#x22;function&#x22; &#x26;&#x26; valueNode.value.toLowerCase() === &#x22;url&#x22;) {
          return false
        }

        const unit = getUnitFromValueNode(valueNode)

        if (!unit || unit &#x26;&#x26; blacklist.indexOf(unit.toLowerCase()) === -1) {
          return
        }

        if (options &#x26;&#x26; optionsMatches(options.ignoreProperties, unit.toLowerCase(), node.prop)) {
          return
        }

        report({
          index: getIndex(node) + valueNode.sourceIndex,
          message: messages.rejected(unit),
          node,
          result,
          ruleName,
        })
      })
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; check(atRule, atRule.params, atRuleParamIndex))
    root.walkDecls(decl =&#x3e; check(decl, decl.value, declarationValueIndex))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.unit-case" id="apidoc.element.stylelint.rules.unit-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-case
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit-case = function (expectation) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    function check(node, value, getIndex) {
      valueParser(value).walk(valueNode =&#x3e; {
        // Ignore wrong units within `url` function
        if (valueNode.type === &#x22;function&#x22; &#x26;&#x26; valueNode.value.toLowerCase() === &#x22;url&#x22;) {
          return false
        }

        const unit = getUnitFromValueNode(valueNode)

        if (!unit) {
          return
        }

        const expectedUnit = expectation === &#x22;lower&#x22; ? unit.toLowerCase() : unit.toUpperCase()

        if (unit === expectedUnit) {
          return
        }

        report({
          index: getIndex(node) + valueNode.sourceIndex,
          message: messages.expected(unit, expectedUnit),
          node,
          result,
          ruleName,
        })
      })
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; check(atRule, atRule.params, atRuleParamIndex))
    root.walkDecls(decl =&#x3e; check(decl, decl.value, declarationValueIndex))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.unit-no-unknown" id="apidoc.element.stylelint.rules.unit-no-unknown">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-no-unknown
        <span class="apidocSignatureSpan">(actual, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit-no-unknown = function (actual, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual }, {
      actual: options,
      possible: {
        ignoreUnits: [_.isString],
      },
      optional: true,
    })

    if (!validOptions) {
      return
    }

    function check(node, value, getIndex) {
      valueParser(value).walk(function (valueNode) {
        // Ignore wrong units within `url` function
        if (valueNode.type === &#x22;function&#x22; &#x26;&#x26; valueNode.value.toLowerCase() === &#x22;url&#x22;) {
          return false
        }

        const unit = getUnitFromValueNode(valueNode)
        if (!unit) {
          return
        }

        if (optionsMatches(options, &#x22;ignoreUnits&#x22;, unit)) {
          return
        }

        if (keywordSets.units.has(unit.toLowerCase())) {
          return
        }

        report({
          index: getIndex(node) + valueNode.sourceIndex,
          message: messages.rejected(unit),
          node,
          result,
          ruleName,
        })
      })
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; check(atRule, atRule.params, atRuleParamIndex))
    root.walkDecls(decl =&#x3e; check(decl, decl.value, declarationValueIndex))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.unit-whitelist" id="apidoc.element.stylelint.rules.unit-whitelist">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>unit-whitelist
        <span class="apidocSignatureSpan">(whitelistInput, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit-whitelist = function (whitelistInput, options) {
  const whitelist = [].concat(whitelistInput)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: whitelist,
      possible: [_.isString],
    }, {
      optional: true,
      actual: options,
      possible: {
        ignoreProperties: validateObjectWithStringArrayProps,
      },
    })
    if (!validOptions) {
      return
    }

    function check(node, value, getIndex) {
      valueParser(value).walk(function (valueNode) {
        // Ignore wrong units within `url` function
        if (valueNode.type === &#x22;function&#x22; &#x26;&#x26; valueNode.value.toLowerCase() === &#x22;url&#x22;) {
          return false
        }

        const unit = getUnitFromValueNode(valueNode)

        if (!unit || unit &#x26;&#x26; whitelist.indexOf(unit.toLowerCase()) !== -1) {
          return
        }

        if (options &#x26;&#x26; optionsMatches(options[&#x22;ignoreProperties&#x22;], unit.toLowerCase(), node.prop)) {
          return
        }

        report({
          index: getIndex(node) + valueNode.sourceIndex,
          message: messages.rejected(unit),
          node,
          result,
          ruleName,
        })
      })
    }

    root.walkAtRules(/^media$/i, atRule =&#x3e; check(atRule, atRule.params, atRuleParamIndex))
    root.walkDecls(decl =&#x3e; check(decl, decl.value, declarationValueIndex))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-keyword-case" id="apidoc.element.stylelint.rules.value-keyword-case">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-keyword-case
        <span class="apidocSignatureSpan">(expectation, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-keyword-case = function (expectation, options) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;lower&#x22;,
        &#x22;upper&#x22;,
      ],
    }, {
      actual: options,
      possible: {
        ignoreKeywords: [_.isString],
      },
      optional: true,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const prop = decl.prop,
        value = decl.value

      valueParser(value).walk(node =&#x3e; {
        const valueLowerCase = node.value.toLowerCase()

        // Ignore system colors
        if (keywordSets.systemColors.has(valueLowerCase)) {
          return
        }

        // Ignore keywords within `url` and `var` function
        if (node.type === &#x22;function&#x22; &#x26;&#x26; (valueLowerCase === &#x22;url&#x22; || valueLowerCase === &#x22;var&#x22; || valueLowerCase === &#x22;counter&#x22; ||
valueLowerCase === &#x22;counters&#x22; || valueLowerCase === &#x22;attr&#x22;)) {
          return false
        }

        const keyword = node.value

        // Ignore css variables, and hex values, and math operators, and sass interpolation
        if (node.type !== &#x22;word&#x22; || !isStandardSyntaxValue(node.value) || value.indexOf(&#x22;#&#x22;) !== -1 || ignoredCharacters.has(keyword
) || getUnitFromValueNode(node)) {
          return
        }

        if (prop === &#x22;animation&#x22; &#x26;&#x26; !keywordSets.animationShorthandKeywords.has(valueLowerCase) &#x26;&#x26; !keywordSets.animationNameKeywords
.has(valueLowerCase)) {
          return
        }
        if (prop === &#x22;animation-name&#x22; &#x26;&#x26; !keywordSets.animationNameKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === &#x22;font&#x22; &#x26;&#x26; !keywordSets.fontShorthandKeywords.has(valueLowerCase) &#x26;&#x26; !keywordSets.fontFamilyKeywords.has(valueLowerCase
)) {
          return
        }
        if (prop === &#x22;font-family&#x22; &#x26;&#x26; !keywordSets.fontFamilyKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === &#x22;counter-increment&#x22; &#x26;&#x26; isCounterIncrementCustomIdentValue(valueLowerCase)) {
          return
        }
        if (prop === &#x22;counter-reset&#x22; &#x26;&#x26; isCounterResetCustomIdentValue(valueLowerCase)) {
          return
        }
        if (prop === &#x22;grid-row&#x22; &#x26;&#x26; !keywordSets.gridRowKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === &#x22;grid-column&#x22; &#x26;&#x26; !keywordSets.gridColumnKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === &#x22;grid-area&#x22; &#x26;&#x26; !keywordSets.gridAreaKeywords.has(valueLowerCase)) {
          return
        }
        if (prop === &#x22;list-style&#x22; &#x26;&#x26; !keywordSets.listStyleShorthandKeywords.has(valueLowerCase) &#x26;&#x26; !keywordSets.listStyleTypeKeywords
.has(valueLowerCase)) {
          return
        }
        if (prop === &#x22;list-style-type&#x22; &#x26;&#x26; !keywordSets.listStyleTypeKeywords.has(valueLowerCase)) {
          return
        }

        const ignoreKeywords = options &#x26;&#x26; options.ignoreKeywords || []

        if (ignoreKeywords.length &#x3e; 0 &#x26;&#x26; matchesStringOrRegExp(keyword, ignoreKeywords)) {
          return
        }

        const keywordLowerCase = keyword.toLocaleLowerCase()
        let expectedKeyword = null

        if (expectation === &#x22;lower&#x22; &#x26;&#x26; mapLowercaseKeywordsToCamelCase.has(keywordLowerCase)) {
          expectedKeyword = mapLowercaseKeywordsToCamelCase.get(keywordLowerCase)
        } else if (expectation === &#x22;lower&#x22;) {
          expectedKeyword = keyword.toLowerCase()
        } else {
          expectedKeyword = keyword.toUpperCase()
        }

        if (keyword === expectedKeyword) {
          return
        }

        report({
          message: messages.expected(keyword, expectedKeyword),
          node: decl,
          index: declarationValueIndex(decl) + node.sourceIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-comma-newline-after" id="apidoc.element.stylelint.rules.value-list-comma-newline-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-newline-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-comma-newline-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    valueListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.afterOneOnly,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-comma-newline-before" id="apidoc.element.stylelint.rules.value-list-comma-newline-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-newline-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-comma-newline-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;newline&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;always-multi-line&#x22;,
        &#x22;never-multi-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    valueListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.beforeAllowingIndentation,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-comma-space-after" id="apidoc.element.stylelint.rules.value-list-comma-space-after">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-space-after
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-comma-space-after = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    valueListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.after,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-comma-space-before" id="apidoc.element.stylelint.rules.value-list-comma-space-before">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-comma-space-before
        <span class="apidocSignatureSpan">(expectation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-comma-space-before = function (expectation) {
  const checker = whitespaceChecker(&#x22;space&#x22;, expectation, messages)
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: expectation,
      possible: [
        &#x22;always&#x22;,
        &#x22;never&#x22;,
        &#x22;always-single-line&#x22;,
        &#x22;never-single-line&#x22;,
      ],
    })
    if (!validOptions) {
      return
    }

    valueListCommaWhitespaceChecker({
      root,
      result,
      locationChecker: checker.before,
      checkedRuleName: ruleName,
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-list-max-empty-lines" id="apidoc.element.stylelint.rules.value-list-max-empty-lines">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-list-max-empty-lines
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-list-max-empty-lines = function (max) {
  const maxAdjacentNewlines = max + 1

  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, {
      actual: max,
      possible: _.isNumber,
    })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      const value = decl.value
      const repeatLFNewLines = _.repeat(&#x22;\n&#x22;, maxAdjacentNewlines)
      const repeatCRLFNewLines = _.repeat(&#x22;\r\n&#x22;, maxAdjacentNewlines)

      styleSearch({ source: value, target: &#x22;\n&#x22; }, match =&#x3e; {
        if (value.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || value.substr(match.startIndex + 1, maxAdjacentNewlines
 * 2) === repeatCRLFNewLines) {
          // Put index at `\r` if it&#x27;s CRLF, otherwise leave it at `\n`
          let index = match.startIndex
          if (value[index - 1] === &#x22;\r&#x22;) {
            index -= 1
          }

          report({
            message: messages.expected(max),
            node: decl,
            index,
            result,
            ruleName,
          })
        }
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.rules.value-no-vendor-prefix" id="apidoc.element.stylelint.rules.value-no-vendor-prefix">
        function <span class="apidocSignatureSpan">stylelint.rules.</span>value-no-vendor-prefix
        <span class="apidocSignatureSpan">(actual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value-no-vendor-prefix = function (actual) {
  return (root, result) =&#x3e; {
    const validOptions = validateOptions(result, ruleName, { actual })
    if (!validOptions) {
      return
    }

    root.walkDecls(decl =&#x3e; {
      if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop) || decl.value[0] !== &#x22;-&#x22;) {
        return
      }

      const prop = decl.prop,
        value = decl.value

      // Search the full declaration in order to get an accurate index

      styleSearch({ source: value.toLowerCase(), target: valuePrefixes }, match =&#x3e; {
        const fullIdentifier = /^(-[a-z-]+)\b/i.exec(value.slice(match.startIndex))[1]
        if (!isAutoprefixable.propertyValue(prop, fullIdentifier)) {
          return
        }

        report({
          message: messages.rejected(fullIdentifier),
          node: decl,
          index: prop.length + (decl.raws.between || &#x22;&#x22;).length + match.startIndex,
          result,
          ruleName,
        })
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.stylelint.utils" id="apidoc.module.stylelint.utils">module stylelint.utils</a></h1>


    <h2>
        <a href="#apidoc.element.stylelint.utils.checkAgainstRule" id="apidoc.element.stylelint.utils.checkAgainstRule">
        function <span class="apidocSignatureSpan">stylelint.utils.</span>checkAgainstRule
        <span class="apidocSignatureSpan">( options, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAgainstRule = function ( options, callback ) {
  if (!options) throw new Error(&#x22;checkAgainstRule requires an options object with &#x27;ruleName&#x27;, &#x27;ruleSettings&#x27;, and &#x27;root&#x27; properties
&#x22;)
  if (!callback) throw new Error(&#x22;checkAgainstRule requires a callback&#x22;)
  if (!options.ruleName) throw new Error(&#x22;checkAgainstRule requires a &#x27;ruleName&#x27; option&#x22;)
  if (!rules[options.ruleName]) throw new Error(`Rule &#x27;${options.ruleName}&#x27; does not exist`)
  if (!options.ruleSettings) throw new Error(&#x22;checkAgainstRule requires a &#x27;ruleSettings&#x27; option&#x22;)
  if (!options.root) throw new Error(&#x22;checkAgainstRule requires a &#x27;root&#x27; option&#x22;)

  const settings = normalizeRuleSettings(options.ruleSettings, options.ruleName)
  if (!settings) { return }

  const tmpPostcssResult = new Result()
  rules[options.ruleName](settings[0], settings[1])(options.root, tmpPostcssResult)
  tmpPostcssResult.warnings().forEach(callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.utils.report" id="apidoc.element.stylelint.utils.report">
        function <span class="apidocSignatureSpan">stylelint.utils.</span>report
        <span class="apidocSignatureSpan">(violation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function (violation) {
  const ruleName = violation.ruleName
  const result = violation.result
  const message = violation.message
  const line = violation.line
  const node = violation.node
  const index = violation.index
  const word = violation.word

  result.stylelint = result.stylelint || {}

  // In quiet mode, mere warnings are ignored
  if (result.stylelint.quiet &#x26;&#x26; result.stylelint.ruleSeverities[ruleName] !== &#x22;error&#x22;) {
    return
  }

  // If a line is not passed, use the node.positionBy method to get the
  // line number that the complaint pertains to
  const startLine = line || node.positionBy({ index }).line

  if (result.stylelint.disabledRanges &#x26;&#x26; !result.stylelint.ignoreDisables) {
    const ranges = result.stylelint.disabledRanges[ruleName] || result.stylelint.disabledRanges.all
    for (const range of ranges) {
      if (
      // If the violation is within a disabledRange,
      // and that disabledRange&#x27;s rules include this one,
      // do not register a warning
      range.start &#x3c;= startLine &#x26;&#x26; (range.end &#x3e;= startLine || range.end === undefined) &#x26;&#x26; (!range.rules || range.rules.indexOf(ruleName
) !== -1)) {
        return
      }
    }
  }

  const severity = _.get(result.stylelint, [ &#x22;ruleSeverities&#x22;, ruleName ], &#x22;ignore&#x22;)

  if (!result.stylelint.stylelintError &#x26;&#x26; severity === &#x22;error&#x22;) {
    result.stylelint.stylelintError = true
  }

  const warningProperties/*: Object*/ = {
    severity,
    rule: ruleName,
  }
  if (node) {
    warningProperties.node = node
  }
  if (index) {
    warningProperties.index = index
  }
  if (word) {
    warningProperties.word = word
  }

  const warningMessage = _.get(result.stylelint, [ &#x22;customMessages&#x22;, ruleName ], message)
  result.warn(warningMessage, warningProperties)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.utils.ruleMessages" id="apidoc.element.stylelint.utils.ruleMessages">
        function <span class="apidocSignatureSpan">stylelint.utils.</span>ruleMessages
        <span class="apidocSignatureSpan">( ruleName, messages )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ruleMessages = function ( ruleName, messages )/*: Object*/ {
  return Object.keys(messages).reduce((newMessages, messageId) =&#x3e; {
    const messageText = messages[messageId]
    if (typeof messageText === &#x22;string&#x22;) {
      newMessages[messageId] = `${messageText} (${ruleName})`
    } else {
      newMessages[messageId] = function () {
        return `${messageText.apply(null, arguments)} (${ruleName})`
      }
    }
    return newMessages
  }, {})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.stylelint.utils.validateOptions" id="apidoc.element.stylelint.utils.validateOptions">
        function <span class="apidocSignatureSpan">stylelint.utils.</span>validateOptions
        <span class="apidocSignatureSpan">( result, ruleName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateOptions = function ( result, ruleName )/*: boolean*/ {
  let noErrors = true

  const optionDescriptions = Array.from(arguments).slice(2)

  optionDescriptions.forEach(optionDescription =&#x3e; {
    validate(optionDescription, ruleName, complain)
  })

  function complain(message) {
    noErrors = false
    result.warn(message, {
      stylelintType: &#x22;invalidOption&#x22;,
    })
    _.set(result, &#x22;stylelint.stylelintError&#x22;, true)
  }

  return noErrors
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
